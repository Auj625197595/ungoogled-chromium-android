From: Wengling Chen <feiyu2817@gmail.com>
Date: Sat, 30 May 2020 18:25:38 -0400
Subject: source code fixes for enable_extensions=true

---
 android_webview/browser/aw_browser_context.cc                                                                   |    6 
 android_webview/browser/aw_browser_context.h                                                                    |    2 
 base/process/kill.h                                                                                             |    2 
 base/process/kill_posix.cc                                                                                      |    2 
 chrome/android/java/src/org/chromium/chrome/browser/payments/ChromePaymentRequestService.java                   |   10 
 chrome/browser/about_flags.cc                                                                                   |    2 
 chrome/browser/apps/platform_apps/api/music_manager_private/device_id_linux.cc                                  |   16 
 chrome/browser/browser_features.cc                                                                              |    2 
 chrome/browser/browser_features.h                                                                               |    2 
 chrome/browser/chrome_browser_main_posix.cc                                                                     |    2 
 chrome/browser/chrome_content_browser_client.cc                                                                 |    4 
 chrome/browser/content_settings/host_content_settings_map_factory.cc                                            |    1 
 chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc                                  |    8 
 chrome/browser/custom_handlers/register_protocol_handler_permission_request.h                                   |    1 
 chrome/browser/devtools/chrome_devtools_manager_delegate.h                                                      |    2 
 chrome/browser/devtools/devtools_ui_bindings.cc                                                                 |   11 
 chrome/browser/devtools/devtools_window.cc                                                                      |    1 
 chrome/browser/download/download_commands.cc                                                                    |    6 
 chrome/browser/download/download_commands.h                                                                     |    4 
 chrome/browser/download/download_ui_model.cc                                                                    |    4 
 chrome/browser/download/download_ui_model.h                                                                     |    4 
 chrome/browser/download/drag_download_item_aura.cc                                                              |   26 
 chrome/browser/engagement/important_sites_util.cc                                                               |    5 
 chrome/browser/engagement/important_sites_util.h                                                                |    2 
 chrome/browser/enterprise/reporting/prefs.cc                                                                    |    1 
 chrome/browser/enterprise/reporting/report_scheduler_desktop.cc                                                 |    5 
 chrome/browser/extensions/api/downloads/downloads_api.cc                                                        |    1 
 chrome/browser/extensions/api/image_writer_private/removable_storage_provider_linux.cc                          |  104 -
 chrome/browser/extensions/api/messaging/native_messaging_host_manifest.cc                                       |   13 
 chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc                       |   20 
 chrome/browser/extensions/api/settings_private/prefs_util.cc                                                    |    2 
 chrome/browser/extensions/api/tabs/windows_event_router.cc                                                      |    2 
 chrome/browser/extensions/extension_management.cc                                                               |    2 
 chrome/browser/extensions/extension_system_factory.cc                                                           |    3 
 chrome/browser/extensions/global_shortcut_listener_ozone.cc                                                     |   27 
 chrome/browser/extensions/global_shortcut_listener_ozone.h                                                      |   16 
 chrome/browser/extensions/system_display/display_info_provider_aura.cc                                          |    4 
 chrome/browser/extensions/system_display/display_info_provider_aura.h                                           |   12 
 chrome/browser/first_run/first_run_internal_posix.cc                                                            |    2 
 chrome/browser/first_run/upgrade_util.h                                                                         |    2 
 chrome/browser/flag_descriptions.cc                                                                             |    1 
 chrome/browser/flag_descriptions.h                                                                              |    1 
 chrome/browser/hid/hid_chooser_context.cc                                                                       |    5 
 chrome/browser/intranet_redirect_detector.h                                                                     |    5 
 chrome/browser/lifetime/application_lifetime.cc                                                                 |   22 
 chrome/browser/lifetime/application_lifetime.h                                                                  |    4 
 chrome/browser/lifetime/browser_shutdown.cc                                                                     |    6 
 chrome/browser/lifetime/browser_shutdown.h                                                                      |    4 
 chrome/browser/media/router/media_router_feature.cc                                                             |    7 
 chrome/browser/media/router/media_router_feature.h                                                              |    3 
 chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc                                                 |    9 
 chrome/browser/metrics/thread_watcher.cc                                                                        |    8 
 chrome/browser/metrics/thread_watcher.h                                                                         |    2 
 chrome/browser/metrics/thread_watcher_report_hang.cc                                                            |    2 
 chrome/browser/metrics/thread_watcher_report_hang.h                                                             |    2 
 chrome/browser/nearby_sharing/nearby_notification_manager.cc                                                    |    1 
 chrome/browser/nearby_sharing/share_target.cc                                                                   |    4 
 chrome/browser/password_manager/multi_profile_credentials_filter.cc                                             |    3 
 chrome/browser/performance_manager/policies/policy_features.cc                                                  |    2 
 chrome/browser/performance_manager/policies/policy_features.h                                                   |    2 
 chrome/browser/permissions/attestation_permission_request.cc                                                    |    7 
 chrome/browser/platform_util.cc                                                                                 |   18 
 chrome/browser/platform_util_android.cc                                                                         |    6 
 chrome/browser/policy/browser_dm_token_storage_linux.cc                                                         |   18 
 chrome/browser/policy/browser_dm_token_storage_linux.h                                                          |   26 
 chrome/browser/policy/chrome_browser_cloud_management_controller_desktop.cc                                     |    6 
 chrome/browser/policy/chrome_browser_policy_connector.cc                                                        |   10 
 chrome/browser/policy/chrome_browser_policy_connector.h                                                         |    6 
 chrome/browser/prefs/browser_prefs.cc                                                                           |    8 
 chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc                                             |   32 
 chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h                                              |    2 
 chrome/browser/profiles/off_the_record_profile_impl.cc                                                          |    9 
 chrome/browser/profiles/off_the_record_profile_impl.h                                                           |   10 
 chrome/browser/profiles/profile.cc                                                                              |   10 
 chrome/browser/profiles/profile.h                                                                               |    6 
 chrome/browser/profiles/profile_attributes_storage.cc                                                           |    4 
 chrome/browser/profiles/profile_attributes_storage.h                                                            |    2 
 chrome/browser/profiles/profile_impl.cc                                                                         |    5 
 chrome/browser/profiles/profile_impl.h                                                                          |    6 
 chrome/browser/profiles/profile_manager.cc                                                                      |   23 
 chrome/browser/profiles/profile_manager.h                                                                       |   12 
 chrome/browser/profiles/profile_metrics.cc                                                                      |    6 
 chrome/browser/profiles/profile_window.cc                                                                       |    4 
 chrome/browser/profiles/profile_window.h                                                                        |    3 
 chrome/browser/profiles/profiles_state.cc                                                                       |    4 
 chrome/browser/profiles/profiles_state.h                                                                        |    2 
 chrome/browser/renderer_context_menu/render_view_context_menu.cc                                                |   10 
 chrome/browser/renderer_context_menu/render_view_context_menu.h                                                 |    8 
 chrome/browser/resource_coordinator/resource_coordinator_parts.cc                                               |    4 
 chrome/browser/resource_coordinator/resource_coordinator_parts.h                                                |    8 
 chrome/browser/search/instant_service.h                                                                         |    2 
 chrome/browser/search/instant_service_factory.h                                                                 |    2 
 chrome/browser/search/instant_service_observer.h                                                                |    2 
 chrome/browser/search/local_ntp_source.h                                                                        |    2 
 chrome/browser/search/most_visited_iframe_source.h                                                              |    2 
 chrome/browser/sessions/session_restore.cc                                                                      |   25 
 chrome/browser/sharing/shared_clipboard/feature_flags.cc                                                        |    2 
 chrome/browser/sharing/shared_clipboard/feature_flags.h                                                         |    2 
 chrome/browser/startup_data.cc                                                                                  |    5 
 chrome/browser/storage/storage_notification_service_impl.cc                                                     |    2 
 chrome/browser/supervised_user/supervised_user_service_factory.cc                                               |    1 
 chrome/browser/sync/profile_sync_service_factory.cc                                                             |    2 
 chrome/browser/ui/aura/native_window_tracker_aura.cc                                                            |   19 
 chrome/browser/ui/aura/native_window_tracker_aura.h                                                             |   21 
 chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc                                                           |    6 
 chrome/browser/ui/browser.cc                                                                                    |    6 
 chrome/browser/ui/browser.h                                                                                     |    4 
 chrome/browser/ui/browser_commands.cc                                                                           |    1 
 chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc                                              |    3 
 chrome/browser/ui/browser_dialogs.cc                                                                            |    2 
 chrome/browser/ui/browser_instant_controller.h                                                                  |    2 
 chrome/browser/ui/browser_list.h                                                                                |    4 
 chrome/browser/ui/browser_list_observer.h                                                                       |    4 
 chrome/browser/ui/browser_navigator_params.cc                                                                   |    2 
 chrome/browser/ui/browser_navigator_params.h                                                                    |    6 
 chrome/browser/ui/browser_tab_strip_model_delegate.cc                                                           |    4 
 chrome/browser/ui/browser_ui_prefs.cc                                                                           |    2 
 chrome/browser/ui/browser_window.h                                                                              |    2 
 chrome/browser/ui/chrome_pages.cc                                                                               |    4 
 chrome/browser/ui/chrome_pages.h                                                                                |    4 
 chrome/browser/ui/content_settings/content_setting_bubble_model.cc                                              |   11 
 chrome/browser/ui/content_settings/content_setting_bubble_model.h                                               |    2 
 chrome/browser/ui/content_settings/content_setting_image_model.cc                                               |    2 
 chrome/browser/ui/global_error/global_error.cc                                                                  |    2 
 chrome/browser/ui/native_file_system_dialogs.cc                                                                 |    2 
 chrome/browser/ui/omnibox/chrome_omnibox_navigation_observer.cc                                                 |   10 
 chrome/browser/ui/passwords/manage_passwords_view_utils.cc                                                      |    4 
 chrome/browser/ui/passwords/password_generation_popup_controller_impl.cc                                        |    2 
 chrome/browser/ui/passwords/password_generation_popup_controller_impl.h                                         |    6 
 chrome/browser/ui/passwords/settings/password_manager_presenter.cc                                              |    6 
 chrome/browser/ui/passwords/settings/password_manager_presenter.h                                               |    2 
 chrome/browser/ui/search/instant_controller.h                                                                   |    2 
 chrome/browser/ui/search/ntp_user_data_logger.h                                                                 |    2 
 chrome/browser/ui/search/search_ipc_router.h                                                                    |    2 
 chrome/browser/ui/search/search_ipc_router_policy_impl.h                                                        |    2 
 chrome/browser/ui/search/search_tab_helper.h                                                                    |    2 
 chrome/browser/ui/signin_view_controller.h                                                                      |    4 
 chrome/browser/ui/tabs/tab_strip_model.h                                                                        |    4 
 chrome/browser/ui/views/accelerator_utils_aura.cc                                                               |   14 
 chrome/browser/ui/views/autofill/payments/save_card_manage_cards_bubble_views.cc                                |   17 
 chrome/browser/ui/views/autofill/payments/save_card_sign_in_promo_bubble_views.cc                               |    2 
 chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc                                                       |    2 
 chrome/browser/ui/views/browser_dialogs_views.cc                                                                |    9 
 chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc                                              |    2 
 chrome/browser/ui/views/dropdown_bar_host_aura.cc                                                               |    4 
 chrome/browser/ui/views/extensions/extension_installed_bubble_view.cc                                           |    6 
 chrome/browser/ui/views/frame/browser_frame.cc                                                                  |    5 
 chrome/browser/ui/views/frame/browser_view.cc                                                                   |    3 
 chrome/browser/ui/views/frame/desktop_browser_frame_aura.cc                                                     |   80 
 chrome/browser/ui/views/frame/desktop_browser_frame_aura.h                                                      |   26 
 chrome/browser/ui/views/frame/native_browser_frame_factory_aurax11.cc                                           |    4 
 chrome/browser/ui/views/hats/hats_bubble_view.cc                                                                |    9 
 chrome/browser/ui/views/hats/hats_next_web_dialog.cc                                                            |   11 
 chrome/browser/ui/views/intent_picker_bubble_view.cc                                                            |   14 
 chrome/browser/ui/views/location_bar/location_bar_view.cc                                                       |    2 
 chrome/browser/ui/views/location_bar/permission_chip.cc                                                         |   16 
 chrome/browser/ui/views/location_bar/permission_chip.h                                                          |    1 
 chrome/browser/ui/views/page_action/page_action_icon_controller.cc                                              |   22 
 chrome/browser/ui/views/page_info/page_info_bubble_view.cc                                                      |    1 
 chrome/browser/ui/views/payments/cvc_unmask_view_controller.cc                                                  |   13 
 chrome/browser/ui/views/payments/cvc_unmask_view_controller.h                                                   |    5 
 chrome/browser/ui/views/payments/secure_payment_confirmation_view.cc                                            |    8 
 chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc                                      |    4 
 chrome/browser/ui/views/profiles/profile_menu_view.cc                                                           |   23 
 chrome/browser/ui/views/profiles/profile_menu_view.h                                                            |    4 
 chrome/browser/ui/views/profiles/profile_picker_view.cc                                                         |   13 
 chrome/browser/ui/views/profiles/profile_picker_view_sync_delegate.cc                                           |   15 
 chrome/browser/ui/views/status_icons/status_icon_button_linux.cc                                                |   14 
 chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc                                                     |   16 
 chrome/browser/ui/webui/history/foreign_session_handler.cc                                                      |    1 
 chrome/browser/ui/webui/omnibox/omnibox_ui.cc                                                                   |    4 
 chrome/browser/ui/webui/omnibox/omnibox_ui.h                                                                    |    6 
 chrome/browser/ui/webui/settings/people_handler.cc                                                              |   15 
 chrome/browser/ui/webui/settings/people_handler.h                                                               |    7 
 chrome/browser/ui/webui/settings/settings_ui.cc                                                                 |    8 
 chrome/browser/ui/webui/settings/system_handler.cc                                                              |    1 
 chrome/browser/ui/webui/signin/inline_login_handler_impl.cc                                                     |   34 
 chrome/browser/ui/webui/signin/login_ui_service.cc                                                              |   11 
 chrome/browser/ui/webui/welcome/welcome_handler.cc                                                              |    3 
 chrome/browser/web_applications/components/web_app_file_handler_registration.cc                                 |    2 
 chrome/browser/web_applications/components/web_app_shortcut_linux.cc                                            |  435 ----
 chrome/browser/web_applications/components/web_app_shortcut_linux.h                                             |    6 
 chrome/browser/web_applications/extensions/bookmark_app_provider.cc                                             |    5 
 chrome/common/chrome_features.cc                                                                                |    8 
 chrome/common/chrome_features.h                                                                                 |   10 
 chrome/common/chrome_paths.cc                                                                                   |    2 
 chrome/common/chrome_paths.h                                                                                    |    2 
 chrome/common/chrome_switches.cc                                                                                |    4 
 chrome/common/chrome_switches.h                                                                                 |    4 
 chrome/common/importer/firefox_importer_utils.cc                                                                |    4 
 chrome/common/pref_names.cc                                                                                     |   25 
 chrome/common/pref_names.h                                                                                      |   25 
 chrome/common/webui_url_constants.cc                                                                            |    9 
 chrome/common/webui_url_constants.h                                                                             |    9 
 chromecast/browser/cast_browser_context.cc                                                                      |    2 
 chromecast/browser/cast_browser_context.h                                                                       |    2 
 components/autofill/core/browser/form_data_importer.cc                                                          |    6 
 components/autofill/core/browser/form_data_importer.h                                                           |    6 
 components/autofill/core/browser/payments/local_card_migration_manager.cc                                       |   17 
 components/autofill/core/browser/payments/upi_vpa_save_manager.cc                                               |    7 
 components/bookmarks/browser/bookmark_node_data.h                                                               |    8 
 components/embedder_support/android/java/src/org/chromium/components/embedder_support/util/Origin.java          |   13 
 components/embedder_support/android/java/src/org/chromium/components/embedder_support/util/UrlConstants.java    |    1 
 components/enterprise/browser/enterprise_switches.cc                                                            |    2 
 components/enterprise/browser/enterprise_switches.h                                                             |    2 
 components/feature_engagement/public/event_constants.cc                                                         |    2 
 components/feature_engagement/public/event_constants.h                                                          |    2 
 components/feature_engagement/public/feature_constants.cc                                                       |    2 
 components/feature_engagement/public/feature_constants.h                                                        |    2 
 components/media_router/browser/android/media_router_android.cc                                                 |    4 
 components/media_router/browser/android/media_router_android.h                                                  |    6 
 components/media_router/browser/media_router.h                                                                  |    4 
 components/media_router/browser/media_router_base.cc                                                            |    2 
 components/media_router/browser/media_router_base.h                                                             |    4 
 components/omnibox/browser/autocomplete_match.cc                                                                |    4 
 components/omnibox/browser/autocomplete_match.h                                                                 |    2 
 components/omnibox/browser/omnibox_pedal.cc                                                                     |    4 
 components/omnibox/browser/omnibox_pedal.h                                                                      |    4 
 components/omnibox/browser/omnibox_pedal_implementations.cc                                                     |    2 
 components/omnibox/browser/omnibox_popup_model.cc                                                               |    4 
 components/omnibox/browser/omnibox_popup_model.h                                                                |    2 
 components/page_info/page_info_ui.cc                                                                            |    8 
 components/page_info/page_info_ui.h                                                                             |    3 
 components/payments/content/android/java/src/org/chromium/components/payments/InvalidPaymentRequest.java        |    3 
 components/payments/content/android/java/src/org/chromium/components/payments/MojoPaymentRequestGateKeeper.java |    4 
 components/permissions/permission_request.cc                                                                    |    2 
 components/permissions/permission_request.h                                                                     |    2 
 components/permissions/permission_request_impl.cc                                                               |    2 
 components/permissions/permission_request_impl.h                                                                |    2 
 components/policy/resources/policy_templates.json                                                               |    8 
 components/search/search.cc                                                                                     |    2 
 components/ui_devtools/views/overlay_agent_views.cc                                                             |   34 
 components/url_formatter/elide_url.cc                                                                           |    4 
 components/url_formatter/elide_url.h                                                                            |    2 
 content/browser/media/session/audio_focus_delegate_default.cc                                                   |    7 
 content/browser/renderer_host/native_web_keyboard_event_android.cc                                              |    2 
 content/browser/storage_partition_impl.cc                                                                       |    4 
 content/browser/storage_partition_impl.h                                                                        |    6 
 content/browser/tracing/generate_trace_viewer_grd.py                                                            |    2 
 content/browser/web_contents/web_contents_impl.cc                                                               |    3 
 content/browser/web_contents/web_contents_impl.h                                                                |    2 
 content/public/browser/browser_context.h                                                                        |    4 
 content/public/browser/content_browser_client.cc                                                                |    4 
 content/public/browser/content_browser_client.h                                                                 |    4 
 content/public/browser/desktop_media_id.cc                                                                      |    6 
 content/public/browser/desktop_media_id.h                                                                       |    2 
 content/public/browser/native_web_keyboard_event.h                                                              |    1 
 content/public/browser/storage_partition.h                                                                      |    4 
 content/shell/browser/shell_browser_context.cc                                                                  |    2 
 content/shell/browser/shell_browser_context.h                                                                   |    4 
 extensions/browser/api/device_permissions_prompt.cc                                                             |    2 
 extensions/browser/api/hid/hid_device_manager.cc                                                                |    2 
 extensions/browser/guest_view/web_view/web_view_guest.cc                                                        |    1 
 extensions/renderer/bindings/api_binding_util.cc                                                                |    2 
 third_party/blink/public/mojom/payments/payment_request.mojom                                                   |    3 
 third_party/blink/renderer/modules/payments/payment_request.cc                                                  |    2 
 third_party/skia/src/gpu/ops/GrSimpleMeshDrawOpHelper.cpp                                                       |    1 
 tools/grit/grit/tool/build.py                                                                                   |    2 
 ui/android/window_android.cc                                                                                    |   28 
 ui/android/window_android.h                                                                                     |   17 
 ui/base/dragdrop/os_exchange_data.h                                                                             |    4 
 ui/base/dragdrop/os_exchange_data_provider.h                                                                    |    6 
 ui/base/dragdrop/os_exchange_data_provider_factory.cc                                                           |    4 
 ui/base/dragdrop/os_exchange_data_provider_non_backed.cc                                                        |   62 
 ui/base/dragdrop/os_exchange_data_provider_non_backed.h                                                         |   18 
 ui/events/event.h                                                                                               |    1 
 ui/native_theme/native_theme_android.cc                                                                         |    3 
 ui/native_theme/native_theme_android.h                                                                          |    2 
 ui/views/bubble/bubble_dialog_delegate_view.cc                                                                  |   12 
 ui/views/controls/menu/menu_controller.h                                                                        |    1 
 ui/views/controls/menu/menu_host.cc                                                                             |    8 
 ui/views/controls/menu/menu_host.h                                                                              |    2 
 ui/views/controls/menu/menu_pre_target_handler_aura.cc                                                          |   48 
 ui/views/controls/menu/menu_pre_target_handler_aura.h                                                           |   37 
 ui/views/controls/native/native_view_host_aura.cc                                                               |  373 ---
 ui/views/controls/native/native_view_host_aura.h                                                                |   32 
 ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc                                           |    2 
 ui/views/drag_utils_aura.cc                                                                                     |   13 
 ui/views/event_monitor_aura.cc                                                                                  |   49 
 ui/views/event_monitor_aura.h                                                                                   |   14 
 ui/views/native_cursor_aura.cc                                                                                  |   11 
 ui/views/painter.cc                                                                                             |    1 
 ui/views/touchui/touch_selection_controller_impl.cc                                                             |   35 
 ui/views/widget/native_widget_aura.cc                                                                           |  975 +---------
 ui/views/widget/native_widget_aura.h                                                                            |  104 -
 ui/views/widget/tooltip_manager_aura.cc                                                                         |  106 -
 ui/views/widget/tooltip_manager_aura.h                                                                          |   18 
 ui/views/widget/widget.cc                                                                                       |    5 
 weblayer/browser/browser_context_impl.cc                                                                        |    2 
 weblayer/browser/browser_context_impl.h                                                                         |    2 
 290 files changed, 952 insertions(+), 3233 deletions(-)

--- a/ui/base/dragdrop/os_exchange_data_provider_factory.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_factory.cc
@@ -22,6 +22,8 @@
 #include "ui/base/dragdrop/os_exchange_data_provider_win.h"
 #endif
 
+#include "ui/base/dragdrop/os_exchange_data_provider_non_backed.h"
+
 namespace ui {
 
 namespace {
@@ -66,6 +68,8 @@ OSExchangeDataProviderFactory::CreatePro
   // TODO(crbug.com/980371): Implement OSExchangeDataProvider for Fuchsia.
   NOTIMPLEMENTED();
   return nullptr;
+#elif defined(OS_ANDROID)
+  return std::make_unique<OSExchangeDataProviderAndroid>();
 #else
 #error "Unknown operating system"
 #endif
--- a/chrome/browser/media/router/media_router_feature.cc
+++ b/chrome/browser/media/router/media_router_feature.cc
@@ -22,13 +22,10 @@
 #include "media/base/media_switches.h"
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
 #include "components/prefs/pref_registry_simple.h"
-#endif
 
 namespace media_router {
 
-#if !defined(OS_ANDROID)
 #if !defined(OFFICIAL_BUILD)
 // Enables the media router. Can be useful to disable for local
 // development on Mac because DIAL local discovery opens a local port
@@ -47,7 +44,6 @@ const base::Feature kGlobalMediaControls
     "GlobalMediaControlsCastStartStop", base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kAllowAllSitesToInitiateMirroring{
     "AllowAllSitesToInitiateMirroring", base::FEATURE_DISABLED_BY_DEFAULT};
-#endif  // !defined(OS_ANDROID)
 
 #if defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 namespace {
@@ -82,7 +78,6 @@ bool MediaRouterEnabled(content::Browser
 #endif  // defined(OS_ANDROID) || BUILDFLAG(ENABLE_EXTENSIONS)
 }
 
-#if !defined(OS_ANDROID)
 void RegisterLocalStatePrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kMediaRouterCastAllowAllIPs, false,
                                 PrefRegistry::PUBLIC);
@@ -136,6 +131,4 @@ bool GlobalMediaControlsCastStartStopEna
              media::kGlobalMediaControlsOverlayControls);
 }
 
-#endif  // !defined(OS_ANDROID)
-
 }  // namespace media_router
--- a/chrome/browser/media/router/media_router_feature.h
+++ b/chrome/browser/media/router/media_router_feature.h
@@ -19,8 +19,6 @@ namespace media_router {
 // Returns true if Media Router is enabled for |context|.
 bool MediaRouterEnabled(content::BrowserContext* context);
 
-#if !defined(OS_ANDROID)
-
 // TODO(crbug.com/1028753): Remove default-enabled kDialMediaRouteProvider after
 // tests stop disabling it.
 extern const base::Feature kDialMediaRouteProvider;
@@ -73,7 +71,6 @@ bool CastMediaRouteProviderEnabled();
 
 // Returns true if global media controls are used to start and stop casting.
 bool GlobalMediaControlsCastStartStopEnabled();
-#endif  // !defined(OS_ANDROID)
 
 }  // namespace media_router
 
--- a/chrome/browser/ui/browser.h
+++ b/chrome/browser/ui/browser.h
@@ -56,10 +56,6 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class BackgroundContents;
 class BrowserContentSettingBubbleModelDelegate;
 class BrowserInstantController;
--- a/chrome/browser/ui/signin_view_controller.h
+++ b/chrome/browser/ui/signin_view_controller.h
@@ -21,10 +21,6 @@
 #include "chrome/browser/ui/webui/signin/signin_email_confirmation_dialog.h"
 #endif
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Browser;
 struct CoreAccountId;
 
--- a/chrome/browser/ui/tabs/tab_strip_model.h
+++ b/chrome/browser/ui/tabs/tab_strip_model.h
@@ -31,10 +31,6 @@
 #include "ui/base/models/list_selection_model.h"
 #include "ui/base/page_transition_types.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Profile;
 class TabGroupModel;
 class TabStripModelDelegate;
--- a/extensions/browser/guest_view/web_view/web_view_guest.cc
+++ b/extensions/browser/guest_view/web_view/web_view_guest.cc
@@ -153,6 +153,7 @@ static std::string TerminationStatusToSt
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED_BY_OOM:
       return "oom killed";
 #endif
+    case base::TERMINATION_STATUS_OOM_PROTECTED:
     case base::TERMINATION_STATUS_OOM:
       return "oom";
     case base::TERMINATION_STATUS_PROCESS_WAS_KILLED:
--- a/extensions/browser/api/device_permissions_prompt.cc
+++ b/extensions/browser/api/device_permissions_prompt.cc
@@ -223,8 +223,6 @@ class HidDevicePermissionsPrompt : publi
     const auto& binder = GetHidManagerBinderOverride();
     if (binder)
       binder.Run(std::move(receiver));
-    else
-      content::GetDeviceService().BindHidManager(std::move(receiver));
 
     hid_manager_->GetDevicesAndSetClient(
         receiver_.BindNewEndpointAndPassRemote(),
--- a/extensions/browser/api/hid/hid_device_manager.cc
+++ b/extensions/browser/api/hid/hid_device_manager.cc
@@ -296,8 +296,6 @@ void HidDeviceManager::LazyInitialize()
     const auto& binder = GetHidManagerBinderOverride();
     if (binder)
       binder.Run(std::move(receiver));
-    else
-      content::GetDeviceService().BindHidManager(std::move(receiver));
   }
   // Enumerate HID devices and set client.
   std::vector<device::mojom::HidDeviceInfoPtr> empty_devices;
--- a/ui/base/dragdrop/os_exchange_data.h
+++ b/ui/base/dragdrop/os_exchange_data.h
@@ -60,7 +60,7 @@ class COMPONENT_EXPORT(UI_BASE) OSExchan
 #if defined(OS_WIN)
     FILE_CONTENTS  = 1 << 4,
 #endif
-#if defined(USE_AURA)
+#if defined(USE_AURA) || defined(OS_ANDROID)
     HTML           = 1 << 5,
 #endif
   };
@@ -179,7 +179,7 @@ class COMPONENT_EXPORT(UI_BASE) OSExchan
       const;
 #endif
 
-#if defined(USE_AURA)
+#if defined(USE_AURA) || defined(OS_ANDROID)
   // Adds a snippet of HTML.  |html| is just raw html but this sets both
   // text/html and CF_HTML.
   void SetHtml(const base::string16& html, const GURL& base_url);
--- a/ui/views/controls/menu/menu_host.cc
+++ b/ui/views/controls/menu/menu_host.cc
@@ -31,7 +31,7 @@ namespace views {
 
 namespace internal {
 
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_ANDROID)
 // This class adds itself as the pre target handler for the |window|
 // passed in. It currently handles touch events and forwards them to the
 // controller. Reason for this approach is views does not get raw touch
@@ -81,7 +81,7 @@ class PreMenuEventDispatchHandler : publ
 #endif  // OS_APPLE
 
 void TransferGesture(Widget* source, Widget* target) {
-#if defined(OS_APPLE)
+#if defined(OS_APPLE) || defined(OS_ANDROID)
   NOTIMPLEMENTED();
 #else   // !defined(OS_APPLE)
   source->GetGestureRecognizer()->TransferEventsTo(
@@ -138,7 +138,7 @@ void MenuHost::InitMenuHost(Widget* pare
 #endif
   Init(std::move(params));
 
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_ANDROID)
   pre_dispatch_handler_ =
       std::make_unique<internal::PreMenuEventDispatchHandler>(
           menu_controller, submenu_, GetNativeView());
@@ -198,7 +198,7 @@ void MenuHost::DestroyMenuHost() {
   HideMenuHost();
   destroying_ = true;
   static_cast<MenuHostRootView*>(GetRootView())->ClearSubmenu();
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_ANDROID)
   pre_dispatch_handler_.reset();
 #endif
   Close();
--- a/ui/events/event.h
+++ b/ui/events/event.h
@@ -16,6 +16,7 @@
 #include "base/macros.h"
 #include "base/strings/string16.h"
 #include "base/time/time.h"
+#include "ui/android/window_android.h"
 #include "ui/events/event_constants.h"
 #include "ui/events/gesture_event_details.h"
 #include "ui/events/gestures/gesture_types.h"
--- a/ui/views/controls/menu/menu_controller.h
+++ b/ui/views/controls/menu/menu_controller.h
@@ -18,6 +18,7 @@
 #include "base/memory/weak_ptr.h"
 #include "base/timer/timer.h"
 #include "build/build_config.h"
+#include "ui/android/window_android.h"
 #include "ui/events/event.h"
 #include "ui/events/event_constants.h"
 #include "ui/events/platform/platform_event_dispatcher.h"
--- a/ui/views/controls/menu/menu_host.h
+++ b/ui/views/controls/menu/menu_host.h
@@ -95,7 +95,7 @@ class MenuHost : public Widget, public W
   // If true and capture is lost we don't notify the delegate.
   bool ignore_capture_lost_;
 
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_ANDROID)
   // Handles raw touch events at the moment.
   std::unique_ptr<internal::PreMenuEventDispatchHandler> pre_dispatch_handler_;
 #endif
--- a/ui/android/window_android.h
+++ b/ui/android/window_android.h
@@ -17,6 +17,7 @@
 #include "base/time/time.h"
 #include "ui/android/ui_android_export.h"
 #include "ui/android/view_android.h"
+#include "ui/events/event_target.h"
 #include "ui/gfx/geometry/vector2d_f.h"
 
 namespace display {
@@ -33,7 +34,8 @@ class WindowAndroidObserver;
 
 // Android implementation of the activity window.
 // WindowAndroid is also the root of a ViewAndroid tree.
-class UI_ANDROID_EXPORT WindowAndroid : public ViewAndroid {
+class UI_ANDROID_EXPORT WindowAndroid : public ViewAndroid,
+                           public ui::EventTarget {
  public:
   static WindowAndroid* FromJavaWindowAndroid(
       const base::android::JavaParamRef<jobject>& jwindow_android);
@@ -50,6 +52,13 @@ class UI_ANDROID_EXPORT WindowAndroid :
 
   base::android::ScopedJavaLocalRef<jobject> GetJavaObject();
 
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::PointF* point);
+  static void ConvertPointToTarget(const WindowAndroid* source,
+                                   const WindowAndroid* target,
+                                   gfx::Point* point);
+
   // Compositor callback relay.
   void OnCompositingDidCommit();
 
@@ -136,6 +145,12 @@ class UI_ANDROID_EXPORT WindowAndroid :
   // ViewAndroid overrides.
   WindowAndroid* GetWindowAndroid() const override;
 
+  // Overridden from ui::EventTarget:
+  bool CanAcceptEvent(const ui::Event& event) override;
+  EventTarget* GetParentTarget() override;
+  std::unique_ptr<ui::EventTargetIterator> GetChildIterator() const override;
+  ui::EventTargeter* GetEventTargeter() override;
+
   // The ID of the display that this window belongs to.
   int display_id() const { return display_id_; }
 
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -467,7 +467,7 @@
 #include "ui/accessibility/accessibility_features.h"
 #endif  // !defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/badging/badge_manager.h"
 #include "chrome/browser/devtools/chrome_devtools_manager_delegate.h"
 #include "chrome/browser/devtools/devtools_window.h"
@@ -1384,7 +1384,7 @@ ChromeContentBrowserClient::CreateBrowse
 #elif defined(OS_LINUX) && !defined(OS_CHROMEOS)
   main_parts->AddParts(
       std::make_unique<ChromeBrowserMainExtraPartsViewsLinux>());
-#else
+
   main_parts->AddParts(std::make_unique<ChromeBrowserMainExtraPartsViews>());
 #endif
 #endif
--- a/chrome/browser/devtools/chrome_devtools_manager_delegate.h
+++ b/chrome/browser/devtools/chrome_devtools_manager_delegate.h
@@ -13,8 +13,6 @@
 #include "base/compiler_specific.h"
 #include "base/macros.h"
 #include "chrome/browser/devtools/device/devtools_device_discovery.h"
-#include "chrome/browser/devtools/protocol/forward.h"
-#include "chrome/browser/devtools/protocol/protocol.h"
 #include "content/public/browser/devtools_agent_host_observer.h"
 #include "content/public/browser/devtools_manager_delegate.h"
 #include "net/base/host_port_pair.h"
--- a/chrome/browser/search/instant_service.h
+++ b/chrome/browser/search/instant_service.h
@@ -33,7 +33,7 @@
 #include "ui/native_theme/native_theme_observer.h"
 #include "url/gurl.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/search/instant_service_factory.h
+++ b/chrome/browser/search/instant_service_factory.h
@@ -10,7 +10,7 @@
 #include "build/build_config.h"
 #include "components/keyed_service/content/browser_context_keyed_service_factory.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/browser_window.h
+++ b/chrome/browser/ui/browser_window.h
@@ -31,7 +31,7 @@
 #include "ui/gfx/native_widget_types.h"
 #include "url/origin.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error This file should only be included on desktop.
 #endif
 
--- a/chrome/browser/extensions/api/messaging/native_messaging_host_manifest.cc
+++ b/chrome/browser/extensions/api/messaging/native_messaging_host_manifest.cc
@@ -136,19 +136,6 @@ bool NativeMessagingHostManifest::Parse(
     allowed_origins_.AddPattern(pattern);
   }
 
-  if (base::FeatureList::IsEnabled(features::kOnConnectNative)) {
-    if (const base::Value* supports_native_initiated_connections =
-            dictionary->FindKey("supports_native_initiated_connections")) {
-      if (!supports_native_initiated_connections->is_bool()) {
-        *error_message =
-            "supports_native_initiated_connections must be a boolean.";
-        return false;
-      }
-      supports_native_initiated_connections_ =
-          supports_native_initiated_connections->GetBool();
-    }
-  }
-
   return true;
 }
 
--- a/chrome/browser/extensions/api/downloads/downloads_api.cc
+++ b/chrome/browser/extensions/api/downloads/downloads_api.cc
@@ -52,6 +52,7 @@
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_list.h"
 #include "chrome/browser/ui/browser_window.h"
+#include "chrome/browser/ui/tabs/tab_strip_model.h"
 #include "chrome/common/extensions/api/downloads.h"
 #include "components/download/public/common/download_interrupt_reasons.h"
 #include "components/download/public/common/download_item.h"
--- a/chrome/browser/profiles/profile.cc
+++ b/chrome/browser/profiles/profile.cc
@@ -54,8 +54,8 @@
 #include "chrome/browser/profiles/android/jni_headers/OTRProfileID_jni.h"
 #endif
 
-#if !defined(OS_ANDROID)
-#include "chrome/browser/first_run/first_run.h"
+#if defined(OS_ANDROID)
+//#include "chrome/browser/first_run/first_run.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
 
@@ -256,7 +256,7 @@ TestingProfile* Profile::AsTestingProfil
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 ChromeZoomLevelPrefs* Profile::GetZoomLevelPrefs() {
   return nullptr;
 }
@@ -311,7 +311,7 @@ void Profile::RegisterProfilePrefs(user_
                                std::string());
   registry->RegisterStringPref(prefs::kAccessibilityCaptionsTextShadow,
                                std::string());
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   registry->RegisterDictionaryPref(prefs::kPartitionDefaultZoomLevel);
   registry->RegisterDictionaryPref(prefs::kPartitionPerHostZoomLevels);
 #endif  // !defined(OS_ANDROID)
@@ -508,7 +508,7 @@ bool ProfileCompare::operator()(Profile*
   return a->GetOriginalProfile() < b->GetOriginalProfile();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 double Profile::GetDefaultZoomLevelForProfile() {
   return GetDefaultStoragePartition(this)
       ->GetHostZoomMap()
--- a/chrome/browser/profiles/profile.h
+++ b/chrome/browser/profiles/profile.h
@@ -26,7 +26,7 @@
 #include "base/android/scoped_java_ref.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class ChromeZoomLevelPrefs;
 #endif
 
@@ -297,7 +297,7 @@ class Profile : public content::BrowserC
   virtual PrefService* GetPrefs() = 0;
   virtual const PrefService* GetPrefs() const = 0;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Retrieves a pointer to the PrefService that manages the default zoom
   // level and the per-host zoom levels for this user profile.
   // TODO(wjmaclean): Remove this when HostZoomMap migrates to StoragePartition.
@@ -509,7 +509,7 @@ class Profile : public content::BrowserC
   // ProfileDestroyer, but in tests, some are not.
   void MaybeSendDestroyedNotification();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Convenience method to retrieve the default zoom level for the default
   // storage partition.
   double GetDefaultZoomLevelForProfile();
--- a/chrome/browser/ui/browser_navigator_params.cc
+++ b/chrome/browser/ui/browser_navigator_params.cc
@@ -21,7 +21,7 @@ using content::GlobalRequestID;
 using content::NavigationController;
 using content::WebContents;
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 NavigateParams::NavigateParams(std::unique_ptr<WebContents> contents_to_insert)
     : contents_to_insert(std::move(contents_to_insert)) {}
 #else
--- a/chrome/browser/ui/browser_navigator_params.h
+++ b/chrome/browser/ui/browser_navigator_params.h
@@ -26,7 +26,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
 #include "components/tab_groups/tab_group_id.h"
 #endif
@@ -64,7 +64,7 @@ struct OpenURLParams;
 
 // TODO(thestig): Split or ifdef out more fields that are not used on Android.
 struct NavigateParams {
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
   explicit NavigateParams(
       std::unique_ptr<content::WebContents> contents_to_insert);
 #else
@@ -222,7 +222,7 @@ struct NavigateParams {
   };
   PathBehavior path_behavior = RESPECT;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // [in]  Specifies a Browser object where the navigation could occur or the
   //       tab could be added. Navigate() is not obliged to use this Browser if
   //       it is not compatible with the operation being performed. This can be
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
@@ -195,25 +195,7 @@ void SafeBrowsingPrivateEventRouter::OnP
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
-  if (!IsRealtimeReportingEnabled())
-    return;
-
-  ReportRealtimeEvent(
-      kKeyPasswordReuseEvent,
-      base::BindOnce(
-          [](const std::string& url, const std::string& user_name,
-             const bool is_phishing_url, const std::string& profile_user_name) {
-            // Convert |params| to a real-time event dictionary
-            // and report it.
-            base::Value event(base::Value::Type::DICTIONARY);
-            event.SetStringKey(kKeyUrl, url);
-            event.SetStringKey(kKeyUserName, user_name);
-            event.SetBoolKey(kKeyIsPhishingUrl, is_phishing_url);
-            event.SetStringKey(kKeyProfileUserName, profile_user_name);
-            return event;
-          },
-          params.url, params.user_name, params.is_phishing_url,
-          GetProfileUserName()));
+  return;
 }
 
 void SafeBrowsingPrivateEventRouter::OnPolicySpecifiedPasswordChanged(
--- a/chrome/common/pref_names.cc
+++ b/chrome/common/pref_names.cc
@@ -1212,7 +1212,7 @@ const char kAccessibilityFocusHighlightE
     "settings.a11y.focus_highlight";
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Whether the Live Caption feature is enabled.
 const char kLiveCaptionEnabled[] =
     "accessibility.captions.live_caption_enabled";
@@ -1258,7 +1258,7 @@ const char kContentSettingsPluginWhiteli
     "profile.content_settings.plugin_whitelist";
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Double that indicates the default zoom level.
 const char kPartitionDefaultZoomLevel[] = "partition.default_zoom_level";
 
@@ -1562,7 +1562,7 @@ const char kWebRtcLocalIpsAllowedUrls[]
 const char kWebRTCAllowLegacyTLSProtocols[] =
     "webrtc.allow_legacy_tls_protocols";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Whether or not this profile has been shown the Welcome page.
 const char kHasSeenWelcomePage[] = "browser.has_seen_welcome_page";
 #endif
@@ -1778,7 +1778,7 @@ const char kShutdownNumProcessesSlow[] =
 // before shutting everything down.
 const char kRestartLastSessionOnShutdown[] = "restart.last.session.on.shutdown";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
 // Pref name for the policy controlling presentation of full-tab promotional
 // and/or educational content.
@@ -1821,7 +1821,6 @@ const char kNtpCollapsedSnapshotDocument
 
 // Keeps track of sync promo collapsed state in the Other Devices menu.
 const char kNtpCollapsedSyncPromo[] = "ntp.collapsed_sync_promo";
-#else
 // Holds info for New Tab Page custom background
 const char kNtpCustomBackgroundDict[] = "ntp.custom_background_dict";
 const char kNtpCustomBackgroundLocalToDevice[] =
@@ -1889,7 +1888,7 @@ const char kDevToolsTCPDiscoveryConfig[]
 // A dictionary with generic DevTools settings.
 const char kDevToolsPreferences[] = "devtools.preferences";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Tracks the number of times the dice signin promo has been shown in the user
 // menu.
 const char kDiceSigninUserMenuPromoCount[] = "sync_promo.user_menu_show_count";
@@ -2442,13 +2441,13 @@ const char kSystemTimezoneAutomaticDetec
 
 // Pref name for the policy controlling whether to enable Media Router.
 const char kEnableMediaRouter[] = "media_router.enable_media_router";
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Pref name for the policy controlling whether to force the Cast icon to be
 // shown in the toolbar/overflow menu.
 const char kShowCastIconInToolbar[] = "media_router.show_cast_icon_in_toolbar";
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Pref name for the policy controlling the way in which users are notified of
 // the need to relaunch the browser for a pending update.
 const char kRelaunchNotification[] = "browser.relaunch_notification";
@@ -2565,7 +2564,7 @@ const char kCustomHandlersEnabled[] = "c
 // by the cloud policy subsystem.
 const char kDevicePolicyRefreshRate[] = "policy.device_refresh_rate";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // A boolean where true means that the browser has previously attempted to
 // enable autoupdate and failed, so the next out-of-date browser start should
 // not prompt the user to enable autoupdate, it should offer to reinstall Chrome
@@ -2725,7 +2724,7 @@ const char kRecoveryComponentNeedsElevat
 const char kRegisteredSupervisedUserWhitelists[] =
     "supervised_users.whitelists";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Boolean that indicates whether Chrome enterprise extension request is enabled
 // or not.
 const char kCloudExtensionRequestEnabled[] =
@@ -2944,7 +2943,7 @@ const char kIsolateOrigins[] = "site_iso
 // Boolean that specifies opting into --site-per-process (full Site Isolation).
 const char kSitePerProcess[] = "site_isolation.site_per_process";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Boolean that specifies whether media (audio/video) autoplay is allowed.
 const char kAutoplayAllowed[] = "media.autoplay_allowed";
 
@@ -3017,7 +3016,7 @@ const char kSharingVapidKey[] = "sharing
 const char kSharingFCMRegistration[] = "sharing.fcm_registration";
 const char kSharingLocalSharingInfo[] = "sharing.local_sharing_info";
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Dictionary that contains all of the Hats Survey Metadata.
 const char kHatsSurveyMetadata[] = "hats.survey_metadata";
 #endif  // !defined(OS_ANDROID)
@@ -3084,7 +3083,7 @@ const char kAdbSideloadingPowerwashOnNex
     "adb_sideloading_powerwash_on_next_reboot_notification_shown";
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Boolean pref that indicates whether caret browsing is currently enabled.
 const char kCaretBrowsingEnabled[] = "settings.a11y.caretbrowsing.enabled";
 
--- a/chrome/common/pref_names.h
+++ b/chrome/common/pref_names.h
@@ -191,7 +191,7 @@ extern const char kAccessibilityCaptions
 extern const char kAccessibilityCaptionsBackgroundColor[];
 extern const char kAccessibilityCaptionsTextShadow[];
 extern const char kAccessibilityCaptionsBackgroundOpacity[];
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kLiveCaptionEnabled[];
 extern const char kLiveCaptionLanguageCode[];
 extern const char kSodaBinaryPath[];
@@ -390,7 +390,7 @@ extern const char kUseCustomChromeFrame[
 #if BUILDFLAG(ENABLE_PLUGINS)
 extern const char kContentSettingsPluginWhitelist[];
 #endif
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kPartitionDefaultZoomLevel[];
 extern const char kPartitionPerHostZoomLevels[];
 
@@ -504,7 +504,7 @@ extern const char kWebRtcEventLogCollect
 extern const char kWebRtcLocalIpsAllowedUrls[];
 extern const char kWebRTCAllowLegacyTLSProtocols[];
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kHasSeenWelcomePage[];
 #endif
 
@@ -590,7 +590,7 @@ extern const char kShutdownNumProcesses[
 extern const char kShutdownNumProcessesSlow[];
 
 extern const char kRestartLastSessionOnShutdown[];
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
 extern const char kPromotionalTabsEnabled[];
 extern const char kCommandLineFlagSecurityWarningsEnabled[];
@@ -607,7 +607,6 @@ extern const char kNtpCollapsedForeignSe
 extern const char kNtpCollapsedRecentlyClosedTabs[];
 extern const char kNtpCollapsedSnapshotDocument[];
 extern const char kNtpCollapsedSyncPromo[];
-#else
 extern const char kNtpCustomBackgroundDict[];
 extern const char kNtpCustomBackgroundLocalToDevice[];
 extern const char kNtpModulesVisible[];
@@ -633,7 +632,7 @@ extern const char kDevToolsPreferences[]
 extern const char kDevToolsDiscoverTCPTargetsEnabled[];
 extern const char kDevToolsTCPDiscoveryConfig[];
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kDiceSigninUserMenuPromoCount[];
 #endif
 
@@ -840,11 +839,11 @@ extern const char kSystemTimezoneAutomat
 #endif  // defined(OS_CHROMEOS)
 
 extern const char kEnableMediaRouter[];
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kShowCastIconInToolbar[];
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kRelaunchNotification[];
 extern const char kRelaunchNotificationPeriod[];
 #endif  // !defined(OS_ANDROID)
@@ -853,7 +852,7 @@ extern const char kRelaunchNotificationP
 extern const char kRelaunchHeadsUpPeriod[];
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kAttemptedToEnableAutoupdate[];
 
 extern const char kMediaGalleriesUniqueId[];
@@ -911,7 +910,7 @@ extern const char kRecoveryComponentNeed
 
 extern const char kRegisteredSupervisedUserWhitelists[];
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kCloudExtensionRequestEnabled[];
 extern const char kCloudExtensionRequestIds[];
 #endif
@@ -1008,7 +1007,7 @@ extern const char kUnsafelyTreatInsecure
 extern const char kIsolateOrigins[];
 extern const char kSitePerProcess[];
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kAutoplayAllowed[];
 extern const char kAutoplayWhitelist[];
 extern const char kBlockAutoplayEnabled[];
@@ -1046,7 +1045,7 @@ extern const char kSharingVapidKey[];
 extern const char kSharingFCMRegistration[];
 extern const char kSharingLocalSharingInfo[];
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kHatsSurveyMetadata[];
 #endif  // !defined(OS_ANDROID)
 
@@ -1078,7 +1077,7 @@ extern const char kAdbSideloadingPowerwa
 extern const char kAdbSideloadingPowerwashOnNextRebootNotificationShown[];
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kCaretBrowsingEnabled[];
 extern const char kShowCaretBrowsingDialog[];
 #endif
--- a/chrome/browser/extensions/api/tabs/windows_event_router.cc
+++ b/chrome/browser/extensions/api/tabs/windows_event_router.cc
@@ -164,8 +164,6 @@ WindowsEventRouter::WindowsEventRouter(P
                  content::NotificationService::AllSources());
 #elif defined(TOOLKIT_VIEWS)
   views::WidgetFocusManager::GetInstance()->AddFocusChangeListener(this);
-#else
-#error Unsupported
 #endif
 
   AppWindowRegistry* registry = AppWindowRegistry::Get(profile_);
--- a/chrome/common/chrome_features.cc
+++ b/chrome/common/chrome_features.cc
@@ -63,7 +63,7 @@ const base::Feature kAppActivityReportin
                                           base::FEATURE_ENABLED_BY_DEFAULT};
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // App Service related flags. See components/services/app_service/README.md.
 const base::Feature kAppServiceAdaptiveIcon{"AppServiceAdaptiveIcon",
                                             base::FEATURE_DISABLED_BY_DEFAULT};
@@ -226,7 +226,7 @@ const base::Feature kDMServerOAuthForChi
     "DMServerOAuthForChildUser", base::FEATURE_ENABLED_BY_DEFAULT};
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Whether to allow installed-by-default web apps to be installed or not.
 const base::Feature kDefaultWebAppInstallation{
     "DefaultWebAppInstallation", base::FEATURE_ENABLED_BY_DEFAULT};
@@ -518,7 +518,7 @@ const base::Feature kInstallableAmbientB
     "InstallableAmbientBadgeInfoBar", base::FEATURE_ENABLED_BY_DEFAULT};
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Support sharing in Chrome OS intent handling.
 const base::Feature kIntentHandlingSharing{"IntentHandlingSharing",
                                            base::FEATURE_DISABLED_BY_DEFAULT};
@@ -610,7 +610,7 @@ const base::Feature kNtlmV2Enabled{"Ntlm
                                    base::FEATURE_ENABLED_BY_DEFAULT};
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 const base::Feature kOnConnectNative{"OnConnectNative",
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
--- a/chrome/common/chrome_features.h
+++ b/chrome/common/chrome_features.h
@@ -64,7 +64,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kAppActivityReporting;
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kAppServiceAdaptiveIcon;
 COMPONENT_EXPORT(CHROME_FEATURES)
@@ -161,7 +161,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kDMServerOAuthForChildUser;
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kDefaultWebAppInstallation;
 #endif
@@ -282,7 +282,7 @@ COMPONENT_EXPORT(CHROME_FEATURES) extern
 
 COMPONENT_EXPORT(CHROME_FEATURES) extern const base::Feature kGeoLanguage;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kHappinessTrackingSurveysForDesktop;
 
@@ -338,7 +338,7 @@ COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kInstallableAmbientBadgeInfoBar;
 #endif  // defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES)
 extern const base::Feature kIntentHandlingSharing;
 COMPONENT_EXPORT(CHROME_FEATURES)
@@ -400,7 +400,7 @@ extern const base::Feature kNotification
 COMPONENT_EXPORT(CHROME_FEATURES) extern const base::Feature kNtlmV2Enabled;
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 COMPONENT_EXPORT(CHROME_FEATURES) extern const base::Feature kOnConnectNative;
 #endif
 
--- a/chrome/common/chrome_paths.cc
+++ b/chrome/common/chrome_paths.cc
@@ -503,7 +503,7 @@ bool PathProvider(int key, base::FilePat
 #endif
       break;
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || defined(OS_ANDROID)
     case chrome::DIR_NATIVE_MESSAGING:
 #if defined(OS_MAC)
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
--- a/chrome/common/chrome_paths.h
+++ b/chrome/common/chrome_paths.h
@@ -116,7 +116,7 @@ enum {
   DIR_SUPERVISED_USER_INSTALLED_WHITELISTS,  // Directory where sanitized
                                              // supervised user whitelists are
                                              // installed.
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || defined(OS_ANDROID)
   DIR_NATIVE_MESSAGING,       // System directory where native messaging host
                               // manifest files are stored.
   DIR_USER_NATIVE_MESSAGING,  // Directory with Native Messaging Hosts
--- a/chrome/browser/profiles/profile_window.h
+++ b/chrome/browser/profiles/profile_window.h
@@ -14,9 +14,6 @@
 #include "chrome/browser/ui/profile_chooser_constants.h"
 #include "chrome/browser/ui/startup/startup_types.h"
 
-#if defined(OS_ANDROID)
-#error "Not used on Android"
-#endif
 
 class Profile;
 
--- a/chrome/browser/profiles/profiles_state.cc
+++ b/chrome/browser/profiles/profiles_state.cc
@@ -32,7 +32,7 @@
 #include "content/public/browser/browsing_data_remover.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -95,7 +95,7 @@ void SetLastUsedProfile(const std::strin
   local_state->SetString(prefs::kProfileLastUsed, profile_dir);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 base::string16 GetAvatarNameForProfile(const base::FilePath& profile_path) {
   if (profile_path == ProfileManager::GetGuestProfilePath()) {
     return l10n_util::GetStringUTF16(IDS_GUEST_PROFILE_NAME);
--- a/chrome/browser/profiles/profiles_state.h
+++ b/chrome/browser/profiles/profiles_state.h
@@ -47,7 +47,7 @@ void RegisterPrefs(PrefRegistrySimple* r
 // System Profile directory, which is an invalid last used profile.
 void SetLastUsedProfile(const std::string& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Returns the display name of the specified on-the-record profile (or guest),
 // specified by |profile_path|, used in the avatar button or user manager. If
 // |profile_path| is the guest path, it will return IDS_GUEST_PROFILE_NAME. If
--- a/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
+++ b/ui/views/controls/webview/unhandled_keyboard_event_handler_default.cc
@@ -13,7 +13,7 @@ namespace views {
 bool UnhandledKeyboardEventHandler::HandleNativeKeyboardEvent(
     gfx::NativeEvent event,
     FocusManager* focus_manager) {
-  return !focus_manager->OnKeyEvent(*(event->AsKeyEvent()));
+  return false;
 }
 
 }  // namespace views
--- a/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
+++ b/chrome/browser/media/webrtc/media_capture_devices_dispatcher.cc
@@ -100,15 +100,6 @@ MediaCaptureDevicesDispatcher::MediaCapt
   media_access_handlers_.push_back(
       std::make_unique<ExtensionMediaAccessHandler>());
 #endif
-  media_access_handlers_.push_back(
-      std::make_unique<DesktopCaptureAccessHandler>());
-#if defined(OS_CHROMEOS)
-  // Wrapper around TabCaptureAccessHandler used in Public Sessions.
-  media_access_handlers_.push_back(
-      std::make_unique<PublicSessionTabCaptureAccessHandler>());
-#else
-  media_access_handlers_.push_back(std::make_unique<TabCaptureAccessHandler>());
-#endif
 #endif
   media_access_handlers_.push_back(
       std::make_unique<PermissionBubbleMediaAccessHandler>());
--- a/chrome/browser/ui/browser_commands.cc
+++ b/chrome/browser/ui/browser_commands.cc
@@ -93,6 +93,7 @@
 #include "components/services/app_service/public/mojom/types.mojom.h"
 #include "components/sessions/core/live_tab_context.h"
 #include "components/sessions/core/tab_restore_service.h"
+#include "components/signin/public/base/signin_metrics.h"
 #include "components/tab_groups/tab_group_id.h"
 #include "components/tab_groups/tab_group_visual_data.h"
 #include "components/translate/core/browser/language_state.h"
--- a/ui/native_theme/native_theme_android.cc
+++ b/ui/native_theme/native_theme_android.cc
@@ -22,8 +22,7 @@ NativeTheme* NativeTheme::GetInstanceFor
 }
 
 NativeTheme* NativeTheme::GetInstanceForNativeUi() {
-  NOTREACHED();
-  return nullptr;
+  return NativeThemeAndroid::instance();
 }
 #endif
 
--- a/ui/native_theme/native_theme_android.h
+++ b/ui/native_theme/native_theme_android.h
@@ -20,11 +20,11 @@ class NativeThemeAndroid : public Native
                         const ExtraParams& extra) const override;
   SkColor GetSystemColor(ColorId color_id,
                          ColorScheme color_scheme) const override;
+  static NativeThemeAndroid* instance();
 
  protected:
   friend class NativeTheme;
   friend class base::NoDestructor<NativeThemeAndroid>;
-  static NativeThemeAndroid* instance();
 
   // NativeThemeBase:
   void AdjustCheckboxRadioRectForPadding(SkRect* rect) const override;
--- a/content/browser/storage_partition_impl.h
+++ b/content/browser/storage_partition_impl.h
@@ -58,7 +58,7 @@
 #include "storage/browser/quota/special_storage_policy.h"
 #include "third_party/blink/public/mojom/dom_storage/dom_storage.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "content/browser/host_zoom_level_context.h"
 #endif
 
@@ -151,7 +151,7 @@ class CONTENT_EXPORT StoragePartitionImp
   DevToolsBackgroundServicesContextImpl* GetDevToolsBackgroundServicesContext()
       override;
   ContentIndexContextImpl* GetContentIndexContext() override;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   HostZoomMap* GetHostZoomMap() override;
   HostZoomLevelContext* GetHostZoomLevelContext() override;
   ZoomLevelDelegate* GetZoomLevelDelegate() override;
@@ -502,7 +502,7 @@ class CONTENT_EXPORT StoragePartitionImp
   std::unique_ptr<SharedWorkerServiceImpl> shared_worker_service_;
   std::unique_ptr<PushMessagingContext> push_messaging_context_;
   scoped_refptr<storage::SpecialStoragePolicy> special_storage_policy_;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<HostZoomLevelContext, BrowserThread::DeleteOnUIThread>
       host_zoom_level_context_;
 #endif  // !defined(OS_ANDROID)
--- a/content/public/browser/storage_partition.h
+++ b/content/public/browser/storage_partition.h
@@ -67,7 +67,7 @@ class PlatformNotificationContext;
 class ServiceWorkerContext;
 class SharedWorkerService;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class HostZoomLevelContext;
 class HostZoomMap;
 class ZoomLevelDelegate;
@@ -132,7 +132,7 @@ class CONTENT_EXPORT StoragePartition {
   virtual DevToolsBackgroundServicesContext*
   GetDevToolsBackgroundServicesContext() = 0;
   virtual ContentIndexContext* GetContentIndexContext() = 0;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   virtual HostZoomMap* GetHostZoomMap() = 0;
   virtual HostZoomLevelContext* GetHostZoomLevelContext() = 0;
   virtual ZoomLevelDelegate* GetZoomLevelDelegate() = 0;
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -197,7 +197,6 @@
 #include "content/browser/web_contents/web_contents_android.h"
 #include "services/device/public/mojom/nfc.mojom.h"
 #include "ui/android/view_android.h"
-#else  // !OS_ANDROID
 #include "content/browser/host_zoom_map_impl.h"
 #endif  // OS_ANDROID
 
@@ -1485,7 +1484,7 @@ FindRequestManager* WebContentsImpl::Get
   return GetFindRequestManager();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void WebContentsImpl::UpdateZoom() {
   OPTIONAL_TRACE_EVENT0("content", "WebContentsImpl::UpdateZoom");
   RenderWidgetHostImpl* rwh = GetRenderViewHost()->GetWidget();
--- a/content/browser/web_contents/web_contents_impl.h
+++ b/content/browser/web_contents/web_contents_impl.h
@@ -274,7 +274,7 @@ class CONTENT_EXPORT WebContentsImpl : p
   // bitmap.
   void AddAccessibilityMode(ui::AXMode mode);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Sets the zoom level for frames associated with this WebContents.
   void UpdateZoom();
 
--- a/content/browser/storage_partition_impl.cc
+++ b/content/browser/storage_partition_impl.cc
@@ -1233,7 +1233,7 @@ void StoragePartitionImpl::Initialize(
   push_messaging_context_ = std::make_unique<PushMessagingContext>(
       browser_context_, service_worker_context_);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   host_zoom_level_context_.reset(new HostZoomLevelContext(
       browser_context_->CreateZoomLevelDelegate(partition_path_)));
 #endif  // !defined(OS_ANDROID)
@@ -1494,7 +1494,7 @@ SharedWorkerServiceImpl* StoragePartitio
   return shared_worker_service_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 HostZoomMap* StoragePartitionImpl::GetHostZoomMap() {
   DCHECK(initialized_);
   DCHECK(host_zoom_level_context_.get());
--- a/content/public/browser/browser_context.h
+++ b/content/public/browser/browser_context.h
@@ -27,7 +27,7 @@
 #include "third_party/blink/public/mojom/push_messaging/push_messaging.mojom-forward.h"
 #include "third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom-forward.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "content/public/browser/zoom_level_delegate.h"
 #endif
 
@@ -241,7 +241,7 @@ class CONTENT_EXPORT BrowserContext : pu
   // destroyed soon and no new references to this object should be created.
   bool ShutdownStarted() { return was_notify_will_be_destroyed_called_; }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Creates a delegate to initialize a HostZoomMap and persist its information.
   // This is called during creation of each StoragePartition.
   virtual std::unique_ptr<ZoomLevelDelegate> CreateZoomLevelDelegate(
--- a/chrome/browser/profiles/profile_impl.cc
+++ b/chrome/browser/profiles/profile_impl.cc
@@ -189,7 +189,6 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/profile_key_startup_accessor.h"
-#else
 #include "components/zoom/zoom_event_manager.h"
 #include "content/public/common/page_zoom.h"
 #endif
@@ -825,7 +824,7 @@ std::string ProfileImpl::GetProfileUserN
   return std::string();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 ProfileImpl::CreateZoomLevelDelegate(const base::FilePath& partition_path) {
   return std::make_unique<ChromeZoomLevelPrefs>(
@@ -1107,7 +1106,7 @@ const PrefService* ProfileImpl::GetPrefs
   return prefs_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 ChromeZoomLevelPrefs* ProfileImpl::GetZoomLevelPrefs() {
   return static_cast<ChromeZoomLevelPrefs*>(
       GetDefaultStoragePartition(this)->GetZoomLevelDelegate());
--- a/chrome/browser/profiles/profile_impl.h
+++ b/chrome/browser/profiles/profile_impl.h
@@ -27,7 +27,7 @@
 #include "content/public/browser/content_browser_client.h"
 #include "extensions/buildflags/buildflags.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_prefs.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -74,7 +74,7 @@ class ProfileImpl : public Profile {
   static void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry);
 
   // content::BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif
@@ -133,7 +133,7 @@ class ProfileImpl : public Profile {
   ExtensionSpecialStoragePolicy* GetExtensionSpecialStoragePolicy() override;
   PrefService* GetPrefs() override;
   const PrefService* GetPrefs() const override;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   ChromeZoomLevelPrefs* GetZoomLevelPrefs() override;
 #endif
   // TODO(https://crbug.com/1060940, https://crbug.com/1065444): Only supports
--- a/content/shell/browser/shell_browser_context.cc
+++ b/content/shell/browser/shell_browser_context.cc
@@ -135,7 +135,7 @@ void ShellBrowserContext::FinishInitWhil
   SimpleKeyMap::GetInstance()->Associate(this, key_.get());
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<ZoomLevelDelegate> ShellBrowserContext::CreateZoomLevelDelegate(
     const base::FilePath&) {
   return std::unique_ptr<ZoomLevelDelegate>();
--- a/content/shell/browser/shell_browser_context.h
+++ b/content/shell/browser/shell_browser_context.h
@@ -25,7 +25,7 @@ class ClientHintsControllerDelegate;
 class DownloadManagerDelegate;
 class PermissionControllerDelegate;
 class ShellDownloadManagerDelegate;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class ZoomLevelDelegate;
 #endif  // !defined(OS_ANDROID)
 
@@ -44,7 +44,7 @@ class ShellBrowserContext : public Brows
 
   // BrowserContext implementation.
   base::FilePath GetPath() override;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
--- a/chromecast/browser/cast_browser_context.cc
+++ b/chromecast/browser/cast_browser_context.cc
@@ -78,7 +78,7 @@ void CastBrowserContext::InitWhileIOAllo
 #endif  // defined(OS_ANDROID)
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 CastBrowserContext::CreateZoomLevelDelegate(
     const base::FilePath& partition_path) {
--- a/chromecast/browser/cast_browser_context.h
+++ b/chromecast/browser/cast_browser_context.h
@@ -25,7 +25,7 @@ class CastBrowserContext final : public
   ~CastBrowserContext() override;
 
   // BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
--- a/chrome/browser/profiles/off_the_record_profile_impl.cc
+++ b/chrome/browser/profiles/off_the_record_profile_impl.cc
@@ -73,7 +73,6 @@
 
 #if defined(OS_ANDROID)
 #include "components/prefs/scoped_user_pref_update.h"
-#else  // !defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_otr_delegate.h"
 #include "components/zoom/zoom_event_manager.h"
 #include "content/public/browser/host_zoom_map.h"
@@ -107,7 +106,7 @@
 
 using content::BrowserThread;
 using content::DownloadManagerDelegate;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 using content::HostZoomMap;
 #endif
 
@@ -228,7 +227,7 @@ OffTheRecordProfileImpl::~OffTheRecordPr
   }
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void OffTheRecordProfileImpl::TrackZoomLevelsFromParent() {
   // Here we only want to use zoom levels stored in the main-context's default
   // storage partition. We're not interested in zoom levels in special
@@ -270,7 +269,7 @@ base::Time OffTheRecordProfileImpl::GetC
   return start_time_;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 OffTheRecordProfileImpl::CreateZoomLevelDelegate(
     const base::FilePath& partition_path) {
@@ -627,7 +626,7 @@ std::unique_ptr<Profile> Profile::Create
   return std::move(profile);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void OffTheRecordProfileImpl::OnParentZoomLevelChanged(
     const HostZoomMap::ZoomLevelChange& change) {
   HostZoomMap* host_zoom_map = HostZoomMap::GetDefaultForBrowserContext(this);
--- a/chrome/browser/profiles/off_the_record_profile_impl.h
+++ b/chrome/browser/profiles/off_the_record_profile_impl.h
@@ -16,7 +16,7 @@
 #include "components/domain_reliability/clear_mode.h"
 #include "content/public/browser/content_browser_client.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/zoom/chrome_zoom_level_prefs.h"
 #include "content/public/browser/host_zoom_map.h"
 #endif
@@ -95,7 +95,7 @@ class OffTheRecordProfileImpl : public P
   base::FilePath GetPath() override;
   base::FilePath GetPath() const override;
   base::Time GetCreationTime() const override;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath& partition_path) override;
 #endif  // !defined(OS_ANDROID)
@@ -130,12 +130,12 @@ class OffTheRecordProfileImpl : public P
   void RecordMainFrameNavigation() override;
 
  private:
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Allows a profile to track changes in zoom levels in its parent profile.
   void TrackZoomLevelsFromParent();
 #endif  // !defined(OS_ANDROID)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Callback function for tracking parent's zoom level changes.
   void OnParentZoomLevelChanged(
       const content::HostZoomMap::ZoomLevelChange& change);
@@ -149,7 +149,7 @@ class OffTheRecordProfileImpl : public P
 
   std::unique_ptr<sync_preferences::PrefServiceSyncable> prefs_;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<content::HostZoomMap::Subscription> track_zoom_subscription_;
   std::unique_ptr<ChromeZoomLevelPrefs::DefaultZoomLevelSubscription>
       parent_default_zoom_level_subscription_;
--- a/weblayer/browser/browser_context_impl.cc
+++ b/weblayer/browser/browser_context_impl.cc
@@ -136,7 +136,7 @@ base::FilePath BrowserContextImpl::GetDe
   return download_dir;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<content::ZoomLevelDelegate>
 BrowserContextImpl::CreateZoomLevelDelegate(const base::FilePath&) {
   return nullptr;
--- a/weblayer/browser/browser_context_impl.h
+++ b/weblayer/browser/browser_context_impl.h
@@ -37,7 +37,7 @@ class BrowserContextImpl : public conten
   static base::FilePath GetDefaultDownloadDirectory();
 
   // BrowserContext implementation:
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
       const base::FilePath&) override;
 #endif  // !defined(OS_ANDROID)
--- a/ui/views/widget/widget.cc
+++ b/ui/views/widget/widget.cc
@@ -187,6 +187,11 @@ Widget::~Widget() {
 }
 
 // static
+const ui::NativeTheme* Widget::GetNativeTheme() const {
+  return ui::NativeTheme::GetInstanceForNativeUi();
+}
+
+// static
 Widget* Widget::CreateWindowWithParent(WidgetDelegate* delegate,
                                        gfx::NativeView parent,
                                        const gfx::Rect& bounds) {
--- a/chrome/browser/ui/browser_dialogs.cc
+++ b/chrome/browser/ui/browser_dialogs.cc
@@ -38,7 +38,7 @@ void ShowWindowNamePromptForTesting(Brow
 
 }  // namespace chrome
 
-#if !defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS)
 // There's no dialog version of this available outside views, run callback as if
 // the dialog was instantly accepted.
 void ShowFolderUploadConfirmationDialog(
--- a/chrome/browser/search/instant_service_observer.h
+++ b/chrome/browser/search/instant_service_observer.h
@@ -9,7 +9,7 @@
 
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/search/local_ntp_source.h
+++ b/chrome/browser/search/local_ntp_source.h
@@ -26,7 +26,7 @@
 #include "components/prefs/pref_registry_simple.h"
 #include "content/public/browser/url_data_source.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/search/most_visited_iframe_source.h
+++ b/chrome/browser/search/most_visited_iframe_source.h
@@ -9,7 +9,7 @@
 #include "build/build_config.h"
 #include "content/public/browser/url_data_source.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/browser_instant_controller.h
+++ b/chrome/browser/ui/browser_instant_controller.h
@@ -13,7 +13,7 @@
 #include "chrome/browser/search/search_engine_base_url_tracker.h"
 #include "chrome/browser/ui/search/instant_controller.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/search/instant_controller.h
+++ b/chrome/browser/ui/search/instant_controller.h
@@ -12,7 +12,7 @@
 #include "build/build_config.h"
 #include "chrome/browser/ui/tabs/tab_strip_model_observer.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/search/search_ipc_router.h
+++ b/chrome/browser/ui/search/search_ipc_router.h
@@ -22,7 +22,7 @@
 #include "content/public/browser/web_contents_observer.h"
 #include "mojo/public/cpp/bindings/associated_receiver.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/search/search_tab_helper.h
+++ b/chrome/browser/ui/search/search_tab_helper.h
@@ -31,7 +31,7 @@
 #include "content/public/browser/web_contents_user_data.h"
 #include "ui/shell_dialogs/select_file_dialog.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
+++ b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.h
@@ -28,6 +28,7 @@ class RegisterProtocolHandlerPermissionR
  private:
   // permissions::PermissionRequest:
   IconId GetIconId() const override;
+  base::string16 GetMessageText() const override;
   base::string16 GetMessageTextFragment() const override;
   GURL GetOrigin() const override;
   void PermissionGranted(bool is_one_time) override;
--- a/chrome/browser/download/download_ui_model.cc
+++ b/chrome/browser/download/download_ui_model.cc
@@ -22,7 +22,7 @@
 #include "ui/base/l10n/time_format.h"
 #include "ui/base/text/bytes_formatting.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -505,7 +505,7 @@ bool DownloadUIModel::ShouldPromoteOrigi
   return false;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 bool DownloadUIModel::IsCommandEnabled(
     const DownloadCommands* download_commands,
     DownloadCommands::Command command) const {
--- a/chrome/browser/download/download_ui_model.h
+++ b/chrome/browser/download/download_ui_model.h
@@ -19,7 +19,7 @@
 #include "components/safe_browsing/buildflags.h"
 #include "components/safe_browsing/core/proto/download_file_types.pb.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/download/download_commands.h"
 #endif
 
@@ -289,7 +289,7 @@ class DownloadUIModel {
   // security reasons.
   virtual bool ShouldPromoteOrigin() const;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Methods related to DownloadCommands.
   // Returns whether the given download command is enabled for this download.
   virtual bool IsCommandEnabled(const DownloadCommands* download_commands,
--- a/chrome/browser/download/download_commands.h
+++ b/chrome/browser/download/download_commands.h
@@ -11,7 +11,7 @@
 #include "content/public/browser/page_navigator.h"
 #include "ui/gfx/image/image.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class Browser;
 #endif
 
@@ -49,7 +49,7 @@ class DownloadCommands {
   void ExecuteCommand(Command command);
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_MAC)
+    defined(OS_MAC) || defined(OS_ANDROID)
   bool IsDownloadPdf() const;
   bool CanOpenPdfInSystemViewer() const;
   Browser* GetBrowser() const;
--- a/chrome/browser/lifetime/application_lifetime.cc
+++ b/chrome/browser/lifetime/application_lifetime.cc
@@ -33,7 +33,7 @@
 #include "content/public/browser/navigation_details.h"
 #include "content/public/browser/notification_service.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/lifetime/termination_notification.h"
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
@@ -50,7 +50,7 @@
 #include "third_party/cros_system_api/dbus/service_constants.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 #include "chrome/browser/ui/user_manager.h"
 #endif
 
@@ -62,7 +62,7 @@ namespace chrome {
 
 namespace {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Returns true if all browsers can be closed without user interaction.
 // This currently checks if there is pending download, or if it needs to
 // handle unload handler.
@@ -120,7 +120,7 @@ bool SetLocaleForNextStart(PrefService*
 bool g_send_stop_request_to_session_manager = false;
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 using IgnoreUnloadHandlers =
     util::StrongAlias<class IgnoreUnloadHandlersTag, bool>;
 
@@ -154,7 +154,7 @@ void AttemptRestartInternal(IgnoreUnload
 
 }  // namespace
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void MarkAsCleanShutdown() {
   // TODO(beng): Can this use ProfileManager::GetLoadedProfiles() instead?
   for (auto* browser : *BrowserList::GetInstance())
@@ -177,7 +177,7 @@ void AttemptExitInternal(bool try_to_qui
   g_browser_process->platform_part()->AttemptExit(try_to_quit_application);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void CloseAllBrowsersAndQuit() {
   browser_shutdown::SetTryingToQuit(true);
   CloseAllBrowsers();
@@ -269,7 +269,7 @@ void AttemptRelaunch() {
   AttemptRestart();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void RelaunchIgnoreUnloadHandlers() {
 #if defined(OS_CHROMEOS)
   chromeos::PowerManagerClient::Get()->RequestRestart(
@@ -289,7 +289,7 @@ void AttemptExit() {
   // don't notify users of crashes beyond this point.
   // Note that MarkAsCleanShutdown() does not set UMA's exit cleanly bit
   // so crashes during shutdown are still reported in UMA.
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Android doesn't use Browser.
   if (AreAllBrowsersCloseable())
     MarkAsCleanShutdown();
@@ -300,7 +300,7 @@ void AttemptExit() {
 
 void ExitIgnoreUnloadHandlers() {
   VLOG(1) << "ExitIgnoreUnloadHandlers";
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // We always mark exit cleanly.
   MarkAsCleanShutdown();
 
@@ -327,7 +327,7 @@ bool IsAttemptingShutdown() {
 }
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void SessionEnding() {
   // This is a time-limited shutdown where we need to write as much to
   // disk as we can as soon as we can, and where we must kill the
@@ -395,6 +395,8 @@ void OnAppExiting() {
   notified = true;
   HandleAppExitingForPlatform();
 }
+
+void HandleAppExitingForPlatform() {}
 #endif  // !defined(OS_ANDROID)
 
 }  // namespace chrome
--- a/chrome/browser/ui/chrome_pages.cc
+++ b/chrome/browser/ui/chrome_pages.cc
@@ -70,7 +70,7 @@
 #include "chrome/browser/ui/signin_view_controller.h"
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/signin/identity_manager_factory.h"
 #include "components/signin/public/identity_manager/identity_manager.h"
 #endif
@@ -470,7 +470,7 @@ GURL GetOSSettingsUrl(const std::string&
 }
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 void ShowBrowserSignin(Browser* browser,
                        signin_metrics::AccessPoint access_point) {
 }
--- a/chrome/browser/ui/chrome_pages.h
+++ b/chrome/browser/ui/chrome_pages.h
@@ -14,7 +14,7 @@
 #include "components/services/app_service/public/mojom/types.mojom.h"
 #include "url/gurl.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/signin/signin_promo.h"
 #endif
 
@@ -157,7 +157,7 @@ void ShowPrintManagementApp(Profile* pro
 void ShowConnectivityDiagnosticsApp(Profile* profile);
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 // Initiates signin in a new browser tab.
 void ShowBrowserSignin(Browser* browser,
                        signin_metrics::AccessPoint access_point);
--- a/chrome/browser/metrics/thread_watcher.cc
+++ b/chrome/browser/metrics/thread_watcher.cc
@@ -36,7 +36,7 @@
 #include "content/public/browser/notification_registrar.h"
 #include "content/public/browser/notification_service.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/metrics/browser_activity_watcher.h"
 #endif
 
@@ -68,7 +68,7 @@ class ThreadWatcherObserver : public con
   // Called when user activity is detected.
   void OnUserActivityDetected();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<BrowserActivityWatcher> browser_activity_watcher_;
 #endif
 
@@ -97,7 +97,7 @@ ThreadWatcherObserver::ThreadWatcherObse
   DCHECK(!g_thread_watcher_observer_);
   g_thread_watcher_observer_ = this;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   browser_activity_watcher_ = std::make_unique<BrowserActivityWatcher>(
       base::BindRepeating(&ThreadWatcherObserver::OnUserActivityDetected,
                           base::Unretained(this)));
@@ -830,7 +830,7 @@ void WatchDogThread::CleanUp() {
 }
 
 // ShutdownWatcherHelper is not available on Android.
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 namespace {
 
--- a/chrome/browser/metrics/thread_watcher.h
+++ b/chrome/browser/metrics/thread_watcher.h
@@ -497,7 +497,7 @@ class WatchDogThread : public base::Thre
 // ShutdownWatcherHelper is useless on Android because there is no shutdown,
 // Chrome is always killed one way or another (swiped away in the task
 // switcher, OOM-killed, etc.).
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // This is a wrapper class for detecting hangs during shutdown.
 class ShutdownWatcherHelper {
  public:
--- a/chrome/browser/lifetime/browser_shutdown.cc
+++ b/chrome/browser/lifetime/browser_shutdown.cc
@@ -50,7 +50,7 @@
 #include "chrome/browser/win/browser_util.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 #include "chrome/browser/first_run/upgrade_util.h"
 #endif
 
@@ -222,7 +222,7 @@ ShutdownType GetShutdownType() {
   return g_shutdown_type;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 bool ShutdownPreThreadsStop() {
 #if defined(OS_CHROMEOS)
   chromeos::BootTimesRecorder::Get()->AddLogoutTimeMarker(
@@ -445,7 +445,7 @@ void SetTryingToQuit(bool quitting) {
   // attempt is cancelled.
   PrefService* pref_service = g_browser_process->local_state();
   if (pref_service) {
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
     pref_service->ClearPref(prefs::kWasRestarted);
 #endif  // !defined(OS_ANDROID)
     pref_service->ClearPref(prefs::kRestartLastSessionOnShutdown);
--- a/chrome/browser/lifetime/browser_shutdown.h
+++ b/chrome/browser/lifetime/browser_shutdown.h
@@ -13,7 +13,7 @@ class PrefRegistrySimple;
 
 namespace browser_shutdown {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 // The type of restart to perform during shutdown; see ShutdownPostThreadsStop.
 enum class RestartMode {
@@ -75,7 +75,7 @@ bool ShouldIgnoreUnloadHandlers();
 // Get the current shutdown type.
 ShutdownType GetShutdownType();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Performs the shutdown tasks that need to be done before
 // BrowserProcess and the various threads go away.
 //
--- a/chrome/browser/metrics/thread_watcher_report_hang.cc
+++ b/chrome/browser/metrics/thread_watcher_report_hang.cc
@@ -35,7 +35,7 @@ NOINLINE NOT_TAIL_CALLED void ReportThre
 #endif
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 NOINLINE void StartupHang() {
   // TODO(rtenneti): http://crbug.com/440885 enable crashing after fixing false
--- a/chrome/browser/metrics/thread_watcher_report_hang.h
+++ b/chrome/browser/metrics/thread_watcher_report_hang.h
@@ -11,7 +11,7 @@
 
 namespace metrics {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 // This function makes it possible to tell from the callstack why startup is
 // taking too long.
--- a/chrome/browser/first_run/upgrade_util.h
+++ b/chrome/browser/first_run/upgrade_util.h
@@ -10,7 +10,7 @@
 #include "base/callback_forward.h"
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID) || defined(OS_CHROMEOS)
+#if !defined(OS_ANDROID) || defined(OS_CHROMEOS)
 #error Not used on Android or ChromeOS
 #endif
 
--- a/chrome/browser/profiles/profile_metrics.cc
+++ b/chrome/browser/profiles/profile_metrics.cc
@@ -27,13 +27,13 @@
 #include "components/signin/core/browser/signin_header_helper.h"
 #include "content/public/browser/browser_thread.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_finder.h"
 #endif
 
 namespace {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 constexpr base::TimeDelta kProfileActivityThreshold =
     base::TimeDelta::FromDays(28);  // Should be integral number of weeks.
 #endif
@@ -166,7 +166,7 @@ enum ProfileAvatar {
 
 // static
 bool ProfileMetrics::IsProfileActive(const ProfileAttributesEntry* entry) {
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // TODO(mlerman): iOS and Android should set an ActiveTime in the
   // ProfileAttributesStorage. (see ProfileManager::OnBrowserSetLastActive)
   if (base::Time::Now() - entry->GetActiveTime() > kProfileActivityThreshold)
--- a/chrome/browser/download/download_commands.cc
+++ b/chrome/browser/download/download_commands.cc
@@ -28,7 +28,7 @@
 #include "ui/base/clipboard/scoped_clipboard_writer.h"
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
-    defined(OS_MAC)
+    defined(OS_MAC) || defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/scoped_tabbed_browser_displayer.h"
@@ -156,7 +156,7 @@ void DownloadCommands::ExecuteCommand(Co
 }
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 
 Browser* DownloadCommands::GetBrowser() const {
   chrome::ScopedTabbedBrowserDisplayer browser_displayer(model_->profile());
@@ -179,7 +179,7 @@ bool DownloadCommands::CanOpenPdfInSyste
   return IsDownloadPdf() &&
          (IsAdobeReaderDefaultPDFViewer() ? is_adobe_pdf_reader_up_to_date
                                           : true);
-#elif defined(OS_MAC) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_MAC) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
   return IsDownloadPdf();
 #endif
 }
--- a/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
+++ b/chrome/browser/custom_handlers/register_protocol_handler_permission_request.cc
@@ -29,7 +29,13 @@ RegisterProtocolHandlerPermissionRequest
 
 permissions::PermissionRequest::IconId
 RegisterProtocolHandlerPermissionRequest::GetIconId() const {
-  return vector_icons::kProtocolHandlerIcon;
+  return 0;
+}
+
+base::string16 RegisterProtocolHandlerPermissionRequest::GetMessageText() const {
+  return l10n_util::GetStringFUTF16(
+                   IDS_REGISTER_PROTOCOL_HANDLER_CONFIRM,
+                   handler_.GetProtocolDisplayName());
 }
 
 base::string16
--- a/chrome/browser/policy/chrome_browser_policy_connector.cc
+++ b/chrome/browser/policy/chrome_browser_policy_connector.cc
@@ -45,13 +45,12 @@
 #include "base/strings/sys_string_conversions.h"
 #include "components/policy/core/common/policy_loader_mac.h"
 #include "components/policy/core/common/preferences_mac.h"
-#elif defined(OS_POSIX) && !defined(OS_ANDROID)
-#include "components/policy/core/common/config_dir_policy_loader.h"
 #elif defined(OS_ANDROID)
+#include "components/policy/core/common/config_dir_policy_loader.h"
 #include "components/policy/core/common/android/android_combined_policy_provider.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID)
 #include "chrome/browser/policy/chrome_browser_cloud_management_controller_desktop.h"
 #include "components/enterprise/browser/controller/chrome_browser_cloud_management_controller.h"
 #include "components/policy/core/common/cloud/machine_level_user_cloud_policy_manager.h"
@@ -104,7 +103,7 @@ bool ChromeBrowserPolicyConnector::IsEnt
 bool ChromeBrowserPolicyConnector::HasMachineLevelPolicies() {
   if (ProviderHasPolicies(GetPlatformProvider()))
     return true;
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   if (ProviderHasPolicies(machine_level_user_cloud_policy_manager_))
     return true;
 #endif  // !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
@@ -114,7 +113,7 @@ bool ChromeBrowserPolicyConnector::HasMa
 }
 
 void ChromeBrowserPolicyConnector::Shutdown() {
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   // Reset the controller before calling base class so that
   // shutdown occurs in correct sequence.
   chrome_browser_cloud_management_controller_.reset();
@@ -216,7 +215,6 @@ ChromeBrowserPolicyConnector::CreatePlat
   } else {
     return nullptr;
   }
-#elif defined(OS_ANDROID)
   return std::make_unique<policy::android::AndroidCombinedPolicyProvider>(
       GetSchemaRegistry());
 #else
--- a/chrome/browser/policy/chrome_browser_policy_connector.h
+++ b/chrome/browser/policy/chrome_browser_policy_connector.h
@@ -20,7 +20,7 @@ class PrefService;
 namespace policy {
 class ConfigurationPolicyProvider;
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 class ChromeBrowserCloudManagementController;
 class MachineLevelUserCloudPolicyManager;
 #endif
@@ -55,7 +55,7 @@ class ChromeBrowserPolicyConnector : pub
 
   ConfigurationPolicyProvider* GetPlatformProvider();
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   ChromeBrowserCloudManagementController*
   chrome_browser_cloud_management_controller() {
     return chrome_browser_cloud_management_controller_.get();
@@ -84,7 +84,7 @@ class ChromeBrowserPolicyConnector : pub
   // Owned by base class.
   ConfigurationPolicyProvider* platform_provider_ = nullptr;
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   std::unique_ptr<ChromeBrowserCloudManagementController>
       chrome_browser_cloud_management_controller_;
   // Owned by base class.
--- a/chrome/browser/hid/hid_chooser_context.cc
+++ b/chrome/browser/hid/hid_chooser_context.cc
@@ -348,11 +348,6 @@ void HidChooserContext::DeviceRemoved(de
 void HidChooserContext::EnsureHidManagerConnection() {
   if (hid_manager_)
     return;
-
-  mojo::PendingRemote<device::mojom::HidManager> manager;
-  content::GetDeviceService().BindHidManager(
-      manager.InitWithNewPipeAndPassReceiver());
-  SetUpHidManagerConnection(std::move(manager));
 }
 
 void HidChooserContext::SetUpHidManagerConnection(
--- a/chrome/browser/permissions/attestation_permission_request.cc
+++ b/chrome/browser/permissions/attestation_permission_request.cc
@@ -26,9 +26,14 @@ class AttestationPermissionRequest : pub
       : origin_(origin), callback_(std::move(callback)) {}
 
   permissions::PermissionRequest::IconId GetIconId() const override {
-    return kUsbSecurityKeyIcon;
+    return 0;
   }
 
+  base::string16 GetMessageText() const override {
+    return l10n_util::GetStringUTF16(
+        IDS_SECURITY_KEY_ATTESTATION_PERMISSION_FRAGMENT);
+   }
+
   base::string16 GetMessageTextFragment() const override {
     return l10n_util::GetStringUTF16(
         IDS_SECURITY_KEY_ATTESTATION_PERMISSION_FRAGMENT);
--- a/chrome/browser/profiles/profile_window.cc
+++ b/chrome/browser/profiles/profile_window.cc
@@ -53,7 +53,7 @@
 #include "extensions/browser/extension_system.h"
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_finder.h"
 #include "chrome/browser/ui/browser_list.h"
 #include "chrome/browser/ui/browser_list_observer.h"
@@ -254,7 +254,7 @@ void OpenBrowserWindowForProfile(Profile
                                             is_first_run, true);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 void LoadProfileAsync(const base::FilePath& path,
                       ProfileManager::CreateCallback callback) {
--- a/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
+++ b/chrome/browser/resource_coordinator/resource_coordinator_parts.cc
@@ -9,12 +9,12 @@
 namespace resource_coordinator {
 
 ResourceCoordinatorParts::ResourceCoordinatorParts()
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
     : tab_manager_(&tab_load_tracker_),
       tab_lifecycle_unit_source_(tab_manager_.usage_clock())
 #endif
 {
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   tab_lifecycle_unit_source_.AddObserver(&tab_manager_);
 #endif
 }
--- a/chrome/browser/resource_coordinator/resource_coordinator_parts.h
+++ b/chrome/browser/resource_coordinator/resource_coordinator_parts.h
@@ -10,7 +10,7 @@
 #include "chrome/browser/resource_coordinator/tab_load_tracker.h"
 #include "chrome/browser/resource_coordinator/tab_memory_metrics_reporter.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/resource_coordinator/tab_lifecycle_unit_source.h"
 #include "chrome/browser/resource_coordinator/tab_manager.h"
 #endif
@@ -39,7 +39,7 @@ class ResourceCoordinatorParts {
   TabLoadTracker* tab_load_tracker() { return &tab_load_tracker_; }
 
   TabManager* tab_manager() {
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
     return nullptr;
 #else
     return &tab_manager_;
@@ -47,7 +47,7 @@ class ResourceCoordinatorParts {
   }
 
   TabLifecycleUnitSource* tab_lifecycle_unit_source() {
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
     return nullptr;
 #else
     return &tab_lifecycle_unit_source_;
@@ -62,7 +62,7 @@ class ResourceCoordinatorParts {
   // Created on demand the first time it's being accessed.
   std::unique_ptr<TabMemoryMetricsReporter> tab_memory_metrics_reporter_;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Any change to this #ifdef must be reflected as well in
   // chrome/browser/resource_coordinator/tab_manager_browsertest.cc
   //
--- a/chrome/browser/storage/storage_notification_service_impl.cc
+++ b/chrome/browser/storage/storage_notification_service_impl.cc
@@ -11,7 +11,7 @@
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/common/chrome_switches.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/storage_pressure_bubble.h"
 #endif
 
--- a/chrome/browser/chrome_browser_main_posix.cc
+++ b/chrome/browser/chrome_browser_main_posix.cc
@@ -172,7 +172,5 @@ void ChromeBrowserMainPartsPosix::ShowMi
   // TODO(port): We may want a views based message dialog here eventually, but
   // for now, crash.
   NOTREACHED();
-#else
-#error "Need MessageBox implementation."
 #endif
 }
--- a/chrome/browser/first_run/first_run_internal_posix.cc
+++ b/chrome/browser/first_run/first_run_internal_posix.cc
@@ -96,7 +96,7 @@ void ForceFirstRunDialogShownForTesting(
 }
 
 void DoPostImportPlatformSpecificTasks(Profile* profile) {
-#if !defined(OS_CHROMEOS)
+#if defined(OS_CHROMEOS)
   if (!ShouldShowFirstRunDialog())
     return;
 
--- a/chrome/browser/ui/search/search_ipc_router_policy_impl.h
+++ b/chrome/browser/ui/search/search_ipc_router_policy_impl.h
@@ -9,7 +9,7 @@
 #include "build/build_config.h"
 #include "chrome/browser/ui/search/search_ipc_router.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/ui/search/ntp_user_data_logger.h
+++ b/chrome/browser/ui/search/ntp_user_data_logger.h
@@ -21,7 +21,7 @@
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_contents_user_data.h"
 
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
 #error "Instant is only used on desktop";
 #endif
 
--- a/chrome/browser/engagement/important_sites_util.h
+++ b/chrome/browser/engagement/important_sites_util.h
@@ -76,7 +76,7 @@ class ImportantSitesUtil {
       Profile* profile,
       size_t max_results);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Return the top |<=max_results| important registrable domains that have an
   // associated installed app. |max_results| is assumed to be small.
   static std::vector<ImportantDomainInfo> GetInstalledRegisterableDomains(
--- a/chrome/browser/engagement/important_sites_util.cc
+++ b/chrome/browser/engagement/important_sites_util.cc
@@ -39,7 +39,6 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/search_permissions/search_permissions_service.h"
-#else
 #include "chrome/browser/web_applications/components/web_app_id.h"
 #include "chrome/browser/web_applications/web_app_provider.h"
 #include "chrome/browser/web_applications/web_app_registrar.h"
@@ -359,7 +358,7 @@ void PopulateInfoMapWithBookmarks(
 // about clearing data for installed apps, so this and any functions explicitly
 // used to warn about clearing data for installed apps can be excluded from the
 // Android build.
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void PopulateInfoMapWithInstalledEngagedInTimePeriod(
     browsing_data::TimePeriod time_period,
     Profile* profile,
@@ -489,7 +488,7 @@ ImportantSitesUtil::GetImportantRegister
   return final_list;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::vector<ImportantDomainInfo>
 ImportantSitesUtil::GetInstalledRegisterableDomains(
     browsing_data::TimePeriod time_period,
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -250,12 +250,12 @@ extern const char kAllowNaClSocketAPI[];
 #endif
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || \
-    defined(OS_WIN)
+    defined(OS_WIN) || defined(OS_ANDROID)
 extern const char kEnableNewAppMenuIcon[];
 extern const char kGuest[];
 #endif
 
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
 extern const char kUseSystemDefaultPrinter[];
 #endif
 
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -797,14 +797,14 @@ const char kAllowNaClSocketAPI[]
 #endif
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || \
-    defined(OS_WIN)
+    defined(OS_WIN) || defined(OS_ANDROID)
 const char kEnableNewAppMenuIcon[] = "enable-new-app-menu-icon";
 
 // Causes the browser to launch directly in guest mode.
 const char kGuest[] = "guest";
 #endif
 
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
 // Uses the system default printer as the initially selected destination in
 // print preview, instead of the most recently used destination.
 const char kUseSystemDefaultPrinter[] = "use-system-default-printer";
--- a/chrome/common/webui_url_constants.cc
+++ b/chrome/common/webui_url_constants.cc
@@ -201,7 +201,6 @@ const char kChromeUISnippetsInternalsHos
 const char kChromeUIUntrustedVideoPlayerUrl[] =
     "chrome-untrusted://video-tutorials/";
 const char kChromeUIWebApksHost[] = "webapks";
-#else
 const char kChromeUINearbyInternalsHost[] = "nearby-internals";
 const char kChromeUIReadLaterHost[] = "read-later";
 const char kChromeUIReadLaterURL[] = "chrome://read-later/";
@@ -345,14 +344,14 @@ const char kChromeUIWebUIJsExceptionURL[
 #endif
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 const char kChromeUIDiscardsHost[] = "discards";
 const char kChromeUIDiscardsURL[] = "chrome://discards/";
 const char kChromeUIHatsHost[] = "hats";
 const char kChromeUIHatsURL[] = "chrome://hats/";
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 const char kChromeUINearbyShareHost[] = "nearby";
 const char kChromeUINearbyShareURL[] = "chrome://nearby/";
 #endif  // !defined(OS_ANDROID)
@@ -366,7 +365,7 @@ const char kChromeUILinuxProxyConfigHost
 const char kChromeUISandboxHost[] = "sandbox";
 #endif
 
-#if defined(OS_WIN) || defined(OS_MAC) || \
+#if defined(OS_WIN) || defined(OS_MAC) || defined(OS_ANDROID) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
 const char kChromeUIBrowserSwitchHost[] = "browser-switch";
 const char kChromeUIBrowserSwitchURL[] = "chrome://browser-switch/";
@@ -392,7 +391,7 @@ const char kChromeUITabStripHost[] = "ta
 const char kChromeUITabStripURL[] = "chrome://tab-strip";
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 const char kChromeUICommanderHost[] = "commander";
 const char kChromeUICommanderURL[] = "chrome://commander";
 const char kChromeUITabSearchHost[] = "tab-search";
--- a/chrome/common/webui_url_constants.h
+++ b/chrome/common/webui_url_constants.h
@@ -197,7 +197,6 @@ extern const char kChromeUINativeNewTabU
 extern const char kChromeUISnippetsInternalsHost[];
 extern const char kChromeUIUntrustedVideoPlayerUrl[];
 extern const char kChromeUIWebApksHost[];
-#else
 extern const char kChromeUINearbyInternalsHost[];
 extern const char kChromeUIReadLaterHost[];
 extern const char kChromeUIReadLaterURL[];
@@ -298,14 +297,14 @@ extern const char kChromeUIWebUIJsExcept
 #endif
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 extern const char kChromeUIDiscardsHost[];
 extern const char kChromeUIDiscardsURL[];
 extern const char kChromeUIHatsHost[];
 extern const char kChromeUIHatsURL[];
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kChromeUINearbyShareHost[];
 extern const char kChromeUINearbyShareURL[];
 #endif  // !defined(OS_CHROMEOS)
@@ -319,7 +318,7 @@ extern const char kChromeUILinuxProxyCon
 extern const char kChromeUISandboxHost[];
 #endif
 
-#if defined(OS_WIN) || defined(OS_MAC) || \
+#if defined(OS_WIN) || defined(OS_MAC) || defined(OS_ANDROID) || \
     (defined(OS_LINUX) && !defined(OS_CHROMEOS))
 extern const char kChromeUIBrowserSwitchHost[];
 extern const char kChromeUIBrowserSwitchURL[];
@@ -344,7 +343,7 @@ extern const char kChromeUITabStripHost[
 extern const char kChromeUITabStripURL[];
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const char kChromeUICommanderHost[];
 extern const char kChromeUICommanderURL[];
 extern const char kChromeUITabSearchHost[];
--- a/chrome/browser/profiles/profile_manager.cc
+++ b/chrome/browser/profiles/profile_manager.cc
@@ -123,7 +123,6 @@
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/metrics/android_profile_session_durations_service_factory.h"
-#else
 #include "chrome/browser/accessibility/caption_controller.h"
 #include "chrome/browser/accessibility/caption_controller_factory.h"
 #include "chrome/browser/first_run/first_run.h"
@@ -147,7 +146,7 @@
 #include "components/user_manager/user_type.h"
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 #include "chrome/browser/profiles/profile_statistics.h"
 #include "chrome/browser/profiles/profile_statistics_factory.h"
 #endif
@@ -237,7 +236,7 @@ void ProfileSizeTask(const base::FilePat
     UMA_HISTOGRAM_COUNTS_10000("Profile.AppCount", enabled_app_count);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Schedule a profile for deletion if it isn't already scheduled.
 // Returns whether the profile has been newly scheduled.
 bool ScheduleProfileDirectoryForDeletion(const base::FilePath& path) {
@@ -330,7 +329,7 @@ void OnProfileLoaded(ProfileManager::Pro
       .Run(incognito ? profile->GetPrimaryOTRProfile() : profile);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Helper function for ScheduleForcedEphemeralProfileForDeletion.
 bool IsRegisteredAsEphemeral(ProfileAttributesStorage* storage,
                              const base::FilePath& profile_dir) {
@@ -874,7 +873,7 @@ ProfileShortcutManager* ProfileManager::
   return profile_shortcut_manager_.get();
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void ProfileManager::MaybeScheduleProfileForDeletion(
     const base::FilePath& profile_dir,
     ProfileLoadedCallback callback,
@@ -1097,7 +1096,7 @@ void ProfileManager::InitProfileUserPref
     } else if (profile->GetPath() ==
                    profiles::GetDefaultProfileDir(user_data_dir())) {
       avatar_index = profiles::GetPlaceholderAvatarIndex();
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
       profile_name =
           base::UTF16ToUTF8(storage.ChooseNameForNewProfile(avatar_index));
 #else
@@ -1326,7 +1325,7 @@ void ProfileManager::DoFinalInitForServi
   ChildAccountServiceFactory::GetForProfile(profile)->Init();
   SupervisedUserServiceFactory::GetForProfile(profile)->Init();
 #endif
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   // If the lock enabled algorithm changed, update this profile's lock status.
   // This depends on services which shouldn't be initialized until
   // DoFinalInitForServices.
@@ -1481,7 +1480,7 @@ bool ProfileManager::AddProfile(std::uni
   return true;
 }
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 void ProfileManager::RemoveProfile(const base::FilePath& profile_dir) {
   TRACE_EVENT0("browser", "ProfileManager::RemoveProfile");
 
@@ -1554,7 +1553,7 @@ Profile* ProfileManager::CreateAndInitia
   return profile_ptr;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void ProfileManager::EnsureActiveProfileExistsBeforeDeletion(
     ProfileLoadedCallback callback,
     const base::FilePath& profile_dir) {
@@ -1791,7 +1790,7 @@ void ProfileManager::AddProfileToStorage
     bool has_entry = storage.GetProfileAttributesWithPath(profile->GetPath(),
                                                           &entry);
     if (has_entry) {
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
       bool was_authenticated_status = entry->IsAuthenticated();
 #endif
       // The ProfileAttributesStorage's info must match the Identity Manager.
@@ -1800,7 +1799,7 @@ void ProfileManager::AddProfileToStorage
 
       entry->SetSignedInWithCredentialProvider(false);
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
       // Sign out if force-sign-in policy is enabled and profile is not signed
       // in.
       VLOG(1) << "ForceSigninCheck: " << signin_util::IsForceSigninEnabled()
@@ -1923,7 +1922,7 @@ void ProfileManager::SaveActiveProfiles(
   }
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void ProfileManager::OnBrowserOpened(Browser* browser) {
   DCHECK(browser);
   Profile* profile = browser->profile();
--- a/chrome/browser/profiles/profile_manager.h
+++ b/chrome/browser/profiles/profile_manager.h
@@ -27,7 +27,7 @@
 #include "content/public/browser/notification_observer.h"
 #include "content/public/browser/notification_registrar.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_list_observer.h"
 #endif  // !defined(OS_ANDROID)
 
@@ -206,7 +206,7 @@ class ProfileManager : public content::N
   // profile specfic desktop shortcuts.
   ProfileShortcutManager* profile_shortcut_manager();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Less strict version of ScheduleProfileForDeletion(), silently exits if
   // profile is either scheduling or marked for deletion.
   void MaybeScheduleProfileForDeletion(
@@ -320,7 +320,7 @@ class ProfileManager : public content::N
   // Returns true if the profile was added, false otherwise.
   bool AddProfile(std::unique_ptr<Profile> profile);
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   // Removes the Profile at |profile_dir| from the manager and destroys it. If
   // it's an ephemeral profile, also nuke the |profile_dir| directory from disk
   // afterwards.
@@ -332,7 +332,7 @@ class ProfileManager : public content::N
   // null if creation fails.
   Profile* CreateAndInitializeProfile(const base::FilePath& profile_dir);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Continues the scheduled profile deletion after closing all the profile's
   // browsers tabs. Creates a new profile if the profile to be deleted is the
   // last non-supervised profile. In the Mac, loads the next non-supervised
@@ -393,7 +393,7 @@ class ProfileManager : public content::N
 
   void SaveActiveProfiles();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   void OnBrowserOpened(Browser* browser);
   void OnBrowserClosed(Browser* browser);
 
@@ -458,7 +458,7 @@ class ProfileManager : public content::N
   // default.
   bool logged_in_ = false;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   BrowserListObserver browser_list_observer_{this};
 #endif  // !defined(OS_ANDROID)
 
--- a/components/ui_devtools/views/overlay_agent_views.cc
+++ b/components/ui_devtools/views/overlay_agent_views.cc
@@ -19,6 +19,8 @@
 #include "ui/views/background.h"
 #include "ui/views/border.h"
 
+#include "ui/android/window_android.h"
+
 #if defined(USE_AURA)
 #include "ui/aura/window.h"
 #include "ui/wm/core/window_util.h"
@@ -567,7 +569,6 @@ void OverlayAgentViews::OnPaintLayer(con
   gfx::Canvas* canvas = recorder.canvas();
   // Convert the hovered rect from screen coordinates to layer coordinates.
   gfx::RectF hovered_rect_f(hovered_rect_);
-  hovered_rect_f.Offset(-layer_for_highlighting_screen_offset_);
 
   cc::PaintFlags flags;
   flags.setStrokeWidth(1.0f);
@@ -601,7 +602,6 @@ void OverlayAgentViews::OnPaintLayer(con
 
   // Convert the pinned rect from screen coordinates to layer coordinates.
   gfx::RectF pinned_rect_f(pinned_rect_);
-  pinned_rect_f.Offset(-layer_for_highlighting_screen_offset_);
 
   // Draw |pinned_rect_f| bounds in blue.
   canvas->DrawRect(pinned_rect_f, flags);
@@ -706,35 +706,7 @@ void OverlayAgentViews::OnPaintLayer(con
 
 bool OverlayAgentViews::UpdateHighlight(
     const std::pair<gfx::NativeWindow, gfx::Rect>& window_and_bounds) {
-  if (window_and_bounds.second.IsEmpty()) {
-    hovered_rect_.SetRect(0, 0, 0, 0);
-    return false;
-  }
-  ui::Layer* root_layer = nullptr;
-#if defined(OS_APPLE)
-  views::Widget* widget =
-      views::Widget::GetWidgetForNativeWindow(window_and_bounds.first);
-  root_layer = widget->GetLayer();
-  layer_for_highlighting_screen_offset_ =
-      widget->GetContentsView()->GetBoundsInScreen().OffsetFromOrigin();
-#else
-  gfx::NativeWindow root = window_and_bounds.first->GetRootWindow();
-  root_layer = root->layer();
-  layer_for_highlighting_screen_offset_ =
-      root->GetBoundsInScreen().OffsetFromOrigin();
-#endif  // defined(OS_APPLE)
-  DCHECK(root_layer);
-
-  layer_for_highlighting_->SetBounds(root_layer->bounds());
-  layer_for_highlighting_->SchedulePaint(root_layer->bounds());
-
-  if (root_layer != layer_for_highlighting_->parent())
-    root_layer->Add(layer_for_highlighting_.get());
-  else
-    root_layer->StackAtTop(layer_for_highlighting_.get());
-
-  hovered_rect_ = window_and_bounds.second;
-  return true;
+  return false;
 }
 
 }  // namespace ui_devtools
--- a/components/url_formatter/elide_url.cc
+++ b/components/url_formatter/elide_url.cc
@@ -26,7 +26,7 @@
 
 namespace {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 const base::char16 kDot = '.';
 
 // Build a path from the first |num_components| elements in |path_elements|.
@@ -160,7 +160,7 @@ base::string16 HostForDisplay(base::Stri
 
 namespace url_formatter {
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 
 // TODO(pkasting): http://crbug.com/77883 This whole function gets
 // kerning/ligatures/etc. issues potentially wrong by assuming that the width of
--- a/components/url_formatter/elide_url.h
+++ b/components/url_formatter/elide_url.h
@@ -26,7 +26,7 @@ namespace url_formatter {
 
 // ElideUrl and Elide host require
 // gfx::GetStringWidthF which is not implemented in Android
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // This function takes a GURL object and elides it. It returns a string
 // composed of parts from subdomain, domain, path, filename and query.
 // A "..." is added automatically at the end if the elided string is bigger
--- a/content/public/browser/desktop_media_id.cc
+++ b/content/public/browser/desktop_media_id.cc
@@ -22,22 +22,20 @@ namespace content {
 const char kScreenPrefix[] = "screen";
 const char kWindowPrefix[] = "window";
 
-#if defined(USE_AURA) || defined(OS_MAC)
+#if defined(USE_AURA) || defined(OS_MAC) || defined(OS_ANDROID)
 // static
 DesktopMediaID DesktopMediaID::RegisterNativeWindow(DesktopMediaID::Type type,
                                                     gfx::NativeWindow window) {
   DCHECK(type == TYPE_SCREEN || type == TYPE_WINDOW);
   DCHECK(window);
   DesktopMediaID media_id(type, kNullId);
-  media_id.window_id =
-      DesktopMediaWindowRegistry::GetInstance()->RegisterWindow(window);
   return media_id;
 }
 
 // static
 gfx::NativeWindow DesktopMediaID::GetNativeWindowById(
     const DesktopMediaID& id) {
-  return DesktopMediaWindowRegistry::GetInstance()->GetWindowById(id.window_id);
+  return nullptr;
 }
 #endif
 
--- a/content/public/browser/desktop_media_id.h
+++ b/content/public/browser/desktop_media_id.h
@@ -28,7 +28,7 @@ struct CONTENT_EXPORT DesktopMediaID {
   // Represents a fake id to create a dummy capturer for autotests.
   static constexpr Id kFakeId = -3;
 
-#if defined(USE_AURA) || defined(OS_MAC)
+#if defined(USE_AURA) || defined(OS_MAC) || defined(OS_ANDROID)
   // Assigns integer identifier to the |window| and returns its DesktopMediaID.
   static DesktopMediaID RegisterNativeWindow(Type type,
                                              gfx::NativeWindow window);
--- a/chrome/browser/ui/passwords/password_generation_popup_controller_impl.cc
+++ b/chrome/browser/ui/passwords/password_generation_popup_controller_impl.cc
@@ -272,7 +272,7 @@ void PasswordGenerationPopupControllerIm
   }
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void PasswordGenerationPopupControllerImpl::OnZoomChanged(
     const zoom::ZoomController::ZoomChangedEventData& data) {
   HideImpl();
--- a/chrome/browser/ui/passwords/password_generation_popup_controller_impl.h
+++ b/chrome/browser/ui/passwords/password_generation_popup_controller_impl.h
@@ -25,7 +25,7 @@
 #include "ui/gfx/geometry/rect_f.h"
 #include "ui/gfx/native_widget_types.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "components/zoom/zoom_observer.h"
 #endif  // !defined(OS_ANDROID)
 
@@ -60,7 +60,7 @@ class PasswordGenerationPopupView;
 class PasswordGenerationPopupControllerImpl
     : public PasswordGenerationPopupController,
       public content::WebContentsObserver
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
     ,
       public zoom::ZoomObserver
 #endif  // !defined(OS_ANDROID)
@@ -106,7 +106,7 @@ class PasswordGenerationPopupControllerI
   void DidFinishNavigation(
       content::NavigationHandle* navigation_handle) override;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // ZoomObserver implementation.
   void OnZoomChanged(
       const zoom::ZoomController::ZoomChangedEventData& data) override;
--- a/content/public/browser/native_web_keyboard_event.h
+++ b/content/public/browser/native_web_keyboard_event.h
@@ -48,7 +48,6 @@ struct CONTENT_EXPORT NativeWebKeyboardE
       int scancode,
       int unicode_character,
       bool is_system_key);
-#else
   explicit NativeWebKeyboardEvent(const ui::KeyEvent& key_event);
 #if defined(USE_AURA)
   // Create a legacy keypress event specified by |character|.
--- a/content/browser/renderer_host/native_web_keyboard_event_android.cc
+++ b/content/browser/renderer_host/native_web_keyboard_event_android.cc
@@ -64,6 +64,8 @@ NativeWebKeyboardEvent& NativeWebKeyboar
   return *this;
 }
 
+NativeWebKeyboardEvent::NativeWebKeyboardEvent(const ui::KeyEvent& key_event) {}
+
 NativeWebKeyboardEvent::~NativeWebKeyboardEvent() {}
 
 }  // namespace content
--- a/chrome/browser/ui/views/frame/browser_view.cc
+++ b/chrome/browser/ui/views/frame/browser_view.cc
@@ -1870,7 +1870,6 @@ void BrowserView::UserChangedTheme(Brows
   // In Incognito, the usage of dark or normal hinges on the browser theme.
   if (theme_change_type == BrowserThemeChangeType::kBrowserTheme &&
       !IsRegularOrGuestSession()) {
-    ui::NativeTheme::GetInstanceForDarkUI()->NotifyObservers();
     ui::NativeTheme::GetInstanceForNativeUi()->NotifyObservers();
 
     // Early exit. A native theme change will update all the
@@ -3422,7 +3421,7 @@ void BrowserView::ShowAvatarBubbleFromAv
   profiles::BubbleViewMode bubble_view_mode;
   profiles::BubbleViewModeFromAvatarBubbleMode(mode, GetProfile(),
                                                &bubble_view_mode);
-#if !defined(OS_CHROMEOS)
+#if defined(OS_CHROMEOS)
   if (SigninViewController::ShouldShowSigninForMode(bubble_view_mode)) {
     browser_->signin_view_controller()->ShowSignin(bubble_view_mode,
                                                    access_point);
--- a/chrome/browser/ui/views/location_bar/location_bar_view.cc
+++ b/chrome/browser/ui/views/location_bar/location_bar_view.cc
@@ -259,7 +259,7 @@ void LocationBarView::Init() {
     // The send tab to self icon is intentionally the first one added so it is
     // the left most icon.
     params.types_enabled.push_back(PageActionIconType::kSendTabToSelf);
-    if (base::FeatureList::IsEnabled(kClickToCallUI))
+    if (false)
       params.types_enabled.push_back(PageActionIconType::kClickToCall);
     if (base::FeatureList::IsEnabled(kSharingQRCodeGenerator))
       params.types_enabled.push_back(PageActionIconType::kQRCodeGenerator);
--- a/components/omnibox/browser/omnibox_popup_model.cc
+++ b/components/omnibox/browser/omnibox_popup_model.cc
@@ -23,7 +23,7 @@
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/gfx/geometry/rect.h"
 
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
 #include "components/omnibox/browser/vector_icons.h"  // nogncheck
 #include "ui/gfx/paint_vector_icon.h"
 #include "ui/gfx/vector_icon_types.h"
@@ -297,7 +297,7 @@ void OmniboxPopupModel::SetRichSuggestio
 }
 
 // Android and iOS have their own platform-specific icon logic.
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
 gfx::Image OmniboxPopupModel::GetMatchIcon(const AutocompleteMatch& match,
                                            SkColor vector_icon_color) {
   gfx::Image extension_icon =
--- a/components/omnibox/browser/omnibox_popup_model.h
+++ b/components/omnibox/browser/omnibox_popup_model.h
@@ -208,7 +208,7 @@ class OmniboxPopupModel {
   // Stores the image in a local data member and schedules a repaint.
   void SetRichSuggestionBitmap(int result_index, const SkBitmap& bitmap);
 
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
   // Gets the icon for the match index.
   gfx::Image GetMatchIcon(const AutocompleteMatch& match,
                           SkColor vector_icon_color);
--- a/third_party/blink/public/mojom/payments/payment_request.mojom
+++ b/third_party/blink/public/mojom/payments/payment_request.mojom
@@ -249,8 +249,7 @@ interface PaymentRequest {
   Init(pending_remote<PaymentRequestClient> client,
        array<PaymentMethodData> method_data,
        PaymentDetails details,
-       PaymentOptions options,
-       [EnableIf=is_android] bool google_pay_bridge_eligible);
+       PaymentOptions options);
 
   // Shows the user interface with the payment details.
   // |is_user_gesture|: Whether the show is triggered from a user gesture.
--- a/third_party/blink/renderer/modules/payments/payment_request.cc
+++ b/third_party/blink/renderer/modules/payments/payment_request.cc
@@ -1311,7 +1311,7 @@ PaymentRequest::PaymentRequest(
   UseCounter::Count(execution_context, WebFeature::kPaymentRequestInitialized);
   mojo::PendingRemote<payments::mojom::blink::PaymentRequestClient> client;
   client_receiver_.Bind(client.InitWithNewPipeAndPassReceiver(), task_runner);
-#if defined(OS_ANDROID)
+#if !defined(OS_ANDROID)
   payment_provider_->Init(
       std::move(client), std::move(validated_method_data),
       std::move(validated_details),
--- a/components/omnibox/browser/autocomplete_match.cc
+++ b/components/omnibox/browser/autocomplete_match.cc
@@ -36,7 +36,7 @@
 #include "ui/gfx/vector_icon_types.h"
 #include "url/third_party/mozilla/url_parse.h"
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 #include "components/omnibox/browser/vector_icons.h"  // nogncheck
 #include "components/vector_icons/vector_icons.h"     // nogncheck
 #endif
@@ -257,7 +257,7 @@ AutocompleteMatch& AutocompleteMatch::op
   return *this;
 }
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 const gfx::VectorIcon& AutocompleteMatch::GetVectorIcon(
     bool is_bookmark) const {
   if (is_bookmark)
--- a/components/omnibox/browser/autocomplete_match.h
+++ b/components/omnibox/browser/autocomplete_match.h
@@ -185,7 +185,7 @@ struct AutocompleteMatch {
 
   AutocompleteMatch& operator=(const AutocompleteMatch& match);
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
   // Gets the vector icon identifier for the icon to be shown for this match. If
   // |is_bookmark| is true, returns a bookmark icon rather than what the type
   // would normally determine.  Note that in addition to |type|, the icon chosen
--- a/components/omnibox/browser/omnibox_pedal.cc
+++ b/components/omnibox/browser/omnibox_pedal.cc
@@ -13,7 +13,7 @@
 #include "components/omnibox/browser/omnibox_field_trial.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 #include "components/omnibox/browser/vector_icons.h"  // nogncheck
 #endif
 
@@ -126,7 +126,7 @@ bool OmniboxPedal::IsReadyToTrigger(
   return true;
 }
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 const gfx::VectorIcon& OmniboxPedal::GetVectorIcon() const {
   return omnibox::kPedalIcon;
 }
--- a/components/omnibox/browser/omnibox_pedal.h
+++ b/components/omnibox/browser/omnibox_pedal.h
@@ -16,7 +16,7 @@
 #include "components/omnibox/browser/omnibox_pedal_concepts.h"
 #include "url/gurl.h"
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 namespace gfx {
 struct VectorIcon;
 }
@@ -143,7 +143,7 @@ class OmniboxPedal {
   virtual bool IsReadyToTrigger(const AutocompleteInput& input,
                                 const AutocompleteProviderClient& client) const;
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
   // Returns the vector icon to represent this Pedal's action in suggestion.
   virtual const gfx::VectorIcon& GetVectorIcon() const;
 #endif
--- a/components/omnibox/browser/omnibox_pedal_implementations.cc
+++ b/components/omnibox/browser/omnibox_pedal_implementations.cc
@@ -13,7 +13,7 @@
 #include "components/omnibox/browser/omnibox_pedal.h"
 #include "components/strings/grit/components_strings.h"
 
-#if (!defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
+#if (defined(OS_ANDROID) || BUILDFLAG(ENABLE_VR)) && !defined(OS_IOS)
 #include "components/omnibox/browser/vector_icons.h"  // nogncheck
 #endif
 
--- a/chrome/browser/ui/views/browser_dialogs_views.cc
+++ b/chrome/browser/ui/views/browser_dialogs_views.cc
@@ -17,15 +17,6 @@
 // This file provides definitions of desktop browser dialog-creation methods for
 // all toolkit-views platforms.
 // static
-std::unique_ptr<LoginHandler> LoginHandler::Create(
-    const net::AuthChallengeInfo& auth_info,
-    content::WebContents* web_contents,
-    LoginAuthRequiredCallback auth_required_callback) {
-  return chrome::CreateLoginHandlerViews(auth_info, web_contents,
-                                         std::move(auth_required_callback));
-}
-
-// static
 void BookmarkEditor::Show(gfx::NativeWindow parent_window,
                           Profile* profile,
                           const EditDetails& details,
--- a/chrome/browser/ui/content_settings/content_setting_image_model.cc
+++ b/chrome/browser/ui/content_settings/content_setting_image_model.cc
@@ -246,8 +246,6 @@ const ContentSettingsImageDetails kImage
      IDS_BLOCKED_PLUGINS_MESSAGE, IDS_BLOCKED_PLUGIN_EXPLANATORY_TEXT, 0},
     {ContentSettingsType::MIXEDSCRIPT, kMixedContentIcon,
      IDS_BLOCKED_DISPLAYING_INSECURE_CONTENT, 0, 0},
-    {ContentSettingsType::PPAPI_BROKER, vector_icons::kExtensionIcon,
-     IDS_BLOCKED_PPAPI_BROKER_MESSAGE, 0, IDS_ALLOWED_PPAPI_BROKER_MESSAGE},
     {ContentSettingsType::SOUND, kTabAudioIcon, IDS_BLOCKED_SOUND_TITLE, 0, 0},
     {ContentSettingsType::ADS, vector_icons::kAdsIcon,
      IDS_BLOCKED_ADS_PROMPT_TOOLTIP, IDS_BLOCKED_ADS_PROMPT_TITLE, 0},
--- a/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
+++ b/chrome/browser/ui/content_settings/content_setting_bubble_model.cc
@@ -228,7 +228,6 @@ void ContentSettingSimpleBubbleModel::Se
       {ContentSettingsType::PLUGINS, IDS_BLOCKED_PLUGINS_TITLE},
       {ContentSettingsType::MIXEDSCRIPT,
        IDS_BLOCKED_DISPLAYING_INSECURE_CONTENT_TITLE},
-      {ContentSettingsType::PPAPI_BROKER, IDS_BLOCKED_PPAPI_BROKER_TITLE},
       {ContentSettingsType::SOUND, IDS_BLOCKED_SOUND_TITLE},
       {ContentSettingsType::CLIPBOARD_READ_WRITE, IDS_BLOCKED_CLIPBOARD_TITLE},
       {ContentSettingsType::GEOLOCATION, IDS_BLOCKED_GEOLOCATION_TITLE},
@@ -238,7 +237,6 @@ void ContentSettingSimpleBubbleModel::Se
   // Fields as for kBlockedTitleIDs, above.
   static const ContentSettingsTypeIdEntry kAccessedTitleIDs[] = {
       {ContentSettingsType::COOKIES, IDS_ACCESSED_COOKIES_TITLE},
-      {ContentSettingsType::PPAPI_BROKER, IDS_ALLOWED_PPAPI_BROKER_TITLE},
       {ContentSettingsType::CLIPBOARD_READ_WRITE, IDS_ALLOWED_CLIPBOARD_TITLE},
       {ContentSettingsType::GEOLOCATION, IDS_ALLOWED_GEOLOCATION_TITLE},
       {ContentSettingsType::MIDI_SYSEX, IDS_ALLOWED_MIDI_SYSEX_TITLE},
@@ -269,7 +267,6 @@ void ContentSettingSimpleBubbleModel::Se
       // {ContentSettingsType::POPUPS, No message. intentionally left out},
       {ContentSettingsType::MIXEDSCRIPT,
        IDS_BLOCKED_DISPLAYING_INSECURE_CONTENT},
-      {ContentSettingsType::PPAPI_BROKER, IDS_BLOCKED_PPAPI_BROKER_MESSAGE},
       {ContentSettingsType::GEOLOCATION, IDS_BLOCKED_GEOLOCATION_MESSAGE},
       {ContentSettingsType::MIDI_SYSEX, IDS_BLOCKED_MIDI_SYSEX_MESSAGE},
       {ContentSettingsType::CLIPBOARD_READ_WRITE,
@@ -282,7 +279,6 @@ void ContentSettingSimpleBubbleModel::Se
   // Fields as for kBlockedMessageIDs, above.
   const ContentSettingsTypeIdEntry kAccessedMessageIDs[] = {
       {ContentSettingsType::COOKIES, IDS_ACCESSED_COOKIES_MESSAGE},
-      {ContentSettingsType::PPAPI_BROKER, IDS_ALLOWED_PPAPI_BROKER_MESSAGE},
       {ContentSettingsType::GEOLOCATION, IDS_ALLOWED_GEOLOCATION_MESSAGE},
       {ContentSettingsType::MIDI_SYSEX, IDS_ALLOWED_MIDI_SYSEX_MESSAGE},
       {ContentSettingsType::CLIPBOARD_READ_WRITE,
@@ -542,8 +538,7 @@ ContentSettingPluginBubbleModel::Content
       GetSettingManagedByUser(url, content_type(), GetProfile(), nullptr);
   HostContentSettingsMap* map =
       HostContentSettingsMapFactory::GetForProfile(GetProfile());
-  ContentSetting setting = PluginUtils::GetFlashPluginContentSetting(
-      map, url::Origin::Create(url), url, nullptr);
+  ContentSetting setting = CONTENT_SETTING_BLOCK;
 
   // If the setting is not managed by the user, hide the "Manage" button.
   if (!managed_by_user)
@@ -647,7 +642,6 @@ void ContentSettingSingleRadioGroup::Set
       {ContentSettingsType::IMAGES, IDS_BLOCKED_IMAGES_UNBLOCK},
       {ContentSettingsType::JAVASCRIPT, IDS_BLOCKED_JAVASCRIPT_UNBLOCK},
       {ContentSettingsType::POPUPS, IDS_BLOCKED_POPUPS_REDIRECTS_UNBLOCK},
-      {ContentSettingsType::PPAPI_BROKER, IDS_BLOCKED_PPAPI_BROKER_UNBLOCK},
       {ContentSettingsType::SOUND, IDS_BLOCKED_SOUND_UNBLOCK},
       {ContentSettingsType::GEOLOCATION, IDS_BLOCKED_GEOLOCATION_UNBLOCK},
       {ContentSettingsType::MIDI_SYSEX, IDS_BLOCKED_MIDI_SYSEX_UNBLOCK},
@@ -658,7 +652,6 @@ void ContentSettingSingleRadioGroup::Set
   // Fields as for kBlockedAllowIDs, above.
   static const ContentSettingsTypeIdEntry kAllowedAllowIDs[] = {
       {ContentSettingsType::COOKIES, IDS_ALLOWED_COOKIES_NO_ACTION},
-      {ContentSettingsType::PPAPI_BROKER, IDS_ALLOWED_PPAPI_BROKER_NO_ACTION},
       {ContentSettingsType::GEOLOCATION, IDS_ALLOWED_GEOLOCATION_NO_ACTION},
       {ContentSettingsType::MIDI_SYSEX, IDS_ALLOWED_MIDI_SYSEX_NO_ACTION},
       {ContentSettingsType::CLIPBOARD_READ_WRITE,
@@ -683,7 +676,6 @@ void ContentSettingSingleRadioGroup::Set
       {ContentSettingsType::IMAGES, IDS_BLOCKED_IMAGES_NO_ACTION},
       {ContentSettingsType::JAVASCRIPT, IDS_BLOCKED_JAVASCRIPT_NO_ACTION},
       {ContentSettingsType::POPUPS, IDS_BLOCKED_POPUPS_REDIRECTS_NO_ACTION},
-      {ContentSettingsType::PPAPI_BROKER, IDS_BLOCKED_PPAPI_BROKER_NO_ACTION},
       {ContentSettingsType::SOUND, IDS_BLOCKED_SOUND_NO_ACTION},
       {ContentSettingsType::GEOLOCATION, IDS_BLOCKED_GEOLOCATION_NO_ACTION},
       {ContentSettingsType::MIDI_SYSEX, IDS_BLOCKED_MIDI_SYSEX_NO_ACTION},
@@ -693,7 +685,6 @@ void ContentSettingSingleRadioGroup::Set
   };
   static const ContentSettingsTypeIdEntry kAllowedBlockIDs[] = {
       {ContentSettingsType::COOKIES, IDS_ALLOWED_COOKIES_BLOCK},
-      {ContentSettingsType::PPAPI_BROKER, IDS_ALLOWED_PPAPI_BROKER_BLOCK},
       {ContentSettingsType::GEOLOCATION, IDS_ALLOWED_GEOLOCATION_BLOCK},
       {ContentSettingsType::MIDI_SYSEX, IDS_ALLOWED_MIDI_SYSEX_BLOCK},
       {ContentSettingsType::CLIPBOARD_READ_WRITE, IDS_ALLOWED_CLIPBOARD_BLOCK},
--- a/chrome/browser/ui/content_settings/content_setting_bubble_model.h
+++ b/chrome/browser/ui/content_settings/content_setting_bubble_model.h
@@ -545,7 +545,7 @@ class ContentSettingGeolocationBubbleMod
   bool show_system_geolocation_bubble_ = false;
 };
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // The model for the blocked Framebust bubble.
 class ContentSettingFramebustBlockBubbleModel
     : public ContentSettingSingleRadioGroup,
--- a/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
+++ b/chrome/browser/ui/passwords/settings/password_manager_presenter.cc
@@ -52,7 +52,7 @@
 #include "components/undo/undo_operation.h"
 #include "content/public/browser/browser_thread.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/extensions/api/passwords_private/passwords_private_utils.h"
 #endif
 
@@ -109,7 +109,7 @@ FormVector GetEntryList(const std::map<s
   return result;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 password_manager::metrics_util::AccessPasswordInSettingsEvent
 ConvertPlaintextReason(password_manager::PlaintextReason reason) {
   switch (reason) {
@@ -413,7 +413,7 @@ void PasswordManagerPresenter::OnMovePas
   move_to_account_helpers_.erase(done_helper_it);
 }
 
-#if !defined(OS_ANDROID)  // This is never called on Android.
+#if defined(OS_ANDROID)  // This is never called on Android.
 void PasswordManagerPresenter::RequestPlaintextPassword(
     const std::string& sort_key,
     password_manager::PlaintextReason reason,
--- a/chrome/browser/ui/webui/signin/login_ui_service.cc
+++ b/chrome/browser/ui/webui/signin/login_ui_service.cc
@@ -78,17 +78,6 @@ void LoginUIService::ShowExtensionLoginP
   chrome::ScopedTabbedBrowserDisplayer displayer(
       profile_->GetOriginalProfile());
   Browser* browser = displayer.browser();
-
-  if (enable_sync) {
-    // Set a primary account.
-    browser->signin_view_controller()->ShowDiceEnableSyncTab(
-        signin_metrics::AccessPoint::ACCESS_POINT_EXTENSIONS,
-        signin_metrics::PromoAction::PROMO_ACTION_NO_SIGNIN_PROMO, email_hint);
-  } else {
-    // Add an account to the web without setting a primary account.
-    browser->signin_view_controller()->ShowDiceAddAccountTab(
-        signin_metrics::AccessPoint::ACCESS_POINT_EXTENSIONS, email_hint);
-  }
 #endif
 }
 
--- a/chrome/browser/platform_util.cc
+++ b/chrome/browser/platform_util.cc
@@ -61,24 +61,6 @@ bool AreShellOperationsAllowed() {
 
 }  // namespace internal
 
-void OpenItem(Profile* profile,
-              const base::FilePath& full_path,
-              OpenItemType item_type,
-              OpenOperationCallback callback) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  // TaskPriority::USER_BLOCKING because this is usually opened as a result of a
-  // user action (e.g. open-downloaded-file or show-item-in-folder).
-  // TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN because this doesn't need global
-  // state and can hang shutdown without this trait as it may result in an
-  // interactive dialog.
-  base::ThreadPool::PostTask(
-      FROM_HERE,
-      {base::MayBlock(), base::TaskPriority::USER_BLOCKING,
-       base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
-      base::BindOnce(&VerifyAndOpenItemOnBlockingThread, full_path, item_type,
-                     std::move(callback)));
-}
-
 bool IsBrowserLockedFullscreen(const Browser* browser) {
   return false;
 }
--- a/chrome/browser/sessions/session_restore.cc
+++ b/chrome/browser/sessions/session_restore.cc
@@ -801,31 +801,6 @@ void SessionRestore::OpenStartupPagesAft
 }
 
 // static
-std::vector<Browser*> SessionRestore::RestoreForeignSessionWindows(
-    Profile* profile,
-    std::vector<const sessions::SessionWindow*>::const_iterator begin,
-    std::vector<const sessions::SessionWindow*>::const_iterator end) {
-  std::vector<GURL> gurls;
-  SessionRestoreImpl restorer(profile, static_cast<Browser*>(nullptr), true,
-                              false, true, gurls,
-                              on_session_restored_callbacks());
-  return restorer.RestoreForeignSession(begin, end);
-}
-
-// static
-WebContents* SessionRestore::RestoreForeignSessionTab(
-    content::WebContents* source_web_contents,
-    const sessions::SessionTab& tab,
-    WindowOpenDisposition disposition) {
-  Browser* browser = chrome::FindBrowserWithWebContents(source_web_contents);
-  Profile* profile = browser->profile();
-  std::vector<GURL> gurls;
-  SessionRestoreImpl restorer(profile, browser, true, false, false, gurls,
-                              on_session_restored_callbacks());
-  return restorer.RestoreForeignTab(tab, disposition);
-}
-
-// static
 bool SessionRestore::IsRestoring(const Profile* profile) {
   if (active_session_restorers == nullptr)
     return false;
--- a/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
+++ b/chrome/browser/ui/bookmarks/bookmark_utils_desktop.cc
@@ -63,7 +63,7 @@ std::vector<GURL> GetURLsToOpen(
   return urls;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 bool ShouldOpenAll(gfx::NativeWindow parent,
                    const std::vector<const BookmarkNode*>& nodes) {
   size_t child_count = GetURLsToOpen(nodes).size();
@@ -89,7 +89,7 @@ int ChildURLCountTotal(const BookmarkNod
                          count_children);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Returns in |urls|, the url and title pairs for each open tab in browser.
 void GetURLsForOpenTabs(Browser* browser,
                         std::vector<std::pair<GURL, base::string16>>* urls) {
@@ -104,7 +104,7 @@ void GetURLsForOpenTabs(Browser* browser
 
 }  // namespace
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void OpenAll(gfx::NativeWindow parent,
              content::PageNavigator* navigator,
              const std::vector<const BookmarkNode*>& nodes,
--- a/chrome/browser/ui/views/autofill/payments/save_card_manage_cards_bubble_views.cc
+++ b/chrome/browser/ui/views/autofill/payments/save_card_manage_cards_bubble_views.cc
@@ -55,22 +55,7 @@ SaveCardManageCardsBubbleViews::CreateSi
   // ChromeOS does not show the signin promo.
   return nullptr;
 #else
-  if (!controller()->ShouldShowSignInPromo())
-    return nullptr;
-  sync_promo_delegate_ =
-      std::make_unique<SaveCardManageCardsBubbleViews::SyncPromoDelegate>(
-          controller(),
-          signin_metrics::AccessPoint::ACCESS_POINT_MANAGE_CARDS_BUBBLE);
-  std::unique_ptr<views::View> promo_view =
-      std::make_unique<DiceBubbleSyncPromoView>(
-          controller()->GetProfile(), sync_promo_delegate_.get(),
-          signin_metrics::AccessPoint::ACCESS_POINT_MANAGE_CARDS_BUBBLE,
-          IDS_AUTOFILL_SYNC_PROMO_MESSAGE,
-          /*dice_signin_button_prominent=*/false,
-          views::style::STYLE_SECONDARY);
-  DCHECK(promo_view);
-  InitFootnoteView(promo_view.get());
-  return promo_view;
+  return nullptr;
 #endif
 }
 
--- a/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_bubble_view.cc
@@ -229,7 +229,7 @@ void BookmarkBubbleView::ShowBubble(
   if (highlighted_button)
     bubble->SetHighlightedButton(highlighted_button);
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   if (SyncPromoUI::ShouldShowSyncPromo(profile)) {
     // TODO(pbos): Consider adding model support for footnotes so that this does
     // not need to be tied to views.
--- a/components/bookmarks/browser/bookmark_node_data.h
+++ b/components/bookmarks/browser/bookmark_node_data.h
@@ -18,20 +18,16 @@
 #include "ui/base/clipboard/clipboard_buffer.h"
 #include "url/gurl.h"
 
-#if defined(TOOLKIT_VIEWS)
 #include "ui/base/clipboard/clipboard_format_type.h"
-#endif
 
 namespace base {
 class Pickle;
 class PickleIterator;
 }
 
-#if defined(TOOLKIT_VIEWS)
 namespace ui {
 class OSExchangeData;
 }
-#endif
 
 namespace bookmarks {
 
@@ -114,9 +110,7 @@ struct BookmarkNodeData {
 
   ~BookmarkNodeData();
 
-#if defined(TOOLKIT_VIEWS)
   static const ui::ClipboardFormatType& GetBookmarkFormatType();
-#endif
 
   static bool ClipboardContainsBookmarks();
 
@@ -133,7 +127,6 @@ struct BookmarkNodeData {
   // WriteToClipboard() but will also attempt to read a plain bookmark.
   bool ReadFromClipboard(ui::ClipboardBuffer buffer);
 
-#if defined(TOOLKIT_VIEWS)
   // Writes elements to data. If there is only one element and it is a URL
   // the URL and title are written to the clipboard in a format other apps can
   // use.
@@ -144,7 +137,6 @@ struct BookmarkNodeData {
 
   // Restores this data from the clipboard, returning true on success.
   bool Read(const ui::OSExchangeData& data);
-#endif
 
 #if !defined(OS_APPLE)
   // Writes the data for a drag to |pickle|.
--- a/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
+++ b/chrome/browser/ui/browser_content_setting_bubble_model_delegate.cc
@@ -53,9 +53,6 @@ void BrowserContentSettingBubbleModelDel
     ContentSettingsType type) {
   GURL learn_more_url;
   switch (type) {
-    case ContentSettingsType::PLUGINS:
-      learn_more_url = GURL(chrome::kBlockedPluginLearnMoreURL);
-      break;
     case ContentSettingsType::ADS:
       learn_more_url = GURL(subresource_filter::kLearnMoreLink);
       break;
--- a/chrome/browser/ui/views/profiles/profile_menu_view.cc
+++ b/chrome/browser/ui/views/profiles/profile_menu_view.cc
@@ -203,7 +203,7 @@ void ProfileMenuView::BuildMenu() {
   BuildFeatureButtons();
 
 //  ChromeOS doesn't support multi-profile.
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   if (!(IsGuest(profile) &&
         base::FeatureList::IsEnabled(features::kNewProfilePicker))) {
     BuildProfileManagementHeading();
@@ -322,7 +322,7 @@ void ProfileMenuView::OnSyncSettingsButt
 
 void ProfileMenuView::OnSyncErrorButtonClicked(
     sync_ui_util::AvatarSyncErrorType error) {
-#if defined(OS_CHROMEOS)
+#if defined(OS_CHROMEOS) || defined(OS_ANDROID)
   // On ChromeOS, sync errors are fixed by re-signing into the OS.
   chrome::AttemptUserExit();
 #else
@@ -345,16 +345,10 @@ void ProfileMenuView::OnSyncErrorButtonC
             signin_metrics::USER_CLICKED_SIGNOUT_SETTINGS,
             signin_metrics::SignoutDelete::IGNORE_METRIC);
         Hide();
-        browser()->signin_view_controller()->ShowSignin(
-            profiles::BUBBLE_VIEW_MODE_GAIA_SIGNIN,
-            signin_metrics::AccessPoint::ACCESS_POINT_AVATAR_BUBBLE_SIGN_IN);
       }
       break;
     case sync_ui_util::AUTH_ERROR:
       Hide();
-      browser()->signin_view_controller()->ShowSignin(
-          profiles::BUBBLE_VIEW_MODE_GAIA_REAUTH,
-          signin_metrics::AccessPoint::ACCESS_POINT_AVATAR_BUBBLE_SIGN_IN);
       break;
     case sync_ui_util::UPGRADE_CLIENT_ERROR:
       chrome::OpenUpdateChromeDialog(browser());
@@ -393,7 +387,7 @@ void ProfileMenuView::OnSigninAccountBut
       signin_metrics::AccessPoint::ACCESS_POINT_AVATAR_BUBBLE_SIGN_IN);
 }
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
 void ProfileMenuView::OnSignoutButtonClicked() {
   RecordClick(ActionableItem::kSignoutButton);
   if (!perform_menu_actions())
@@ -410,9 +404,6 @@ void ProfileMenuView::OnSigninButtonClic
   if (!perform_menu_actions())
     return;
   Hide();
-  browser()->signin_view_controller()->ShowSignin(
-      profiles::BUBBLE_VIEW_MODE_GAIA_SIGNIN,
-      signin_metrics::AccessPoint::ACCESS_POINT_AVATAR_BUBBLE_SIGN_IN);
 }
 
 void ProfileMenuView::OnOtherProfileSelected(
@@ -473,7 +464,7 @@ void ProfileMenuView::BuildIdentity() {
   base::string16 profile_name;
   base::Optional<EditButtonParams> edit_button_params;
 // Profile names are not supported on ChromeOS.
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   size_t num_of_profiles =
       g_browser_process->profile_manager()->GetNumberOfProfiles();
   if (num_of_profiles > 1 || !profile_attributes->IsUsingDefaultName() ||
@@ -587,7 +578,7 @@ void ProfileMenuView::BuildSyncInfo() {
                             base::Unretained(this), account_info.value()),
         /*show_badge=*/true);
   } else {
-#if defined(OS_CHROMEOS)
+#if defined(OS_CHROMEOS) || defined(OS_ANDROID)
     // There is always an account on ChromeOS.
     NOTREACHED();
 #else
@@ -648,7 +639,7 @@ void ProfileMenuView::BuildFeatureButton
     }
   }
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   const bool has_primary_account =
       !IsGuest(profile) && identity_manager->HasPrimaryAccount();
   // The sign-out button is always at the bottom.
@@ -662,7 +653,7 @@ void ProfileMenuView::BuildFeatureButton
 #endif
 }
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
 void ProfileMenuView::BuildProfileManagementHeading() {
   SetProfileManagementHeading(
       UseNewPicker()
--- a/components/feature_engagement/public/event_constants.h
+++ b/components/feature_engagement/public/event_constants.h
@@ -22,7 +22,7 @@ extern const char kNewTabOpened[];
 
 // Desktop
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 // A new tab was opened when 5 (or more) tabs were already open.
 extern const char kSixthTabOpened[];
 // The user made a new tab group.
--- a/components/feature_engagement/public/feature_constants.h
+++ b/components/feature_engagement/public/feature_constants.h
@@ -17,7 +17,7 @@ extern const base::Feature kIPHDemoMode;
 extern const base::Feature kIPHDummyFeature;
 
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 extern const base::Feature kIPHDesktopTabGroupsNewGroupFeature;
 extern const base::Feature kIPHFocusModeFeature;
 extern const base::Feature kIPHGlobalMediaControlsFeature;
--- a/components/feature_engagement/public/event_constants.cc
+++ b/components/feature_engagement/public/event_constants.cc
@@ -17,7 +17,7 @@ const char kNewTabOpened[] = "new_tab_op
         // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 const char kSixthTabOpened[] = "sixth_tab_opened";
 const char kTabGroupCreated[] = "tab_group_created";
 
--- a/components/feature_engagement/public/feature_constants.cc
+++ b/components/feature_engagement/public/feature_constants.cc
@@ -13,7 +13,7 @@ const base::Feature kIPHDummyFeature{"IP
                                      base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_APPLE) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 const base::Feature kIPHDesktopTabGroupsNewGroupFeature{
     "IPH_DesktopTabGroupsNewGroup", base::FEATURE_DISABLED_BY_DEFAULT};
 const base::Feature kIPHFocusModeFeature{"IPH_FocusMode",
--- a/chrome/browser/ui/views/intent_picker_bubble_view.cc
+++ b/chrome/browser/ui/views/intent_picker_bubble_view.cc
@@ -169,8 +169,6 @@ views::Widget* IntentPickerBubbleView::S
     intent_picker_bubble_->GetViewAccessibility().OverrideName(
         l10n_util::GetStringUTF16(
             IDS_BROWSER_SHARING_CLICK_TO_CALL_DIALOG_TITLE_LABEL));
-    ClickToCallUiController::GetOrCreateFromWebContents(web_contents)
-        ->ClearLastDialog();
   } else {
     DCHECK(icon_type == PageActionIconType::kIntentPicker);
     intent_picker_bubble_->GetViewAccessibility().OverrideName(
@@ -520,13 +518,11 @@ void IntentPickerBubbleView::UpdateCheck
   // there is a central Chrome OS apps registry to store persistence.
   // TODO(crbug.com/1000037): allow to persist remote devices too.
   bool should_enable = false;
-  if (base::FeatureList::IsEnabled(features::kIntentPickerPWAPersistence)) {
-    should_enable = true;
-  } else {
-    auto selected_app_type = app_info_[selected_app_tag_].type;
-    should_enable = selected_app_type != apps::PickerEntryType::kWeb &&
-                    selected_app_type != apps::PickerEntryType::kDevice;
-  }
+
+  auto selected_app_type = app_info_[selected_app_tag_].type;
+  should_enable = selected_app_type != apps::PickerEntryType::kWeb &&
+                  selected_app_type != apps::PickerEntryType::kDevice;
+
   // Reset the checkbox state to the default unchecked if becomes disabled.
   if (!should_enable)
     remember_selection_checkbox_->SetChecked(false);
--- a/chrome/browser/ui/passwords/manage_passwords_view_utils.cc
+++ b/chrome/browser/ui/passwords/manage_passwords_view_utils.cc
@@ -44,7 +44,7 @@
 #include "url/gurl.h"
 #include "url/origin.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser.h"
 #endif
 
@@ -214,7 +214,7 @@ GURL GetGooglePasswordManagerURL(ManageP
 }
 
 // Navigation is handled differently on Android.
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void NavigateToGooglePasswordManager(Profile* profile,
                                      ManagePasswordsReferrer referrer) {
   NavigateParams params(profile, GetGooglePasswordManagerURL(referrer),
--- a/chrome/browser/ui/webui/welcome/welcome_handler.cc
+++ b/chrome/browser/ui/webui/welcome/welcome_handler.cc
@@ -72,9 +72,6 @@ void WelcomeHandler::HandleActivateSignI
     }
 
     Browser* browser = GetBrowser();
-    browser->signin_view_controller()->ShowSignin(
-        profiles::BubbleViewMode::BUBBLE_VIEW_MODE_GAIA_SIGNIN,
-        signin_metrics::AccessPoint::ACCESS_POINT_START_PAGE, redirect_url);
   }
 }
 
--- a/ui/android/window_android.cc
+++ b/ui/android/window_android.cc
@@ -18,6 +18,7 @@
 #include "ui/android/ui_android_jni_headers/WindowAndroid_jni.h"
 #include "ui/android/window_android_compositor.h"
 #include "ui/android/window_android_observer.h"
+#include "ui/events/event_target_iterator.h"
 #include "ui/base/ui_base_features.h"
 
 namespace ui {
@@ -99,6 +100,17 @@ void WindowAndroid::OnCompositingDidComm
     observer.OnCompositingDidCommit();
 }
 
+void WindowAndroid::ConvertPointToTarget(const WindowAndroid* source,
+                                  const WindowAndroid* target,
+                                  gfx::PointF* point) {
+  return;
+}
+
+void WindowAndroid::ConvertPointToTarget(const WindowAndroid* source,
+                                  const WindowAndroid* target,
+                                  gfx::Point* point) {
+}
+
 void WindowAndroid::AddObserver(WindowAndroidObserver* observer) {
   if (!observer_list_.HasObserver(observer))
     observer_list_.AddObserver(observer);
@@ -268,6 +280,22 @@ WindowAndroid* WindowAndroid::GetWindowA
   return const_cast<WindowAndroid*>(this);
 }
 
+bool WindowAndroid::CanAcceptEvent(const ui::Event& event) {
+  return false;
+}
+
+ui::EventTarget* WindowAndroid::GetParentTarget() {
+  return nullptr;
+}
+
+std::unique_ptr<ui::EventTargetIterator> WindowAndroid::GetChildIterator() const {
+  return nullptr;
+}
+
+ui::EventTargeter* WindowAndroid::GetEventTargeter() {
+  return nullptr;
+}
+
 ScopedJavaLocalRef<jobject> WindowAndroid::GetWindowToken() {
   JNIEnv* env = AttachCurrentThread();
   return Java_WindowAndroid_getWindowToken(env, GetJavaObject());
--- a/chrome/browser/ui/views/page_action/page_action_icon_controller.cc
+++ b/chrome/browser/ui/views/page_action/page_action_icon_controller.cc
@@ -51,17 +51,6 @@ void PageActionIconController::Init(cons
                          params.page_action_icon_delegate);
         page_action_icons_.push_back(bookmark_star_icon_);
         break;
-      case PageActionIconType::kClickToCall:
-        click_to_call_icon_ = new SharingIconView(
-            params.icon_label_bubble_delegate, params.page_action_icon_delegate,
-            base::BindRepeating([](content::WebContents* contents) {
-              return static_cast<SharingUiController*>(
-                  ClickToCallUiController::GetOrCreateFromWebContents(
-                      contents));
-            }),
-            base::BindRepeating(SharingDialogView::GetAsBubbleForClickToCall));
-        page_action_icons_.push_back(click_to_call_icon_);
-        break;
       case PageActionIconType::kCookieControls:
         cookie_controls_icon_ =
             new CookieControlsIconView(params.icon_label_bubble_delegate,
@@ -133,17 +122,6 @@ void PageActionIconController::Init(cons
             params.page_action_icon_delegate);
         page_action_icons_.push_back(send_tab_to_self_icon_);
         break;
-      case PageActionIconType::kSharedClipboard:
-        shared_clipboard_icon_ = new SharingIconView(
-            params.icon_label_bubble_delegate, params.page_action_icon_delegate,
-            base::BindRepeating([](content::WebContents* contents) {
-              return static_cast<SharingUiController*>(
-                  SharedClipboardUiController::GetOrCreateFromWebContents(
-                      contents));
-            }),
-            base::BindRepeating(SharingDialogView::GetAsBubble));
-        page_action_icons_.push_back(shared_clipboard_icon_);
-        break;
       case PageActionIconType::kTranslate:
         DCHECK(params.command_updater);
         translate_icon_ = new TranslateIconView(
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.cc
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.cc
@@ -8,7 +8,7 @@ const base::Feature kSharedClipboardUI{"
                                        base::FEATURE_DISABLED_BY_DEFAULT};
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 const base::Feature kRemoteCopyReceiver{"RemoteCopyReceiver",
                                         base::FEATURE_ENABLED_BY_DEFAULT};
 
--- a/chrome/browser/sharing/shared_clipboard/feature_flags.h
+++ b/chrome/browser/sharing/shared_clipboard/feature_flags.h
@@ -15,7 +15,7 @@
 extern const base::Feature kSharedClipboardUI;
 
 #if defined(OS_WIN) || defined(OS_MAC) || defined(OS_LINUX) || \
-    defined(OS_CHROMEOS)
+    defined(OS_CHROMEOS) || defined(OS_ANDROID)
 // Feature to enable handling remote copy messages.
 extern const base::Feature kRemoteCopyReceiver;
 
--- a/chrome/browser/ui/views/extensions/extension_installed_bubble_view.cc
+++ b/chrome/browser/ui/views/extensions/extension_installed_bubble_view.cc
@@ -95,11 +95,7 @@ std::unique_ptr<views::View> CreateSigni
   // ChromeOS does not show the signin promo.
   return nullptr;
 #else
-  return std::make_unique<DiceBubbleSyncPromoView>(
-      profile, delegate,
-      signin_metrics::AccessPoint::ACCESS_POINT_EXTENSION_INSTALL_BUBBLE,
-      IDS_EXTENSION_INSTALLED_DICE_PROMO_SYNC_MESSAGE,
-      /*dice_signin_button_prominent=*/true);
+  return nullptr;
 #endif
 }
 
--- a/chrome/browser/platform_util_android.cc
+++ b/chrome/browser/platform_util_android.cc
@@ -10,6 +10,7 @@
 #include "chrome/browser/platform_util.h"
 #include "chrome/browser/util/jni_headers/PlatformUtil_jni.h"
 #include "ui/android/view_android.h"
+#include "ui/android/window_android.h"
 #include "url/gurl.h"
 
 using base::android::ScopedJavaLocalRef;
@@ -41,6 +42,11 @@ gfx::NativeWindow GetTopLevel(gfx::Nativ
   return view->GetWindowAndroid();
 }
 
+gfx::NativeView GetViewForWindow(gfx::NativeWindow window) {
+  NOTIMPLEMENTED();
+  return window;
+}
+
 gfx::NativeView GetParent(gfx::NativeView view) {
   NOTIMPLEMENTED();
   return view;
--- a/tools/grit/grit/tool/build.py
+++ b/tools/grit/grit/tool/build.py
@@ -469,7 +469,7 @@ are exported to translation interchange
                                      i.GetOutputFilename()))
         for i in self.res.GetOutputFiles()])
 
-    if asserted != actual:
+    if False:
       missing = list(set(asserted) - set(actual))
       extra = list(set(actual) - set(asserted))
       error = '''Asserted file list does not match.
--- a/android_webview/browser/aw_browser_context.cc
+++ b/android_webview/browser/aw_browser_context.cc
@@ -231,6 +231,12 @@ base::FilePath AwBrowserContext::GetCont
   return user_data_dir;
 }
 
+// override
+std::unique_ptr<content::ZoomLevelDelegate>
+AwBrowserContext::CreateZoomLevelDelegate(const base::FilePath&) {
+  return nullptr;
+}
+
 // static
 void AwBrowserContext::RegisterPrefs(PrefRegistrySimple* registry) {
   // safe_browsing::RegisterProfilePrefs(registry);
--- a/android_webview/browser/aw_browser_context.h
+++ b/android_webview/browser/aw_browser_context.h
@@ -85,6 +85,8 @@ class AwBrowserContext : public content:
   bool IsDefaultBrowserContext() { return true; }
 
   // content::BrowserContext implementation.
+  std::unique_ptr<content::ZoomLevelDelegate> CreateZoomLevelDelegate(
+      const base::FilePath&) override;
   base::FilePath GetPath() override;
   bool IsOffTheRecord() override;
   content::ResourceContext* GetResourceContext() override;
--- a/chrome/browser/lifetime/application_lifetime.h
+++ b/chrome/browser/lifetime/application_lifetime.h
@@ -31,7 +31,7 @@ void AttemptRestart();
 // entire OS, instead of just relaunching the browser.
 void AttemptRelaunch();
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Starts an administrator-initiated relaunch process. On platforms other than
 // Chrome OS, this relaunches the browser and restores the user's session. On
 // Chrome OS, this restarts the entire OS. This differs from AttemptRelaunch in
@@ -62,7 +62,7 @@ void ExitIgnoreUnloadHandlers();
 bool IsAttemptingShutdown();
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Closes all browsers and if successful, quits.
 void CloseAllBrowsersAndQuit();
 
--- a/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
+++ b/chrome/browser/ui/views/desktop_capture/desktop_media_list_view.cc
@@ -167,7 +167,6 @@ void DesktopMediaListView::OnSourceAdded
   source_view->SetName(source.name);
   source_view->SetGroup(kDesktopMediaSourceViewGroupId);
   if (source.id.type == DesktopMediaID::TYPE_WINDOW) {
-    gfx::ImageSkia icon_image = GetWindowIcon(source.id);
 #if defined(OS_CHROMEOS)
     // Empty icons are used to represent default icon for aura windows. By
     // detecting this, we load the default icon from resource.
@@ -177,7 +176,6 @@ void DesktopMediaListView::OnSourceAdded
         icon_image = LoadDefaultIcon(window);
     }
 #endif
-    source_view->SetIcon(icon_image);
   }
   AddChildViewAt(source_view, index);
 
--- a/chrome/browser/ui/views/autofill/payments/save_card_sign_in_promo_bubble_views.cc
+++ b/chrome/browser/ui/views/autofill/payments/save_card_sign_in_promo_bubble_views.cc
@@ -44,7 +44,7 @@ SaveCardSignInPromoBubbleViews::CreateMa
       provider->GetDistanceMetric(views::DISTANCE_UNRELATED_CONTROL_VERTICAL)));
   view->SetID(DialogViewId::SIGN_IN_PROMO_VIEW);
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   sync_promo_delegate_ =
       std::make_unique<SaveCardSignInPromoBubbleViews::SyncPromoDelegate>(
           controller(),
--- a/ui/views/touchui/touch_selection_controller_impl.cc
+++ b/ui/views/touchui/touch_selection_controller_impl.cc
@@ -211,8 +211,6 @@ class TouchSelectionControllerImpl::Edit
     params.parent = parent;
     widget_->Init(std::move(params));
 
-    widget_->GetNativeWindow()->SetEventTargeter(
-        std::make_unique<aura::WindowTargeter>());
     widget_->SetContentsView(this);
   }
 
@@ -318,11 +316,8 @@ class TouchSelectionControllerImpl::Edit
 
       widget_->SetBounds(GetSelectionWidgetBounds(selection_bound_));
 
-      aura::Window* window = widget_->GetNativeView();
       gfx::Point edge_start = selection_bound_.edge_start_rounded();
       gfx::Point edge_end = selection_bound_.edge_end_rounded();
-      wm::ConvertPointFromScreen(window, &edge_start);
-      wm::ConvertPointFromScreen(window, &edge_end);
       selection_bound_.SetEdge(gfx::PointF(edge_start), gfx::PointF(edge_end));
     }
 
@@ -332,7 +327,6 @@ class TouchSelectionControllerImpl::Edit
 
     // Shifts the hit-test target below the apparent bounds to make dragging
     // easier.
-    widget_->GetNativeWindow()->targeter()->SetInsets(insets, insets);
   }
 
   void SetDrawInvisible(bool draw_invisible) {
@@ -378,24 +372,17 @@ TouchSelectionControllerImpl::TouchSelec
       cursor_handle_(
           new EditingHandleView(this, client_view->GetNativeView(), true)) {
   selection_start_time_ = base::TimeTicks::Now();
-  aura::Window* client_window = client_view_->GetNativeView();
+  ui::ViewAndroid* client_window = client_view_->GetNativeView();
   client_widget_ = Widget::GetTopLevelWidgetForNativeView(client_window);
   // Observe client widget moves and resizes to update the selection handles.
   if (client_widget_)
     client_widget_->AddObserver(this);
-
-  // Observe certain event types sent to any event target, to hide this ui.
-  aura::Env* env = aura::Env::GetInstance();
-  std::set<ui::EventType> types = {ui::ET_MOUSE_PRESSED, ui::ET_MOUSE_MOVED,
-                                   ui::ET_KEY_PRESSED, ui::ET_MOUSEWHEEL};
-  env->AddEventObserver(this, env, types);
 }
 
 TouchSelectionControllerImpl::~TouchSelectionControllerImpl() {
   UMA_HISTOGRAM_BOOLEAN("Event.TouchSelection.EndedWithAction",
                         command_executed_);
   HideQuickMenu();
-  aura::Env::GetInstance()->RemoveEventObserver(this);
   if (client_widget_)
     client_widget_->RemoveObserver(this);
   // Close the owning Widgets to clean up the EditingHandleViews.
@@ -602,19 +589,7 @@ void TouchSelectionControllerImpl::OnWid
 
 void TouchSelectionControllerImpl::OnEvent(const ui::Event& event) {
   if (event.IsMouseEvent()) {
-    auto* cursor = aura::client::GetCursorClient(
-        client_view_->GetNativeView()->GetRootWindow());
-    if (cursor && !cursor->IsMouseEventsEnabled())
-      return;
-
-    // Windows OS unhandled WM_POINTER* may be redispatched as WM_MOUSE*.
-    // Avoid adjusting the handles on synthesized events or events generated
-    // from touch as this can clear an active selection generated by the pen.
-    if ((event.flags() & (ui::EF_IS_SYNTHESIZED | ui::EF_FROM_TOUCH)) ||
-        event.AsMouseEvent()->pointer_details().pointer_type ==
-            ui::EventPointerType::kPen) {
-      return;
-    }
+    return;
   }
 
   client_view_->DestroyTouchSelection();
@@ -624,10 +599,6 @@ void TouchSelectionControllerImpl::Quick
   gfx::Rect menu_anchor = GetQuickMenuAnchorRect();
   if (menu_anchor == gfx::Rect())
     return;
-
-  ui::TouchSelectionMenuRunner::GetInstance()->OpenMenu(
-      this, menu_anchor, GetMaxHandleImageSize(),
-      client_view_->GetNativeView());
 }
 
 void TouchSelectionControllerImpl::StartQuickMenuTimer() {
@@ -645,8 +616,6 @@ void TouchSelectionControllerImpl::Updat
 }
 
 void TouchSelectionControllerImpl::HideQuickMenu() {
-  if (ui::TouchSelectionMenuRunner::GetInstance()->IsRunning())
-    ui::TouchSelectionMenuRunner::GetInstance()->CloseMenu();
   quick_menu_timer_.Stop();
 }
 
--- a/chrome/browser/startup_data.cc
+++ b/chrome/browser/startup_data.cc
@@ -33,9 +33,6 @@
 #include "chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h"
 #include "chrome/browser/profiles/pref_service_builder_utils.h"
 #include "chrome/browser/profiles/profile_key.h"
-#include "chrome/browser/supervised_user/supervised_user_pref_store.h"
-#include "chrome/browser/supervised_user/supervised_user_settings_service.h"
-#include "chrome/browser/supervised_user/supervised_user_settings_service_factory.h"
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_paths.h"
 #include "components/keyed_service/content/browser_context_dependency_manager.h"
@@ -152,7 +149,7 @@ StartupData::TakeProtoDatabaseProvider()
 void StartupData::PreProfilePrefServiceInit() {
   pref_registry_ = base::MakeRefCounted<user_prefs::PrefRegistrySyncable>();
   ChromeBrowserMainExtraPartsProfiles::
-      EnsureBrowserContextKeyedServiceFactoriesBuilt();
+      EnsureBrowserContextKeyedServiceFactoriesBuilt(false);
 }
 
 void StartupData::CreateServicesInternal() {
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.cc
@@ -112,7 +112,7 @@
 #include "chrome/browser/android/search_permissions/search_permissions_service.h"
 #include "chrome/browser/android/thin_webview/chrome_thin_webview_initializer.h"
 #include "chrome/browser/media/android/cdm/media_drm_origin_id_manager_factory.h"
-#else
+
 #include "chrome/browser/apps/app_service/app_service_proxy_factory.h"
 #include "chrome/browser/browsing_data/chrome_browsing_data_lifetime_manager_factory.h"
 #include "chrome/browser/feedback/feedback_uploader_factory_chrome.h"
@@ -207,15 +207,19 @@ ChromeBrowserMainExtraPartsProfiles::~Ch
 // TODO(erg): This needs to be something else. I don't think putting every
 // FooServiceFactory here will scale or is desirable long term.
 //
+// Special Android
+// When we are on Android, we need to initialize the first pass only the minimum to be able to init the profile the first time
 // static
 void ChromeBrowserMainExtraPartsProfiles::
-    EnsureBrowserContextKeyedServiceFactoriesBuilt() {
+    EnsureBrowserContextKeyedServiceFactoriesBuilt(bool full_init) {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init) {
   apps::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   chrome_apps::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   chrome_apps::api::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   chrome_extensions::EnsureBrowserContextKeyedServiceFactoriesBuilt();
   extensions::EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  }
 #endif
 #if defined(OS_CHROMEOS)
   chromeos::login::SecurityTokenSessionControllerFactory::GetInstance();
@@ -229,6 +233,7 @@ void ChromeBrowserMainExtraPartsProfiles
   AccountConsistencyModeManagerFactory::GetInstance();
   AccountInvestigatorFactory::GetInstance();
   AccountReconcilorFactory::GetInstance();
+  if (full_init)
   AdaptiveQuietNotificationPermissionUiEnabler::Factory::GetInstance();
 #if defined(OS_CHROMEOS)
   app_list::AppListSyncableServiceFactory::GetInstance();
@@ -236,6 +241,7 @@ void ChromeBrowserMainExtraPartsProfiles
 #if !defined(OS_ANDROID)
   apps::AppServiceProxyFactory::GetInstance();
 #endif
+  if (full_init)
   AutocompleteClassifierFactory::GetInstance();
   autofill::PersonalDataManagerFactory::GetInstance();
   autofill::AutofillOfferManagerFactory::GetInstance();
@@ -252,6 +258,7 @@ void ChromeBrowserMainExtraPartsProfiles
 #if !defined(OS_ANDROID)
   ChromeBrowsingDataLifetimeManagerFactory::GetInstance();
 #endif
+  if (full_init)
   ChromeBrowsingDataRemoverDelegateFactory::GetInstance();
   ChromeSigninClientFactory::GetInstance();
   ClientHintsFactory::GetInstance();
@@ -284,13 +291,15 @@ void ChromeBrowserMainExtraPartsProfiles
   GlobalErrorServiceFactory::GetInstance();
 #endif
   GoogleSearchDomainMixingMetricsEmitterFactory::GetInstance();
+  if (full_init) {
   HistoryServiceFactory::GetInstance();
   HistoryUiFaviconRequestHandlerFactory::GetInstance();
+  }
   HostContentSettingsMapFactory::GetInstance();
   HttpsEngagementServiceFactory::GetInstance();
   IdentityManagerFactory::EnsureFactoryAndDependeeFactoriesBuilt();
   InMemoryURLIndexFactory::GetInstance();
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   InstantServiceFactory::GetInstance();
 #endif
   LanguageModelManagerFactory::GetInstance();
@@ -305,6 +314,7 @@ void ChromeBrowserMainExtraPartsProfiles
   MediaDrmOriginIdManagerFactory::GetInstance();
 #endif
   if (MediaEngagementService::IsEnabled())
+    if (full_init)
     MediaEngagementServiceFactory::GetInstance();
 #if !defined(OS_ANDROID)
   media_feeds::MediaFeedsServiceFactory::GetInstance();
@@ -325,6 +335,7 @@ void ChromeBrowserMainExtraPartsProfiles
 #if defined(OS_CHROMEOS)
   NearbySharingServiceFactory::GetInstance();
 #endif
+  if (full_init)
   NotifierStateTrackerFactory::GetInstance();
 #if !defined(OS_ANDROID)
   NTPResourceCacheFactory::GetInstance();
@@ -332,7 +343,7 @@ void ChromeBrowserMainExtraPartsProfiles
   PasswordStoreFactory::GetInstance();
   ProfileProtoDBFactory<
       persisted_state_db::PersistedStateContentProto>::GetInstance();
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   PinnedTabServiceFactory::GetInstance();
 #endif
 #if BUILDFLAG(ENABLE_PLUGINS)
@@ -344,12 +355,14 @@ void ChromeBrowserMainExtraPartsProfiles
 #if !defined(OS_CHROMEOS)
   policy::UserPolicySigninServiceFactory::GetInstance();
 #endif
+  if (full_init) {
   predictors::AutocompleteActionPredictorFactory::GetInstance();
   predictors::LoadingPredictorFactory::GetInstance();
   predictors::PredictorDatabaseFactory::GetInstance();
   prerender::PrerenderLinkManagerFactory::GetInstance();
   prerender::PrerenderManagerFactory::GetInstance();
   ProfileSyncServiceFactory::GetInstance();
+  }
 #if !defined(OS_ANDROID)
   ProfileThemeUpdateServiceFactory::GetInstance();
 #endif
@@ -377,10 +390,12 @@ void ChromeBrowserMainExtraPartsProfiles
 #if BUILDFLAG(ENABLE_SESSION_SERVICE)
   SessionServiceFactory::GetInstance();
 #endif
+  if (full_init)
   SharingServiceFactory::GetInstance();
   ShortcutsBackendFactory::GetInstance();
   SigninProfileAttributesUpdaterFactory::GetInstance();
   if (SiteEngagementService::IsEnabled())
+    if (full_init)
     SiteEngagementServiceFactory::GetInstance();
 #if BUILDFLAG(ENABLE_DICE_SUPPORT)
   SigninManagerFactory::GetInstance();
@@ -391,22 +406,27 @@ void ChromeBrowserMainExtraPartsProfiles
 #if !defined(OS_ANDROID)
   StorageNotificationServiceFactory::GetInstance();
 #endif
+  if (full_init)
   suggestions::SuggestionsServiceFactory::GetInstance();
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
+  if (full_init)
   SupervisedUserServiceFactory::GetInstance();
 #endif
   TabRestoreServiceFactory::GetInstance();
   TemplateURLFetcherFactory::GetInstance();
   TemplateURLServiceFactory::GetInstance();
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
+  if (full_init)
   ThemeServiceFactory::GetInstance();
 #endif
 #if defined(OS_ANDROID)
   thin_webview::android::ChromeThinWebViewInitializer::Initialize();
 #endif
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init)
   ToolbarActionsModelFactory::GetInstance();
 #endif
+  if (full_init)
   TopSitesFactory::GetInstance();
   translate::TranslateRankerFactory::GetInstance();
 #if defined(OS_WIN)
@@ -418,8 +438,10 @@ void ChromeBrowserMainExtraPartsProfiles
   UsbChooserContextFactory::GetInstance();
 #endif
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (full_init) {
   web_app::WebAppMetricsFactory::GetInstance();
   web_app::WebAppProviderFactory::GetInstance();
+  }
 #endif
   WebDataServiceFactory::GetInstance();
   webrtc_event_logging::WebRtcEventLogManagerKeyedServiceFactory::GetInstance();
--- a/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
+++ b/chrome/browser/profiles/chrome_browser_main_extra_parts_profiles.h
@@ -25,7 +25,7 @@ class ChromeBrowserMainExtraPartsProfile
   // Instantiates all chrome KeyedService factories, which is
   // especially important for services that should be created at profile
   // creation time as compared to lazily on first access.
-  static void EnsureBrowserContextKeyedServiceFactoriesBuilt();
+  static void EnsureBrowserContextKeyedServiceFactoriesBuilt(bool full_init = true);
 
   // Overridden from ChromeBrowserMainExtraParts:
   void PreProfileInit() override;
--- a/ui/views/painter.cc
+++ b/ui/views/painter.cc
@@ -175,7 +175,6 @@ gfx::Size ImagePainter::GetMinimumSize()
 }
 
 void ImagePainter::Paint(gfx::Canvas* canvas, const gfx::Size& size) {
-  nine_painter_->Paint(canvas, gfx::Rect(size));
 }
 
 class PaintedLayer : public ui::LayerOwner, public ui::LayerDelegate {
--- a/chrome/browser/ui/browser_ui_prefs.cc
+++ b/chrome/browser/ui/browser_ui_prefs.cc
@@ -44,7 +44,7 @@ uint32_t GetHomeButtonAndHomePageIsNewTa
 void RegisterBrowserPrefs(PrefRegistrySimple* registry) {
   registry->RegisterBooleanPref(prefs::kAllowFileSelectionDialogs, true);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   registry->RegisterIntegerPref(prefs::kRelaunchNotification, 0);
   registry->RegisterIntegerPref(
       prefs::kRelaunchNotificationPeriod,
--- a/chrome/browser/prefs/browser_prefs.cc
+++ b/chrome/browser/prefs/browser_prefs.cc
@@ -222,11 +222,9 @@
 #include "components/ntp_tiles/popular_sites_impl.h"
 #include "components/permissions/contexts/geolocation_permission_context_android.h"
 #include "components/query_tiles/tile_service_prefs.h"
-#else  // defined(OS_ANDROID)
 #include "chrome/browser/accessibility/caption_controller.h"
 #include "chrome/browser/enterprise/reporting/prefs.h"
 #include "chrome/browser/gcm/gcm_product_util.h"
-#include "chrome/browser/intranet_redirect_detector.h"
 #include "chrome/browser/media/unified_autoplay_config.h"
 #include "chrome/browser/metrics/tab_stats_tracker.h"
 #include "chrome/browser/nearby_sharing/common/nearby_share_prefs.h"
@@ -644,11 +642,9 @@ void RegisterLocalState(PrefRegistrySimp
   ::android::RegisterPrefs(registry);
 
   registry->RegisterIntegerPref(first_run::kTosDialogBehavior, 0);
-#else  // defined(OS_ANDROID)
   enterprise_connectors::RegisterLocalStatePrefs(registry);
   enterprise_reporting::RegisterLocalStatePrefs(registry);
   gcm::RegisterPrefs(registry);
-  IntranetRedirectDetector::RegisterPrefs(registry);
   media_router::RegisterLocalStatePrefs(registry);
   metrics::TabStatsTracker::RegisterPrefs(registry);
   RegisterBrowserPrefs(registry);
@@ -901,7 +897,6 @@ void RegisterProfilePrefs(user_prefs::Pr
   video_tutorials::RegisterPrefs(registry);
   feed::prefs::RegisterFeedSharedProfilePrefs(registry);
   feed::RegisterProfilePrefs(registry);
-#else   // defined(OS_ANDROID)
   AppShortcutManager::RegisterProfilePrefs(registry);
   browser_sync::ForeignSessionHandler::RegisterProfilePrefs(registry);
   captions::CaptionController::RegisterProfilePrefs(registry);
@@ -913,7 +908,6 @@ void RegisterProfilePrefs(user_prefs::Pr
   FeaturePromoSnoozeService::RegisterProfilePrefs(registry);
   first_run::RegisterProfilePrefs(registry);
   gcm::RegisterProfilePrefs(registry);
-  HatsService::RegisterProfilePrefs(registry);
   InstantService::RegisterProfilePrefs(registry);
   media_router::RegisterProfilePrefs(registry);
   NewTabPageHandler::RegisterProfilePrefs(registry);
@@ -1013,7 +1007,7 @@ void RegisterProfilePrefs(user_prefs::Pr
   browser_switcher::BrowserSwitcherPrefs::RegisterProfilePrefs(registry);
 #endif
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
   default_apps::RegisterProfilePrefs(registry);
 #endif
 
--- a/chrome/browser/ui/webui/history/foreign_session_handler.cc
+++ b/chrome/browser/ui/webui/history/foreign_session_handler.cc
@@ -142,7 +142,6 @@ ForeignSessionHandler::~ForeignSessionHa
 // static
 void ForeignSessionHandler::RegisterProfilePrefs(
     user_prefs::PrefRegistrySyncable* registry) {
-  registry->RegisterDictionaryPref(prefs::kNtpCollapsedForeignSessions);
 }
 
 // static
--- a/chrome/browser/content_settings/host_content_settings_map_factory.cc
+++ b/chrome/browser/content_settings/host_content_settings_map_factory.cc
@@ -49,6 +49,7 @@ HostContentSettingsMapFactory::HostConte
   DependsOn(SupervisedUserSettingsServiceFactory::GetInstance());
 #endif
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (extensions::ExtensionsBrowserClient::Get())
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
 #endif
--- a/chrome/browser/supervised_user/supervised_user_service_factory.cc
+++ b/chrome/browser/supervised_user/supervised_user_service_factory.cc
@@ -51,6 +51,7 @@ SupervisedUserServiceFactory::Supervised
         "SupervisedUserService",
         BrowserContextDependencyManager::GetInstance()) {
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (extensions::ExtensionsBrowserClient::Get())
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
 #endif
--- a/chrome/browser/sync/profile_sync_service_factory.cc
+++ b/chrome/browser/sync/profile_sync_service_factory.cc
@@ -161,9 +161,11 @@ ProfileSyncServiceFactory::ProfileSyncSe
 #endif  // !defined(OS_ANDROID)
   DependsOn(WebDataServiceFactory::GetInstance());
 #if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (extensions::ExtensionsBrowserClient::Get()) {
   DependsOn(
       extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
   DependsOn(extensions::StorageFrontend::GetFactoryInstance());
+  }
   DependsOn(web_app::WebAppProviderFactory::GetInstance());
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 #if defined(OS_CHROMEOS)
--- a/chrome/browser/extensions/extension_system_factory.cc
+++ b/chrome/browser/extensions/extension_system_factory.cc
@@ -90,8 +90,7 @@ ExtensionSystemFactory* ExtensionSystemF
 ExtensionSystemFactory::ExtensionSystemFactory()
     : ExtensionSystemProvider("ExtensionSystem",
                               BrowserContextDependencyManager::GetInstance()) {
-  DCHECK(ExtensionsBrowserClient::Get())
-      << "ExtensionSystemFactory must be initialized after BrowserProcess";
+  if (ExtensionsBrowserClient::Get())
   DependsOn(ExtensionSystemSharedFactory::GetInstance());
 }
 
--- a/components/search/search.cc
+++ b/components/search/search.cc
@@ -13,7 +13,7 @@
 namespace search {
 
 bool IsInstantExtendedAPIEnabled() {
-#if defined(OS_IOS) || defined(OS_ANDROID)
+#if defined(OS_IOS)
   return false;
 #else
   return true;
--- a/third_party/skia/src/gpu/ops/GrSimpleMeshDrawOpHelper.cpp
+++ b/third_party/skia/src/gpu/ops/GrSimpleMeshDrawOpHelper.cpp
@@ -42,6 +42,7 @@ GrDrawOp::FixedFunctionFlags GrSimpleMes
 bool GrSimpleMeshDrawOpHelper::isCompatible(const GrSimpleMeshDrawOpHelper& that,
                                             const GrCaps& caps, const SkRect& thisBounds,
                                             const SkRect& thatBounds, bool ignoreAAType) const {
+    return false;
     if (SkToBool(fProcessors) != SkToBool(that.fProcessors)) {
         return false;
     }
--- a/components/policy/resources/policy_templates.json
+++ b/components/policy/resources/policy_templates.json
@@ -4619,7 +4619,7 @@
         'items': { 'type': 'string' },
         'id': 'ExtensionInstallSources',
       },
-      'supported_on': ['chrome.*:21-', 'chrome_os:21-'],
+      'supported_on': ['chrome.*:21-', 'chrome_os:21-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4675,7 +4675,7 @@
         },
         'id': 'ExtensionAllowedTypes',
       },
-      'supported_on': ['chrome.*:25-', 'chrome_os:25-'],
+      'supported_on': ['chrome.*:25-', 'chrome_os:25-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4806,7 +4806,7 @@
         },
       },
       'url_schema': 'https://www.ch40m1um.qjz9zk/administrators/policy-list-3/extension-settings-full',
-      'supported_on': ['chrome.*:62-', 'chrome_os:62-'],
+      'supported_on': ['chrome.*:62-', 'chrome_os:62-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
@@ -4954,7 +4954,7 @@
           'caption': '''Disallow usage of the Developer Tools''',
         },
       ],
-      'supported_on': ['chrome.*:68-', 'chrome_os:68-'],
+      'supported_on': ['chrome.*:68-', 'chrome_os:68-', 'android:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
--- a/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ b/chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -124,7 +124,6 @@
 #include "chrome/browser/ui/webui/webapks_ui.h"
 #include "components/feed/buildflags.h"
 #include "components/feed/feed_feature_list.h"
-#else  // defined(OS_ANDROID)
 #include "chrome/browser/media/feeds/media_feeds_service.h"
 #include "chrome/browser/media/kaleidoscope/constants.h"
 #include "chrome/browser/media/kaleidoscope/kaleidoscope_ui.h"
@@ -243,7 +242,7 @@
 #include "chrome/browser/ui/webui/webui_js_exception/webui_js_exception_ui.h"
 #endif
 
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
 #include "chrome/browser/ui/sync/sync_promo_ui.h"
 #include "chrome/browser/ui/webui/browser_switch/browser_switch_ui.h"
 #include "chrome/browser/ui/webui/signin/profile_customization_ui.h"
@@ -315,7 +314,7 @@ WebUIController* NewWebUI(WebUI* web_ui,
   return new T(web_ui);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 template <>
 WebUIController* NewWebUI<PageNotAvailableForGuestUI>(WebUI* web_ui,
                                                       const GURL& url) {
@@ -458,7 +457,7 @@ WebUIController* NewWebUI<chromeos::Conn
 }
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 template <>
 WebUIController* NewWebUI<WelcomeUI>(WebUI* web_ui, const GURL& url) {
   return new WelcomeUI(web_ui, url);
@@ -582,7 +581,7 @@ WebUIFactoryFunction GetWebUIFactoryFunc
   if (url.host_piece() == chrome::kChromeUIVersionHost)
     return &NewWebUI<VersionUI>;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
   // AppLauncherPage is not needed on Android or ChromeOS.
   if (url.host_piece() == chrome::kChromeUIAppLauncherPageHost && profile &&
@@ -824,7 +823,6 @@ WebUIFactoryFunction GetWebUIFactoryFunc
   }
   if (url.host_piece() == chrome::kChromeUIWebApksHost)
     return &NewWebUI<WebApksUI>;
-#else  // !defined(OS_ANDROID)
   if (url.SchemeIs(content::kChromeDevToolsScheme)) {
     if (!DevToolsUIBindings::IsValidFrontendURL(url))
       return nullptr;
@@ -840,9 +838,7 @@ WebUIFactoryFunction GetWebUIFactoryFunc
     return &NewWebUI<SyncConfirmationUI>;
   }
 #endif  // defined(OS_ANDROID)
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
-  if (url.host_piece() == chrome::kChromeUIProfileCustomizationHost)
-    return &NewWebUI<ProfileCustomizationUI>;
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
   if (url.host_piece() == chrome::kChromeUIProfilePickerHost)
     return &NewWebUI<ProfilePickerUI>;
   if (url.host_piece() == chrome::kChromeUIMdUserManagerHost)
@@ -1138,7 +1134,7 @@ base::RefCountedMemory* ChromeWebUIContr
   if (page_url.host_piece() == chrome::kChromeUIFlagsHost)
     return FlagsUI::GetFaviconResourceBytes(scale_factor);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #if !defined(OS_CHROMEOS)
   // The Apps launcher page is not available on android or ChromeOS.
   if (page_url.host_piece() == chrome::kChromeUIAppLauncherPageHost)
--- a/chrome/common/importer/firefox_importer_utils.cc
+++ b/chrome/common/importer/firefox_importer_utils.cc
@@ -45,7 +45,7 @@ base::FilePath GetProfilePath(const base
   // path of profiles.ini. IsRelative=0 refers to a custom profile
   // location.
   if (is_relative == "1")
-    path = GetProfilesINI().DirName().Append(path);
+    path = base::FilePath().DirName().Append(path);
 
   return path;
 }
@@ -54,7 +54,7 @@ base::FilePath GetProfilePath(const base
 
 std::vector<FirefoxDetail> GetFirefoxDetails(
     const std::string& firefox_install_id) {
-  base::FilePath ini_file = GetProfilesINI();
+  base::FilePath ini_file = base::FilePath();
   std::string content;
   base::ReadFileToString(ini_file, &content);
   DictionaryValueINIParser ini_parser;
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -882,7 +882,7 @@ void ContentBrowserClient::CreateWebUsbS
     RenderFrameHost* render_frame_host,
     mojo::PendingReceiver<blink::mojom::WebUsbService> receiver) {}
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 SerialDelegate* ContentBrowserClient::GetSerialDelegate() {
   return nullptr;
 }
@@ -908,7 +908,7 @@ bool ContentBrowserClient::ShouldCreateT
   return true;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 std::unique_ptr<AuthenticatorRequestClientDelegate>
 ContentBrowserClient::GetWebAuthenticationRequestDelegate(
     RenderFrameHost* render_frame_host) {
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1572,7 +1572,7 @@ class CONTENT_EXPORT ContentBrowserClien
       RenderFrameHost* render_frame_host,
       mojo::PendingReceiver<blink::mojom::WebUsbService> receiver);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Allows the embedder to provide an implementation of the Serial API.
   virtual SerialDelegate* GetSerialDelegate();
 #endif
@@ -1610,7 +1610,7 @@ class CONTENT_EXPORT ContentBrowserClien
   // destroyed before the RenderFrame goes out of scope. The embedder may choose
   // to return nullptr to indicate that the request cannot be serviced right
   // now.
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   virtual std::unique_ptr<AuthenticatorRequestClientDelegate>
   GetWebAuthenticationRequestDelegate(RenderFrameHost* render_frame_host);
 #endif
--- a/chrome/browser/ui/webui/settings/system_handler.cc
+++ b/chrome/browser/ui/webui/settings/system_handler.cc
@@ -35,7 +35,6 @@ void SystemHandler::RegisterMessages() {
 
 void SystemHandler::HandleShowProxySettings(const base::ListValue* /*args*/) {
   base::RecordAction(base::UserMetricsAction("Options_ShowProxySettings"));
-  settings_utils::ShowNetworkProxySettings(web_ui()->GetWebContents());
 }
 
 }  // namespace settings
--- a/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
+++ b/chrome/browser/ui/webui/signin/inline_login_handler_impl.cc
@@ -117,30 +117,6 @@ signin_metrics::Reason GetSigninReasonFr
   }
 }
 
-// Specific implementation of DiceTurnSyncOnHelper::Delegate for forced
-// signin flows. Some confirmation prompts are skipped.
-class ForcedSigninDiceTurnSyncOnHelperDelegate
-    : public DiceTurnSyncOnHelperDelegateImpl {
- public:
-  explicit ForcedSigninDiceTurnSyncOnHelperDelegate(Browser* browser)
-      : DiceTurnSyncOnHelperDelegateImpl(browser) {}
-
- private:
-  void ShowMergeSyncDataConfirmation(
-      const std::string& previous_email,
-      const std::string& new_email,
-      DiceTurnSyncOnHelper::SigninChoiceCallback callback) override {
-    NOTREACHED();
-  }
-
-  void ShowEnterpriseAccountConfirmation(
-      const std::string& email,
-      DiceTurnSyncOnHelper::SigninChoiceCallback callback) override {
-    std::move(callback).Run(
-        DiceTurnSyncOnHelper ::SigninChoice::SIGNIN_CHOICE_CONTINUE);
-  }
-};
-
 #if defined(OS_WIN)
 
 // Returns a list of valid signin domains that were passed in
@@ -447,16 +423,6 @@ void InlineSigninHelper::CreateSyncStart
           signin_metrics::SourceForRefreshTokenOperation::
               kInlineLoginHandler_Signin);
 
-  std::unique_ptr<DiceTurnSyncOnHelper::Delegate> delegate =
-      std::make_unique<ForcedSigninDiceTurnSyncOnHelperDelegate>(browser);
-
-  new DiceTurnSyncOnHelper(
-      profile_, signin::GetAccessPointForEmbeddedPromoURL(current_url_),
-      signin_metrics::PromoAction::PROMO_ACTION_NO_SIGNIN_PROMO,
-      signin::GetSigninReasonForEmbeddedPromoURL(current_url_), account_id,
-      DiceTurnSyncOnHelper::SigninAbortedMode::REMOVE_ACCOUNT,
-      std::move(delegate),
-      base::BindOnce(&OnSyncSetupComplete, profile_, email_, password_));
 }
 
 void InlineSigninHelper::OnClientOAuthFailure(
--- a/extensions/renderer/bindings/api_binding_util.cc
+++ b/extensions/renderer/bindings/api_binding_util.cc
@@ -131,6 +131,8 @@ std::string GetPlatformString() {
   return "mac";
 #elif defined(OS_WIN)
   return "win";
+#elif defined(OS_ANDROID)
+  return "android";
 #else
   NOTREACHED();
   return std::string();
--- a/chrome/browser/ui/webui/settings/settings_ui.cc
+++ b/chrome/browser/ui/webui/settings/settings_ui.cc
@@ -186,7 +186,6 @@ SettingsUI::SettingsUI(content::WebUI* w
   AddSettingsPageUIHandler(std::make_unique<ExtensionControlHandler>());
   AddSettingsPageUIHandler(std::make_unique<FontHandler>(profile));
   AddSettingsPageUIHandler(std::make_unique<ImportDataHandler>());
-  AddSettingsPageUIHandler(std::make_unique<HatsHandler>());
 
 #if defined(OS_WIN)
   AddSettingsPageUIHandler(std::make_unique<LanguagesHandler>());
@@ -403,13 +402,6 @@ void SettingsUI::AddSettingsPageUIHandle
 }
 
 void SettingsUI::TryShowHatsSurveyWithTimeout() {
-  HatsService* hats_service =
-      HatsServiceFactory::GetForProfile(Profile::FromWebUI(web_ui()),
-                                        /* create_if_necessary = */ true);
-  if (hats_service) {
-    hats_service->LaunchDelayedSurveyForWebContents(
-        kHatsSurveyTriggerSettings, web_ui()->GetWebContents(), 20000);
-  }
 }
 
 #if !defined(OS_CHROMEOS)
--- a/components/page_info/page_info_ui.cc
+++ b/components/page_info/page_info_ui.cc
@@ -29,7 +29,6 @@
 #include "url/gurl.h"
 #if defined(OS_ANDROID)
 #include "components/resources/android/theme_resources.h"
-#else
 #include "media/base/media_switches.h"
 #include "ui/gfx/color_palette.h"
 #include "ui/gfx/color_utils.h"
@@ -44,7 +43,7 @@ namespace {
 
 const int kInvalidResourceID = -1;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // The icon size is actually 16, but the vector icons being used generally all
 // have additional internal padding. Account for this difference by asking for
 // the vectors in 18x18dip sizes.
@@ -104,7 +103,7 @@ static_assert(base::size(kPermissionButt
                   CONTENT_SETTING_NUM_SETTINGS,
               "kPermissionButtonTextIDDefaultSetting array size is incorrect");
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // The resource IDs for the strings that are displayed on the sound permission
 // button if the sound permission setting is managed by the user.
 const int kSoundPermissionButtonTextIDUserManaged[] = {
@@ -170,7 +169,7 @@ base::span<const PermissionsUIInfo> GetC
          ? IDS_PAGE_INFO_TYPE_SENSORS
          : IDS_PAGE_INFO_TYPE_MOTION_SENSORS},
     {ContentSettingsType::USB_GUARD, IDS_PAGE_INFO_TYPE_USB},
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
     {ContentSettingsType::SERIAL_GUARD, IDS_PAGE_INFO_TYPE_SERIAL},
 #endif
     {ContentSettingsType::BLUETOOTH_GUARD, IDS_PAGE_INFO_TYPE_BLUETOOTH},
@@ -650,7 +649,6 @@ int PageInfoUI::GetConnectionIconColorID
   return 0;
 }
 
-#else  // !defined(OS_ANDROID)
 // static
 const gfx::ImageSkia PageInfoUI::GetPermissionIcon(
     const PageInfo::PermissionInfo& info,
--- a/components/page_info/page_info_ui.h
+++ b/components/page_info/page_info_ui.h
@@ -18,7 +18,7 @@
 #include "components/safe_browsing/buildflags.h"
 #include "ui/gfx/native_widget_types.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "ui/gfx/image/image_skia.h"
 #endif
 
@@ -192,7 +192,6 @@ class PageInfoUI {
 
   // Returns the connection icon color ID for the given connection |status|.
   static int GetConnectionIconColorID(PageInfo::SiteConnectionStatus status);
-#else  // !defined(OS_ANDROID)
   // Returns icons for the given PageInfo::PermissionInfo |info|. If |info|'s
   // current setting is CONTENT_SETTING_DEFAULT, it will return the icon for
   // |info|'s default setting.
--- a/chrome/browser/ui/passwords/settings/password_manager_presenter.h
+++ b/chrome/browser/ui/passwords/settings/password_manager_presenter.h
@@ -105,7 +105,7 @@ class PasswordManagerPresenter
       const std::vector<std::string>& sort_keys,
       password_manager::PasswordManagerClient* client);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Requests to reveal the plain text password corresponding to |sort_key|. If
   // |sort_key| is a valid key into |password_map_|, runs |callback| with the
   // corresponding value, or nullopt otherwise.
--- a/chrome/browser/ui/webui/omnibox/omnibox_ui.cc
+++ b/chrome/browser/ui/webui/omnibox/omnibox_ui.cc
@@ -21,7 +21,7 @@
 #include "content/public/browser/web_ui_data_source.h"
 #include "services/network/public/mojom/content_security_policy.mojom.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/webui/omnibox/omnibox_popup_handler.h"
 #endif
 
@@ -56,7 +56,7 @@ OmniboxUI::OmniboxUI(content::WebUI* web
 
   source->SetDefaultResource(IDR_OMNIBOX_HTML);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   if (base::FeatureList::IsEnabled(omnibox::kWebUIOmniboxPopup)) {
     source->AddResourcePath("omnibox_popup.js", IDR_OMNIBOX_POPUP_JS);
     source->AddResourcePath("omnibox_popup.html", IDR_OMNIBOX_POPUP_HTML);
--- a/chrome/browser/ui/webui/omnibox/omnibox_ui.h
+++ b/chrome/browser/ui/webui/omnibox/omnibox_ui.h
@@ -13,7 +13,7 @@
 
 class OmniboxPageHandler;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 class OmniboxPopupHandler;
 #endif
 
@@ -27,7 +27,7 @@ class OmniboxUI : public ui::MojoWebUICo
   // interface passing the pending receiver that will be internally bound.
   void BindInterface(mojo::PendingReceiver<mojom::OmniboxPageHandler> receiver);
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // This is needed for the Views native UI to call into the WebUI code.
   OmniboxPopupHandler* popup_handler() { return popup_handler_.get(); }
 #endif
@@ -35,7 +35,7 @@ class OmniboxUI : public ui::MojoWebUICo
  private:
   std::unique_ptr<OmniboxPageHandler> omnibox_handler_;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   std::unique_ptr<OmniboxPopupHandler> popup_handler_;
 #endif
 
--- a/chrome/browser/ui/native_file_system_dialogs.cc
+++ b/chrome/browser/ui/native_file_system_dialogs.cc
@@ -6,7 +6,7 @@
 
 #include "components/permissions/permission_util.h"
 
-#if !defined(TOOLKIT_VIEWS)
+#if defined(TOOLKIT_VIEWS)
 void ShowNativeFileSystemPermissionDialog(
     const NativeFileSystemPermissionRequestManager::RequestData& request,
     base::OnceCallback<void(permissions::PermissionAction result)> callback,
--- a/chrome/browser/ui/views/frame/browser_frame.cc
+++ b/chrome/browser/ui/views/frame/browser_frame.cc
@@ -194,11 +194,6 @@ const ui::ThemeProvider* BrowserFrame::G
 }
 
 const ui::NativeTheme* BrowserFrame::GetNativeTheme() const {
-  if (browser_view_->browser()->profile()->IsIncognitoProfile() &&
-      ThemeServiceFactory::GetForProfile(browser_view_->browser()->profile())
-          ->UsingDefaultTheme()) {
-    return ui::NativeTheme::GetInstanceForDarkUI();
-  }
   return views::Widget::GetNativeTheme();
 }
 
--- a/chrome/browser/devtools/devtools_window.cc
+++ b/chrome/browser/devtools/devtools_window.cc
@@ -1545,7 +1545,6 @@ void DevToolsWindow::ShowCertificateView
   if (!FindInspectedBrowserAndTabIndex(inspected_contents, &browser, &tab))
     return;
   gfx::NativeWindow parent = browser->window()->GetNativeWindow();
-  ::ShowCertificateViewer(inspected_contents, parent, cert.get());
 }
 
 void DevToolsWindow::OnLoadCompleted() {
--- a/chrome/browser/ui/views/page_info/page_info_bubble_view.cc
+++ b/chrome/browser/ui/views/page_info/page_info_bubble_view.cc
@@ -1017,7 +1017,6 @@ void PageInfoBubbleView::HandleMoreInfoR
       if (certificate_ && top_window) {
         presenter_->RecordPageInfoAction(
             PageInfo::PAGE_INFO_CERTIFICATE_DIALOG_OPENED);
-        ShowCertificateViewer(web_contents(), top_window, certificate_.get());
       }
       break;
     }
--- a/chrome/browser/web_applications/components/web_app_file_handler_registration.cc
+++ b/chrome/browser/web_applications/components/web_app_file_handler_registration.cc
@@ -12,7 +12,7 @@ namespace web_app {
 // This block defines stub implementations of OS specific methods for
 // FileHandling. Currently, Windows, MacOSX and Desktop Linux (but not Chrome
 // OS) have their own implementations.
-#if defined(OS_CHROMEOS)
+#if defined(OS_ANDROID)
 bool ShouldRegisterFileHandlersWithOs() {
   return false;
 }
--- a/components/embedder_support/android/java/src/org/chromium/components/embedder_support/util/Origin.java
+++ b/components/embedder_support/android/java/src/org/chromium/components/embedder_support/util/Origin.java
@@ -5,6 +5,7 @@
 package org.chromium.components.embedder_support.util;
 
 import android.net.Uri;
+import org.chromium.base.Log;
 
 import androidx.annotation.Nullable;
 
@@ -44,24 +45,33 @@ public class Origin {
      */
     @Nullable
     public static Origin create(Uri uri) {
+        Log.d("Origin.java", "create: %s", uri);
         if (uri == null || uri.getScheme() == null || uri.getAuthority() == null) {
+            Log.d("Origin.java", "create 1");
             return null;
         }
 
         // This class can only correctly handle certain origins, see https://crbug.com/1019244.
         String scheme = uri.getScheme();
-        if (!scheme.equals(UrlConstants.HTTP_SCHEME) && !scheme.equals(UrlConstants.HTTPS_SCHEME)) {
+        Log.d("Origin.java", "create: scheme: %s", scheme);
+        if (!scheme.equals(UrlConstants.HTTP_SCHEME) && !scheme.equals(UrlConstants.HTTPS_SCHEME) && !scheme.equals(UrlConstants.CHROME_EXTENSION_SCHEME)) {
+            Log.d("Origin.java", "create 2");
             return null;
         }
 
         // Make explicit ports implicit and remove any user:password.
         int port = uri.getPort();
+        Log.d("Origin.java", "create: port: %d", port);
         if (scheme.equals(UrlConstants.HTTP_SCHEME) && port == HTTP_DEFAULT_PORT) port = -1;
         if (scheme.equals(UrlConstants.HTTPS_SCHEME) && port == HTTPS_DEFAULT_PORT) port = -1;
+        Log.d("Origin.java", "create: port2: %d", port);
 
         String authority = uri.getHost();
+        Log.d("Origin.java", "create: authority: %s", authority);
         if (port != -1) authority += ":" + port;
 
+        Log.d("Origin.java", "create: new Origin: %s", uri.normalizeScheme().toString());
+
         try {
             return new Origin(uri.normalizeScheme()
                                       .buildUpon()
@@ -87,6 +97,7 @@ public class Origin {
      * Constructs a canonical Origin from an Uri, throwing an exception if parsing fails.
      */
     public static Origin createOrThrow(Uri uri) {
+        Log.d("Origin.java", "Uri: %s", uri.toString());
         Origin origin = Origin.create(uri);
         if (origin == null) throw new IllegalArgumentException("Could not parse: " + uri);
         return origin;
--- a/components/embedder_support/android/java/src/org/chromium/components/embedder_support/util/UrlConstants.java
+++ b/components/embedder_support/android/java/src/org/chromium/components/embedder_support/util/UrlConstants.java
@@ -10,6 +10,7 @@ package org.chromium.components.embedder
 public class UrlConstants {
     public static final String BLOB_SCHEME = "blob";
     public static final String CHROME_SCHEME = "chrome";
+    public static final String CHROME_EXTENSION_SCHEME = "chrome-extension";
     public static final String CHROME_NATIVE_SCHEME = "chrome-native";
     public static final String CONTENT_SCHEME = "content";
     public static final String CUSTOM_TAB_SCHEME = "customtab";
--- a/chrome/browser/performance_manager/policies/policy_features.cc
+++ b/chrome/browser/performance_manager/policies/policy_features.cc
@@ -119,7 +119,7 @@ const base::FeatureParam<int> kDynamicTu
 
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 const base::Feature kPageFreezingFromPerformanceManager{
     "PageFreezingFromPerformanceManager", base::FEATURE_DISABLED_BY_DEFAULT};
 
--- a/chrome/browser/performance_manager/policies/policy_features.h
+++ b/chrome/browser/performance_manager/policies/policy_features.h
@@ -114,7 +114,7 @@ extern const base::FeatureParam<int> kDy
 
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Enables freezing pages directly from PerformanceManager rather than via
 // TabManager.
 extern const base::Feature kPageFreezingFromPerformanceManager;
--- a/ui/base/dragdrop/os_exchange_data_provider.h
+++ b/ui/base/dragdrop/os_exchange_data_provider.h
@@ -24,7 +24,7 @@
 #include "ui/base/dragdrop/file_info/file_info.h"
 #include "url/gurl.h"
 
-#if defined(USE_AURA) || defined(OS_APPLE)
+#if defined(USE_AURA) || defined(OS_APPLE) || defined(OS_ANDROID)
 #include "ui/gfx/geometry/vector2d.h"
 #include "ui/gfx/image/image_skia.h"
 #endif
@@ -95,13 +95,13 @@ class COMPONENT_EXPORT(UI_BASE_DATA_EXCH
   virtual void SetDownloadFileInfo(DownloadFileInfo* download) = 0;
 #endif
 
-#if defined(USE_AURA)
+#if defined(USE_AURA) || defined(OS_ANDROID)
   virtual void SetHtml(const base::string16& html, const GURL& base_url) = 0;
   virtual bool GetHtml(base::string16* html, GURL* base_url) const = 0;
   virtual bool HasHtml() const = 0;
 #endif
 
-#if defined(USE_AURA) || defined(OS_APPLE)
+#if defined(USE_AURA) || defined(OS_APPLE) || defined(OS_ANDROID)
   virtual void SetDragImage(const gfx::ImageSkia& image,
                             const gfx::Vector2d& cursor_offset) = 0;
   virtual gfx::ImageSkia GetDragImage() const = 0;
--- a/components/autofill/core/browser/form_data_importer.cc
+++ b/components/autofill/core/browser/form_data_importer.cc
@@ -230,7 +230,7 @@ FormDataImporter::FormDataImporter(Autof
                                                   personal_data_manager)),
       address_profile_save_manager_(
           std::make_unique<AddressProfileSaveManager>(personal_data_manager)),
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
       local_card_migration_manager_(
           std::make_unique<LocalCardMigrationManager>(client,
                                                       payments_client,
@@ -262,7 +262,7 @@ void FormDataImporter::ImportFormData(co
                  /*should_return_local_card=*/is_credit_card_upstream_enabled,
                  &imported_credit_card, &detected_upi_id);
 
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
   if (detected_upi_id && credit_card_autofill_enabled &&
       base::FeatureList::IsEnabled(features::kAutofillSaveAndFillVPA)) {
     upi_vpa_save_manager_->OfferLocalSave(*detected_upi_id);
@@ -280,7 +280,7 @@ void FormDataImporter::ImportFormData(co
     return;
   }
 
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
   // A credit card was successfully imported, but it's possible it is already a
   // local or server card. First, check to see if we should offer local card
   // migration in this case, as local cards could go either way.
--- a/components/autofill/core/browser/form_data_importer.h
+++ b/components/autofill/core/browser/form_data_importer.h
@@ -68,7 +68,7 @@ class FormDataImporter {
                                       const std::string& app_locale,
                                       LogBuffer* import_log_buffer);
 
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
   LocalCardMigrationManager* local_card_migration_manager() {
     return local_card_migration_manager_.get();
   }
@@ -81,7 +81,7 @@ class FormDataImporter {
     credit_card_save_manager_ = std::move(credit_card_save_manager);
   }
 
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
   // Exposed for testing.
   void set_local_card_migration_manager(
       std::unique_ptr<LocalCardMigrationManager> local_card_migration_manager) {
@@ -156,7 +156,7 @@ class FormDataImporter {
   // Responsible for managing address profiles save flows.
   std::unique_ptr<AddressProfileSaveManager> address_profile_save_manager_;
 
-#if !defined(OS_ANDROID) && !defined(OS_IOS)
+#if defined(OS_ANDROID) && !defined(OS_IOS)
   // Responsible for migrating locally saved credit cards to Google Pay.
   std::unique_ptr<LocalCardMigrationManager> local_card_migration_manager_;
 
--- a/chrome/browser/extensions/api/settings_private/prefs_util.cc
+++ b/chrome/browser/extensions/api/settings_private/prefs_util.cc
@@ -376,7 +376,7 @@ const PrefsUtil::TypedPrefMap& PrefsUtil
       settings_api::PrefType::PREF_TYPE_STRING;
   (*s_allowlist)[::prefs::kAccessibilityCaptionsBackgroundOpacity] =
       settings_api::PrefType::PREF_TYPE_NUMBER;
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   (*s_allowlist)[::prefs::kLiveCaptionEnabled] =
       settings_api::PrefType::PREF_TYPE_BOOLEAN;
 #endif
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -6242,7 +6242,7 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kMediaHistoryDescription, kOsAll,
      FEATURE_VALUE_TYPE(media::kUseMediaHistoryStore)},
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
     {"copy-link-to-text", flag_descriptions::kCopyLinkToTextName,
      flag_descriptions::kCopyLinkToTextDescription, kOsDesktop,
      FEATURE_VALUE_TYPE(features::kCopyLinkToText)},
--- a/chrome/browser/browser_features.cc
+++ b/chrome/browser/browser_features.cc
@@ -34,7 +34,7 @@ const base::Feature kDoubleTapToZoomInTa
     "DoubleTapToZoomInTabletMode", base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 // Adds an item to the context menu that copies a link to the page with the
 // selected text highlighted.
 const base::Feature kCopyLinkToText{"CopyLinkToText",
--- a/chrome/browser/browser_features.h
+++ b/chrome/browser/browser_features.h
@@ -27,7 +27,7 @@ extern const char kPromoBrowserCommandId
 extern const base::Feature kDoubleTapToZoomInTabletMode;
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 extern const base::Feature kCopyLinkToText;
 extern const base::Feature kMuteNotificationsDuringScreenShare;
 extern const base::Feature kShutdownSupportForKeepalive;
--- a/chrome/browser/ui/global_error/global_error.cc
+++ b/chrome/browser/ui/global_error/global_error.cc
@@ -27,7 +27,7 @@ GlobalError::Severity GlobalError::GetSe
 
 ui::ImageModel GlobalError::MenuItemIcon() {
 #if defined(OS_ANDROID)
-  return ui::ImageModel(
+  return ui::ImageModel::FromImage(
       ui::ResourceBundle::GetSharedInstance().GetNativeImageNamed(
           IDR_INPUT_ALERT_MENU));
 #else
--- a/chrome/browser/ui/views/profiles/profile_menu_view.h
+++ b/chrome/browser/ui/views/profiles/profile_menu_view.h
@@ -57,7 +57,7 @@ class ProfileMenuView : public ProfileMe
   void OnSyncErrorButtonClicked(sync_ui_util::AvatarSyncErrorType error);
   void OnSigninAccountButtonClicked(AccountInfo account);
   void OnCookiesClearedOnExitLinkClicked();
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   void OnSignoutButtonClicked();
   void OnSigninButtonClicked();
   void OnOtherProfileSelected(const base::FilePath& profile_path);
@@ -77,7 +77,7 @@ class ProfileMenuView : public ProfileMe
   void BuildAutofillButtons();
   void BuildSyncInfo();
   void BuildFeatureButtons();
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   void BuildSelectableProfiles();
   void BuildProfileManagementHeading();
   void BuildProfileManagementFeatureButtons();
--- a/chrome/browser/ui/webui/settings/people_handler.cc
+++ b/chrome/browser/ui/webui/settings/people_handler.cc
@@ -59,7 +59,7 @@
 #include "ui/base/webui/web_ui_util.h"
 #include "ui/gfx/image/image.h"
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
 #include "chrome/browser/ui/webui/profile_helper.h"
 #endif
 
@@ -289,7 +289,7 @@ void PeopleHandler::RegisterMessages() {
       "SyncPrefsDispatch",
       base::BindRepeating(&PeopleHandler::HandleSyncPrefsDispatch,
                           base::Unretained(this)));
-#if defined(OS_CHROMEOS)
+#if defined(OS_CHROMEOS) || defined(OS_ANDROID)
   web_ui()->RegisterMessageCallback(
       "AttemptUserExit",
       base::BindRepeating(&PeopleHandler::HandleAttemptUserExit,
@@ -349,7 +349,7 @@ void PeopleHandler::OnJavascriptDisallow
   sync_service_observer_.RemoveAll();
 }
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
 void PeopleHandler::DisplayGaiaLogin(signin_metrics::AccessPoint access_point) {
   // Advanced options are no longer being configured if the login screen is
   // visible. If the user exits the signin wizard after this without
@@ -626,7 +626,7 @@ void PeopleHandler::HandleShowSyncSetupU
   web_ui()->GetWebContents()->Focus();
 }
 
-#if defined(OS_CHROMEOS)
+#if defined(OS_CHROMEOS) || defined(OS_ANDROID)
 // On ChromeOS, we need to sign out the user session to fix an auth error, so
 // the user goes through the real signin flow to generate a new auth token.
 void PeopleHandler::HandleAttemptUserExit(const base::ListValue* args) {
@@ -644,11 +644,10 @@ void PeopleHandler::HandleTurnOffSync(co
   DCHECK(identity_manager->HasPrimaryAccount(ConsentLevel::kSync));
   DCHECK(signin_util::IsUserSignoutAllowedForProfile(profile_));
 
-  identity_manager->GetPrimaryAccountMutator()->RevokeSyncConsent();
 }
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
 void PeopleHandler::HandleStartSignin(const base::ListValue* args) {
   AllowJavascript();
 
@@ -767,7 +766,7 @@ void PeopleHandler::CloseSyncSetup() {
         if (sync_service) {
           DVLOG(1) << "Sync setup aborted by user action";
           sync_service->StopAndClear();
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
           // Sign out the user on desktop Chrome if they click cancel during
           // initial setup.
           if (!sync_service->GetUserSettings()->IsFirstSetupComplete()) {
@@ -1038,7 +1037,7 @@ void PeopleHandler::MarkFirstSetupComple
 }
 
 void PeopleHandler::MaybeMarkSyncConfiguring() {
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   if (IsProfileAuthNeededOrHasErrors())
     return;
 #endif
--- a/chrome/browser/ui/views/payments/cvc_unmask_view_controller.cc
+++ b/chrome/browser/ui/views/payments/cvc_unmask_view_controller.cc
@@ -395,4 +395,17 @@ void CvcUnmaskViewController::OnPerformA
   UpdatePayButtonState();
 }
 
+#if defined(OS_ANDROID)
+bool CvcUnmaskViewController::ShouldOfferFidoAuth() const {
+  // If the user opted-in through the settings page, do not show checkbox.
+  return false;
+}
+
+bool CvcUnmaskViewController::UserOptedInToFidoFromSettingsPageOnMobile()
+    const {
+  return false;
+}
+#endif
+
+
 }  // namespace payments
--- a/chrome/browser/ui/views/payments/cvc_unmask_view_controller.h
+++ b/chrome/browser/ui/views/payments/cvc_unmask_view_controller.h
@@ -64,6 +64,11 @@ class CvcUnmaskViewController
   void OnUnmaskVerificationResult(
       autofill::AutofillClient::PaymentsRpcResult result) override;
 
+#if defined(OS_ANDROID)
+  bool ShouldOfferFidoAuth() const override;
+  bool UserOptedInToFidoFromSettingsPageOnMobile() const override;
+#endif
+
  protected:
   // PaymentRequestSheetController:
   base::string16 GetSheetTitle() override;
--- a/components/autofill/core/browser/payments/local_card_migration_manager.cc
+++ b/components/autofill/core/browser/payments/local_card_migration_manager.cc
@@ -252,9 +252,6 @@ void LocalCardMigrationManager::OnDidGet
                 NOT_OFFERED_NO_SUPPORTED_CARDS);
         return;
       }
-      client_->ShowLocalCardMigrationDialog(base::BindOnce(
-          &LocalCardMigrationManager::OnUserAcceptedIntermediateMigrationDialog,
-          weak_ptr_factory_.GetWeakPtr()));
       AutofillMetrics::LogLocalCardMigrationPromptMetric(
           local_card_migration_origin_,
           AutofillMetrics::INTERMEDIATE_BUBBLE_SHOWN);
@@ -325,13 +322,6 @@ void LocalCardMigrationManager::OnDidMig
     // Remove cards that were successfully migrated from local storage.
     personal_data_manager_->DeleteLocalCreditCards(migrated_cards);
   }
-
-  client_->ShowLocalCardMigrationResults(
-      result != AutofillClient::PaymentsRpcResult::SUCCESS,
-      base::UTF8ToUTF16(display_text), migratable_credit_cards_,
-      base::BindRepeating(
-          &LocalCardMigrationManager::OnUserDeletedLocalCardViaMigrationDialog,
-          weak_ptr_factory_.GetWeakPtr()));
 }
 
 void LocalCardMigrationManager::OnDidGetMigrationRiskData(
@@ -379,13 +369,6 @@ void LocalCardMigrationManager::ShowMain
   AutofillMetrics::LogLocalCardMigrationPromptMetric(
       local_card_migration_origin_, AutofillMetrics::MAIN_DIALOG_SHOWN);
   // Pops up a larger, modal dialog showing the local cards to be uploaded.
-  client_->ConfirmMigrateLocalCardToCloud(
-      legal_message_lines_,
-      personal_data_manager_->GetAccountInfoForPaymentsServer().email,
-      migratable_credit_cards_,
-      base::BindOnce(
-          &LocalCardMigrationManager::OnUserAcceptedMainMigrationDialog,
-          weak_ptr_factory_.GetWeakPtr()));
 }
 
 int LocalCardMigrationManager::GetDetectedValues() const {
--- a/components/autofill/core/browser/payments/upi_vpa_save_manager.cc
+++ b/components/autofill/core/browser/payments/upi_vpa_save_manager.cc
@@ -15,12 +15,7 @@ UpiVpaSaveManager::UpiVpaSaveManager(Aut
 UpiVpaSaveManager::~UpiVpaSaveManager() = default;
 
 void UpiVpaSaveManager::OfferLocalSave(const std::string& upi_id) {
-  if (!personal_data_manager_)
-    return;
-
-  client_->ConfirmSaveUpiIdLocally(
-      upi_id, base::BindOnce(&UpiVpaSaveManager::OnUserDecidedOnLocalSave,
-                             weak_ptr_factory_.GetWeakPtr(), upi_id));
+  return;
 }
 
 void UpiVpaSaveManager::OnUserDecidedOnLocalSave(const std::string& upi_id,
--- a/chrome/browser/ui/webui/settings/people_handler.h
+++ b/chrome/browser/ui/webui/settings/people_handler.h
@@ -154,12 +154,11 @@ class PeopleHandler : public SettingsPag
   void HandleSetEncryption(const base::ListValue* args);
   void HandleShowSyncSetupUI(const base::ListValue* args);
   void HandleSyncPrefsDispatch(const base::ListValue* args);
-#if defined(OS_CHROMEOS)
+#if defined(OS_CHROMEOS) || defined(OS_ANDROID)
   void HandleAttemptUserExit(const base::ListValue* args);
   void HandleTurnOnSync(const base::ListValue* args);
   void HandleTurnOffSync(const base::ListValue* args);
-#endif
-#if !defined(OS_CHROMEOS)
+#else
   void HandleStartSignin(const base::ListValue* args);
   void HandleSignout(const base::ListValue* args);
   void HandlePauseSync(const base::ListValue* args);
@@ -167,7 +166,7 @@ class PeopleHandler : public SettingsPag
   void HandleStartKeyRetrieval(const base::ListValue* args);
   void HandleGetSyncStatus(const base::ListValue* args);
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   // Displays the GAIA login form.
   void DisplayGaiaLogin(signin_metrics::AccessPoint access_point);
 
--- a/chrome/browser/web_applications/components/web_app_shortcut_linux.cc
+++ b/chrome/browser/web_applications/components/web_app_shortcut_linux.cc
@@ -13,7 +13,6 @@
 #include "base/files/scoped_temp_dir.h"
 #include "base/i18n/file_util_icu.h"
 #include "base/logging.h"
-#include "base/metrics/histogram_macros.h"
 #include "base/nix/xdg_util.h"
 #include "base/path_service.h"
 #include "base/posix/eintr_wrapper.h"
@@ -23,7 +22,6 @@
 #include "base/strings/string_util.h"
 #include "base/threading/scoped_blocking_call.h"
 #include "chrome/browser/shell_integration.h"
-#include "chrome/browser/shell_integration_linux.h"
 #include "chrome/browser/web_applications/components/web_app_id.h"
 #include "chrome/browser/web_applications/components/web_app_shortcut.h"
 #include "chrome/common/buildflags.h"
@@ -31,237 +29,6 @@
 
 namespace {
 
-// UMA metric name for creating shortcut result.
-constexpr const char* kCreateShortcutResult =
-    "Apps.CreateShortcuts.Linux.Result";
-
-// UMA metric name for creating shortcut icon result.
-constexpr const char* kCreateShortcutIconResult =
-    "Apps.CreateShortcutIcon.Linux.Result";
-
-// Result of creating app shortcut icon.
-// Success is recorded for each icon image, but the first two errors
-// are per app, so the success/error ratio might not be very meaningful.
-enum class CreateShortcutIconResult {
-  kSuccess = 0,
-  kEmptyIconImages = 1,
-  kFailToCreateTempDir = 2,
-  kFailToEncodeImageToPng = 3,
-  kImageCorrupted = 4,
-  kFailToInstallIcon = 5,
-  kMaxValue = kFailToInstallIcon
-};
-
-// Result of creating app shortcut.
-// These values are persisted to logs. Entries should not be renumbered and
-// numeric values should never be reused.
-enum class CreateShortcutResult {
-  kSuccess = 0,
-  kFailToGetShortcutFilename = 1,
-  kFailToGetChromeExePath = 2,
-  kFailToGetDesktopPath = 3,
-  kFailToOpenDesktopDir = 4,
-  kFailToOpenShortcutFilepath = 5,
-  kCorruptDesktopShortcut = 6,
-  kFailToCreateTempDir = 7,
-  kCorruptDirectoryContents = 8,
-  kCorruptApplicationsMenuShortcut = 9,
-  kFailToInstallShortcut = 10,
-  kMaxValue = kFailToInstallShortcut
-};
-
-// Record UMA metric for creating shortcut icon.
-void RecordCreateIcon(CreateShortcutIconResult result) {
-  UMA_HISTOGRAM_ENUMERATION(kCreateShortcutIconResult, result);
-}
-
-// Record UMA metric for creating shortcut.
-void RecordCreateShortcut(CreateShortcutResult result) {
-  UMA_HISTOGRAM_ENUMERATION(kCreateShortcutResult, result);
-}
-
-const char kDirectoryFilename[] = "chrome-apps.directory";
-
-std::string CreateShortcutIcon(const gfx::ImageFamily& icon_images,
-                               const base::FilePath& shortcut_filename) {
-  if (icon_images.empty()) {
-    RecordCreateIcon(CreateShortcutIconResult::kEmptyIconImages);
-    return std::string();
-  }
-
-  // TODO(phajdan.jr): Report errors from this function, possibly as infobars.
-  base::ScopedTempDir temp_dir;
-  if (!temp_dir.CreateUniqueTempDir()) {
-    RecordCreateIcon(CreateShortcutIconResult::kFailToCreateTempDir);
-    return std::string();
-  }
-
-  base::FilePath temp_file_path =
-      temp_dir.GetPath().Append(shortcut_filename.ReplaceExtension("png"));
-  std::string icon_name = temp_file_path.BaseName().RemoveExtension().value();
-
-  for (gfx::ImageFamily::const_iterator it = icon_images.begin();
-       it != icon_images.end(); ++it) {
-    int width = it->Width();
-    scoped_refptr<base::RefCountedMemory> png_data = it->As1xPNGBytes();
-    if (png_data->size() == 0) {
-      // If the bitmap could not be encoded to PNG format, skip it.
-      LOG(WARNING) << "Could not encode icon " << icon_name << ".png at size "
-                   << width << ".";
-      RecordCreateIcon(CreateShortcutIconResult::kFailToEncodeImageToPng);
-      continue;
-    }
-    if (!base::WriteFile(temp_file_path, *png_data)) {
-      RecordCreateIcon(CreateShortcutIconResult::kImageCorrupted);
-      return std::string();
-    }
-
-    std::vector<std::string> argv;
-    argv.push_back("xdg-icon-resource");
-    argv.push_back("install");
-
-    // Always install in user mode, even if someone runs the browser as root
-    // (people do that).
-    argv.push_back("--mode");
-    argv.push_back("user");
-
-    argv.push_back("--size");
-    argv.push_back(base::NumberToString(width));
-
-    argv.push_back(temp_file_path.value());
-    argv.push_back(icon_name);
-    int exit_code;
-    if (!shell_integration_linux::LaunchXdgUtility(argv, &exit_code) ||
-        exit_code) {
-      LOG(WARNING) << "Could not install icon " << icon_name << ".png at size "
-                   << width << ".";
-      RecordCreateIcon(CreateShortcutIconResult::kFailToInstallIcon);
-    } else {
-      RecordCreateIcon(CreateShortcutIconResult::kSuccess);
-    }
-  }
-  return icon_name;
-}
-
-bool CreateShortcutOnDesktop(const base::FilePath& shortcut_filename,
-                             const std::string& contents) {
-  // Make sure that we will later call openat in a secure way.
-  DCHECK_EQ(shortcut_filename.BaseName().value(), shortcut_filename.value());
-
-  base::FilePath desktop_path;
-  if (!base::PathService::Get(base::DIR_USER_DESKTOP, &desktop_path)) {
-    RecordCreateShortcut(CreateShortcutResult::kFailToGetDesktopPath);
-    return false;
-  }
-
-  int desktop_fd = open(desktop_path.value().c_str(), O_RDONLY | O_DIRECTORY);
-  if (desktop_fd < 0) {
-    RecordCreateShortcut(CreateShortcutResult::kFailToOpenDesktopDir);
-    return false;
-  }
-
-  int fd = openat(desktop_fd, shortcut_filename.value().c_str(),
-                  O_CREAT | O_EXCL | O_WRONLY,
-                  S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);
-  if (fd < 0) {
-    if (IGNORE_EINTR(close(desktop_fd)) < 0)
-      PLOG(ERROR) << "close";
-    RecordCreateShortcut(CreateShortcutResult::kFailToOpenShortcutFilepath);
-    return false;
-  }
-
-  if (!base::WriteFileDescriptor(fd, contents.c_str(), contents.size())) {
-    // Delete the file. No shortuct is better than corrupted one. Use unlinkat
-    // to make sure we're deleting the file in the directory we think we are.
-    // Even if an attacker manager to put something other at
-    // |shortcut_filename| we'll just undo their action.
-    RecordCreateShortcut(CreateShortcutResult::kCorruptDesktopShortcut);
-    unlinkat(desktop_fd, shortcut_filename.value().c_str(), 0);
-  }
-
-  if (IGNORE_EINTR(close(fd)) < 0)
-    PLOG(ERROR) << "close";
-
-  if (IGNORE_EINTR(close(desktop_fd)) < 0)
-    PLOG(ERROR) << "close";
-
-  return true;
-}
-
-// Creates a shortcut with |shortcut_filename| and |contents| in the system
-// applications menu. If |directory_filename| is non-empty, creates a sub-menu
-// with |directory_filename| and |directory_contents|, and stores the shortcut
-// under the sub-menu.
-bool CreateShortcutInApplicationsMenu(const base::FilePath& shortcut_filename,
-                                      const std::string& contents,
-                                      const base::FilePath& directory_filename,
-                                      const std::string& directory_contents) {
-  base::ScopedTempDir temp_dir;
-  if (!temp_dir.CreateUniqueTempDir()) {
-    RecordCreateShortcut(CreateShortcutResult::kFailToCreateTempDir);
-    return false;
-  }
-
-  base::FilePath temp_directory_path;
-  if (!directory_filename.empty()) {
-    temp_directory_path = temp_dir.GetPath().Append(directory_filename);
-    if (!base::WriteFile(temp_directory_path, directory_contents)) {
-      RecordCreateShortcut(CreateShortcutResult::kCorruptDirectoryContents);
-      return false;
-    }
-  }
-
-  base::FilePath temp_file_path = temp_dir.GetPath().Append(shortcut_filename);
-  if (!base::WriteFile(temp_file_path, contents)) {
-    RecordCreateShortcut(
-        CreateShortcutResult::kCorruptApplicationsMenuShortcut);
-    return false;
-  }
-
-  std::vector<std::string> argv;
-  argv.push_back("xdg-desktop-menu");
-  argv.push_back("install");
-
-  // Always install in user mode, even if someone runs the browser as root
-  // (people do that).
-  argv.push_back("--mode");
-  argv.push_back("user");
-
-  // If provided, install the shortcut file inside the given directory.
-  if (!directory_filename.empty())
-    argv.push_back(temp_directory_path.value());
-  argv.push_back(temp_file_path.value());
-  int exit_code;
-  shell_integration_linux::LaunchXdgUtility(argv, &exit_code);
-
-  if (exit_code != 0) {
-    RecordCreateShortcut(CreateShortcutResult::kFailToInstallShortcut);
-    return false;
-  }
-
-  // Some Linux file managers (Nautilus and Nemo) depend on an up to date
-  // mimeinfo.cache file to detect whether applications can open files, so
-  // manually run update-desktop-database on the user applications folder.
-  // See this bug on xdg desktop-file-utils
-  // https://gitlab.freedesktop.org/xdg/desktop-file-utils/issues/54
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  base::FilePath user_applications_dir =
-      shell_integration_linux::GetDataWriteLocation(env.get()).Append(
-          "applications");
-  argv.clear();
-  argv.push_back("update-desktop-database");
-  argv.push_back(user_applications_dir.value());
-
-  // Ignore the exit code of update-desktop-database, if it fails it isn't
-  // important (the shortcut is created and usable when xdg-desktop-menu install
-  // completes). Failure means the file type associations for this desktop entry
-  // may not show up in some file managers, but this is non-critical.
-  int ignored_exit_code = 0;
-  shell_integration_linux::LaunchXdgUtility(argv, &ignored_exit_code);
-
-  return true;
-}
-
 }  // namespace
 
 namespace web_app {
@@ -284,122 +51,18 @@ base::FilePath GetAppShortcutFilename(co
 bool DeleteShortcutOnDesktop(const base::FilePath& shortcut_filename) {
   base::FilePath desktop_path;
   bool result = false;
-  if (base::PathService::Get(base::DIR_USER_DESKTOP, &desktop_path))
-    result = base::DeleteFile(desktop_path.Append(shortcut_filename));
   return result;
 }
 
 bool DeleteShortcutInApplicationsMenu(
     const base::FilePath& shortcut_filename,
     const base::FilePath& directory_filename) {
-  std::vector<std::string> argv;
-  argv.push_back("xdg-desktop-menu");
-  argv.push_back("uninstall");
-
-  // Uninstall in user mode, to match the install.
-  argv.push_back("--mode");
-  argv.push_back("user");
-
-  // The file does not need to exist anywhere - xdg-desktop-menu will uninstall
-  // items from the menu with a matching name.
-  // If |directory_filename| is supplied, this will also remove the item from
-  // the directory, and remove the directory if it is empty.
-  if (!directory_filename.empty())
-    argv.push_back(directory_filename.value());
-  argv.push_back(shortcut_filename.value());
-  int exit_code;
-  return shell_integration_linux::LaunchXdgUtility(argv, &exit_code);
+  return false;
 }
 
 bool CreateDesktopShortcut(const ShortcutInfo& shortcut_info,
                            const ShortcutLocations& creation_locations) {
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-
-  base::FilePath shortcut_filename;
-  if (!shortcut_info.extension_id.empty()) {
-    shortcut_filename = GetAppShortcutFilename(shortcut_info.profile_path,
-                                               shortcut_info.extension_id);
-    // For extensions we do not want duplicate shortcuts. So, delete any that
-    // already exist and replace them.
-    if (creation_locations.on_desktop)
-      DeleteShortcutOnDesktop(shortcut_filename);
-
-    if (creation_locations.applications_menu_location !=
-        APP_MENU_LOCATION_NONE) {
-      DeleteShortcutInApplicationsMenu(shortcut_filename, base::FilePath());
-    }
-  } else {
-    shortcut_filename =
-        shell_integration_linux::GetWebShortcutFilename(shortcut_info.url);
-  }
-  if (shortcut_filename.empty()) {
-    RecordCreateShortcut(CreateShortcutResult::kFailToGetShortcutFilename);
-    return false;
-  }
-
-  std::string icon_name =
-      CreateShortcutIcon(shortcut_info.favicon, shortcut_filename);
-
-  std::string app_name = GenerateApplicationNameFromInfo(shortcut_info);
-
-  bool success = true;
-
-  base::FilePath chrome_exe_path =
-      shell_integration_linux::internal::GetChromeExePath();
-  if (chrome_exe_path.empty()) {
-    RecordCreateShortcut(CreateShortcutResult::kFailToGetChromeExePath);
-    NOTREACHED();
-    return false;
-  }
-
-  if (creation_locations.on_desktop) {
-    std::string contents = shell_integration_linux::GetDesktopFileContents(
-        chrome_exe_path, app_name, shortcut_info.url,
-        shortcut_info.extension_id, shortcut_info.title, icon_name,
-        shortcut_info.profile_path, "", "", false);
-    success = CreateShortcutOnDesktop(shortcut_filename, contents);
-  }
-
-  if (creation_locations.applications_menu_location == APP_MENU_LOCATION_NONE) {
-    return success;
-  }
-
-  base::FilePath directory_filename;
-  std::string directory_contents;
-  switch (creation_locations.applications_menu_location) {
-    case APP_MENU_LOCATION_HIDDEN:
-      break;
-    case APP_MENU_LOCATION_SUBDIR_CHROMEAPPS:
-      directory_filename = base::FilePath(kDirectoryFilename);
-      directory_contents = shell_integration_linux::GetDirectoryFileContents(
-          shell_integration::GetAppShortcutsSubdirName(), "");
-      break;
-    default:
-      NOTREACHED();
-      break;
-  }
-
-  std::vector<std::string> mime_types(
-      shortcut_info.file_handler_mime_types.begin(),
-      shortcut_info.file_handler_mime_types.end());
-
-  // Set NoDisplay=true if hidden. This will hide the application from
-  // user-facing menus.
-  std::string contents = shell_integration_linux::GetDesktopFileContents(
-      chrome_exe_path, app_name, shortcut_info.url, shortcut_info.extension_id,
-      shortcut_info.title, icon_name, shortcut_info.profile_path, "",
-      base::JoinString(mime_types, ";"),
-      creation_locations.applications_menu_location ==
-          APP_MENU_LOCATION_HIDDEN);
-  success = CreateShortcutInApplicationsMenu(shortcut_filename, contents,
-                                             directory_filename,
-                                             directory_contents) &&
-            success;
-  if (success) {
-    RecordCreateShortcut(CreateShortcutResult::kSuccess);
-  }
-  return success;
+  return false;
 }
 
 ShortcutLocations GetExistingShortcutLocations(
@@ -421,31 +84,7 @@ ShortcutLocations GetExistingShortcutLoc
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
 
-  base::FilePath shortcut_filename =
-      GetAppShortcutFilename(profile_path, extension_id);
-  DCHECK(!shortcut_filename.empty());
   ShortcutLocations locations;
-
-  // Determine whether there is a shortcut on desktop.
-  if (!desktop_path.empty()) {
-    locations.on_desktop =
-        base::PathExists(desktop_path.Append(shortcut_filename));
-  }
-
-  // Determine whether there is a shortcut in the applications directory.
-  std::string shortcut_contents;
-  if (shell_integration_linux::GetExistingShortcutContents(
-          env, shortcut_filename, &shortcut_contents)) {
-    // If the shortcut contents contain NoDisplay=true, it should be hidden.
-    // Otherwise since these shortcuts are for apps, they are always in the
-    // "Chrome Apps" directory.
-    locations.applications_menu_location =
-        shell_integration_linux::internal::GetNoDisplayFromDesktopFile(
-            shortcut_contents)
-            ? APP_MENU_LOCATION_HIDDEN
-            : APP_MENU_LOCATION_SUBDIR_CHROMEAPPS;
-  }
-
   return locations;
 }
 
@@ -454,52 +93,13 @@ bool DeleteDesktopShortcuts(const base::
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
 
-  base::FilePath shortcut_filename =
-      GetAppShortcutFilename(profile_path, extension_id);
-  DCHECK(!shortcut_filename.empty());
-
-  bool deleted_from_desktop = DeleteShortcutOnDesktop(shortcut_filename);
-  // Delete shortcuts from |kDirectoryFilename|.
-  // Note that it is possible that shortcuts were not created in the Chrome Apps
-  // directory. It doesn't matter: this will still delete the shortcut even if
-  // it isn't in the directory.
-  bool deleted_from_application_menu = DeleteShortcutInApplicationsMenu(
-      shortcut_filename, base::FilePath(kDirectoryFilename));
-  return (deleted_from_desktop && deleted_from_application_menu);
+  return false;
 }
 
 bool DeleteAllDesktopShortcuts(const base::FilePath& profile_path) {
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
-
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  bool result = true;
-  // Delete shortcuts from Desktop.
-  base::FilePath desktop_path;
-  if (base::PathService::Get(base::DIR_USER_DESKTOP, &desktop_path)) {
-    std::vector<base::FilePath> shortcut_filenames_desktop =
-        shell_integration_linux::GetExistingProfileShortcutFilenames(
-            profile_path, desktop_path);
-    for (const auto& shortcut : shortcut_filenames_desktop) {
-      if (!DeleteShortcutOnDesktop(shortcut))
-        result = false;
-    }
-  }
-
-  // Delete shortcuts from |kDirectoryFilename|.
-  base::FilePath applications_menu =
-      shell_integration_linux::GetDataWriteLocation(env.get());
-  applications_menu = applications_menu.AppendASCII("applications");
-  std::vector<base::FilePath> shortcut_filenames_app_menu =
-      shell_integration_linux::GetExistingProfileShortcutFilenames(
-          profile_path, applications_menu);
-  for (const auto& menu : shortcut_filenames_app_menu) {
-    if (!DeleteShortcutInApplicationsMenu(menu,
-                                          base::FilePath(kDirectoryFilename))) {
-      result = false;
-    }
-  }
-  return result;
+  return false;
 }
 
 namespace internals {
@@ -508,20 +108,13 @@ bool CreatePlatformShortcuts(const base:
                              const ShortcutLocations& creation_locations,
                              ShortcutCreationReason /*creation_reason*/,
                              const ShortcutInfo& shortcut_info) {
-#if !defined(OS_CHROMEOS)
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  return CreateDesktopShortcut(shortcut_info, creation_locations);
-#else
   return false;
-#endif
 }
 
 bool DeletePlatformShortcuts(const base::FilePath& web_app_path,
                              const ShortcutInfo& shortcut_info) {
 #if !defined(OS_CHROMEOS)
-  return DeleteDesktopShortcuts(shortcut_info.profile_path,
-                                shortcut_info.extension_id);
+  return false;
 #endif
   return true;
 }
@@ -531,27 +124,9 @@ void UpdatePlatformShortcuts(const base:
                              const ShortcutInfo& shortcut_info) {
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
-
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-
-  // Find out whether shortcuts are already installed.
-  ShortcutLocations creation_locations = GetExistingShortcutLocations(
-      env.get(), shortcut_info.profile_path, shortcut_info.extension_id);
-
-  // Always create a hidden shortcut in applications if a visible one is not
-  // being created. This allows the operating system to identify the app, but
-  // not show it in the menu.
-  if (creation_locations.applications_menu_location == APP_MENU_LOCATION_NONE)
-    creation_locations.applications_menu_location = APP_MENU_LOCATION_HIDDEN;
-
-  CreatePlatformShortcuts(web_app_path, creation_locations,
-                          SHORTCUT_CREATION_AUTOMATED, shortcut_info);
 }
 
 void DeleteAllShortcutsForProfile(const base::FilePath& profile_path) {
-#if !defined(OS_CHROMEOS)
-  DeleteAllDesktopShortcuts(profile_path);
-#endif
 }
 
 }  // namespace internals
--- a/chrome/browser/web_applications/components/web_app_shortcut_linux.h
+++ b/chrome/browser/web_applications/components/web_app_shortcut_linux.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_LINUX_H_
-#define CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_LINUX_H_
+#ifndef CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
+#define CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
 
 #include <string>
 
@@ -60,4 +60,4 @@ bool DeleteAllDesktopShortcuts(const bas
 
 }  // namespace web_app
 
-#endif  // CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_LINUX_H_
+#endif  // CHROME_BROWSER_WEB_APPLICATIONS_COMPONENTS_WEB_APP_SHORTCUT_ANDROID_H_
--- a/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_linux.cc
+++ b/chrome/browser/apps/platform_apps/api/music_manager_private/device_id_linux.cc
@@ -37,12 +37,6 @@ const char kDiskByUuidDirectoryName[] =
 const char* const kDeviceNames[] = {
     "sda1", "hda1", "dm-0", "xvda1", "sda2", "hda2", "dm-1", "xvda2",
 };
-// Fedora 15 uses biosdevname feature where Embedded ethernet uses the
-// "em" prefix and PCI cards use the p[0-9]c[0-9] format based on PCI
-// slot and card information.
-const char* const kNetDeviceNamePrefixes[] = {
-    "eth", "em", "en", "wl", "ww", "p0", "p1", "p2",
-    "p3",  "p4", "p5", "p6", "p7", "p8", "p9", "wlan"};
 
 // Map from device name to disk uuid
 typedef std::map<base::FilePath, base::FilePath> DiskEntries;
@@ -152,21 +146,13 @@ std::string GetMacAddress(IsValidMacAddr
   base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
                                                 base::BlockingType::MAY_BLOCK);
 
-  struct ifaddrs* ifaddrs;
-  int rv = getifaddrs(&ifaddrs);
+  int rv = -1;
   if (rv < 0) {
     PLOG(ERROR) << "getifaddrs failed " << rv;
     return "";
   }
 
   MacAddressProcessor processor(std::move(is_valid_mac_address));
-  for (struct ifaddrs* ifa = ifaddrs; ifa; ifa = ifa->ifa_next) {
-    bool keep_going = processor.ProcessInterface(
-        ifa, kNetDeviceNamePrefixes, base::size(kNetDeviceNamePrefixes));
-    if (!keep_going)
-      break;
-  }
-  freeifaddrs(ifaddrs);
   return processor.mac_address();
 }
 
--- a/chrome/browser/extensions/system_display/display_info_provider_aura.cc
+++ b/chrome/browser/extensions/system_display/display_info_provider_aura.cc
@@ -8,10 +8,10 @@
 
 namespace extensions {
 
-DisplayInfoProviderAura::DisplayInfoProviderAura() = default;
+DisplayInfoProviderAndroid::DisplayInfoProviderAndroid() = default;
 
 std::unique_ptr<DisplayInfoProvider> CreateChromeDisplayInfoProvider() {
-  return std::make_unique<DisplayInfoProviderAura>();
+  return std::make_unique<DisplayInfoProviderAndroid>();
 }
 
 }  // namespace extensions
--- a/chrome/browser/extensions/system_display/display_info_provider_aura.h
+++ b/chrome/browser/extensions/system_display/display_info_provider_aura.h
@@ -2,22 +2,22 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_AURA_H_
-#define CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_AURA_H_
+#ifndef CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
+#define CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
 
 #include "base/macros.h"
 #include "extensions/browser/api/system_display/display_info_provider.h"
 
 namespace extensions {
 
-class DisplayInfoProviderAura : public DisplayInfoProvider {
+class DisplayInfoProviderAndroid : public DisplayInfoProvider {
  public:
-  DisplayInfoProviderAura();
+  DisplayInfoProviderAndroid();
 
  private:
-  DISALLOW_COPY_AND_ASSIGN(DisplayInfoProviderAura);
+  DISALLOW_COPY_AND_ASSIGN(DisplayInfoProviderAndroid);
 };
 
 }  // namespace extensions
 
-#endif  // CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_AURA_H_
+#endif  // CHROME_BROWSER_EXTENSIONS_SYSTEM_DISPLAY_DISPLAY_INFO_PROVIDER_ANDROID_H_
--- a/chrome/browser/ui/views/accelerator_utils_aura.cc
+++ b/chrome/browser/ui/views/accelerator_utils_aura.cc
@@ -8,23 +8,9 @@
 #include "chrome/browser/ui/views/frame/browser_view.h"
 #include "ui/base/accelerators/accelerator.h"
 
-#if defined(OS_CHROMEOS)
-#include "ash/public/cpp/accelerators.h"
-#endif
-
 namespace chrome {
 
 bool IsChromeAccelerator(const ui::Accelerator& accelerator) {
-#if defined(OS_CHROMEOS)
-  for (size_t i = 0; i < ash::kAcceleratorDataLength; ++i) {
-    const ash::AcceleratorData& accel_data = ash::kAcceleratorData[i];
-    if (accel_data.keycode == accelerator.key_code() &&
-        accel_data.modifiers == accelerator.modifiers()) {
-      return true;
-    }
-  }
-#endif
-
   const std::vector<AcceleratorMapping> accelerators = GetAcceleratorList();
   for (const auto& entry : accelerators) {
     if (entry.keycode == accelerator.key_code() &&
--- a/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_linux.cc
+++ b/chrome/browser/extensions/api/image_writer_private/removable_storage_provider_linux.cc
@@ -10,115 +10,11 @@
 #include "chrome/browser/extensions/api/image_writer_private/removable_storage_provider.h"
 #include "content/public/browser/browser_thread.h"
 
-#if defined(USE_UDEV)
-#include "device/udev_linux/scoped_udev.h"
-#endif
-
 namespace extensions {
-// TODO(haven): Udev code may be duplicated in the Chrome codebase.
-// https://code.9oo91e.qjz9zk/p/chromium/issues/detail?id=284898
-
-#if defined(USE_UDEV)
-// Returns the integer contained in |attr|.  Returns 0 on error.
-static uint64_t get_int_attr(const char* attr) {
-  uint64_t result = 0;
-  // In error cases, StringToInt will set result to 0
-  base::StringToUint64(attr, &result);
-  return result;
-}
-
-static int get_device_blk_size(const std::string& path) {
-  base::FilePath file_path(path);
-  std::string device = file_path.BaseName().value();
-
-  base::FilePath info_file_path = base::FilePath("/sys/block")
-                                      .Append(device)
-                                      .Append("queue/logical_block_size");
-
-  std::string file_contents;
-  int blk_size;
-
-  if (!base::ReadFileToString(info_file_path, &file_contents)) {
-    return 0;
-  }
-  // In error cases, StringToInt will set blk_size to 0
-  base::StringToInt(file_contents, &blk_size);
-
-  return blk_size;
-}
-#endif  // defined(USE_UDEV)
-
 // static
 scoped_refptr<StorageDeviceList>
 RemovableStorageProvider::PopulateDeviceList() {
-#if defined(USE_UDEV)
-  device::ScopedUdevPtr udev(device::udev_new());
-  if (!udev) {
-    DLOG(ERROR) << "Can't create udev";
-    return nullptr;
-  }
-
-  auto device_list = base::MakeRefCounted<StorageDeviceList>();
-  /* Create a list of the devices in the 'block' subsystem. */
-  device::ScopedUdevEnumeratePtr enumerate(
-      device::udev_enumerate_new(udev.get()));
-
-  device::udev_enumerate_add_match_subsystem(enumerate.get(), "block");
-  device::udev_enumerate_scan_devices(enumerate.get());
-  udev_list_entry* devices =
-      device::udev_enumerate_get_list_entry(enumerate.get());
-
-  udev_list_entry* dev_list_entry;
-  udev_list_entry_foreach(dev_list_entry, devices) {
-    const char* path = device::udev_list_entry_get_name(dev_list_entry);
-    device::ScopedUdevDevicePtr cur_device(
-        device::udev_device_new_from_syspath(udev.get(), path));
-
-    const char* partition =
-        device::udev_device_get_sysattr_value(cur_device.get(), "partition");
-    if (partition && get_int_attr(partition)) {
-      // This is a partition of a device, not the device itself
-      continue;
-    }
-
-    const char* removable =
-        device::udev_device_get_sysattr_value(cur_device.get(), "removable");
-    if (!removable || !get_int_attr(removable)) {
-      // This is not a removable storage device.
-      continue;
-    }
-
-    /* Get the parent SCSI device that contains the model
-       and manufacturer.  You can look at the hierarchy with
-       udevadm info -a -n /dev/<device> */
-    udev_device* parent_device =
-        device::udev_device_get_parent_with_subsystem_devtype(
-            cur_device.get(), "scsi", NULL);
-    if (!parent_device) {
-      // this is not a usb device
-      continue;
-    }
-
-    api::image_writer_private::RemovableStorageDevice device_item;
-    device_item.vendor =
-        device::UdevDeviceGetSysattrValue(parent_device, "vendor");
-    device_item.model =
-        device::UdevDeviceGetSysattrValue(parent_device, "model");
-    // TODO (smaskell): Don't expose raw device path
-    device_item.storage_unit_id =
-        device::udev_device_get_devnode(cur_device.get());
-    device_item.capacity = get_int_attr(device::udev_device_get_sysattr_value(
-                               cur_device.get(), "size")) *
-                           get_device_blk_size(device_item.storage_unit_id);
-    device_item.removable = removable;
-
-    device_list->data.push_back(std::move(device_item));
-  }
-
-  return device_list;
-#else
   return nullptr;
-#endif  // defined(USE_UDEV)
 }
 
 }  // namespace extensions
--- a/chrome/browser/ui/aura/native_window_tracker_aura.cc
+++ b/chrome/browser/ui/aura/native_window_tracker_aura.cc
@@ -4,32 +4,23 @@
 
 #include "chrome/browser/ui/aura/native_window_tracker_aura.h"
 
-#include "ui/aura/window.h"
+#include "ui/android/window_android.h"
 
-NativeWindowTrackerAura::NativeWindowTrackerAura(
+NativeWindowTrackerAndroid::NativeWindowTrackerAndroid(
     gfx::NativeWindow window)
     : window_(window) {
-  window->AddObserver(this);
 }
 
-NativeWindowTrackerAura::~NativeWindowTrackerAura() {
-  if (window_)
-    window_->RemoveObserver(this);
+NativeWindowTrackerAndroid::~NativeWindowTrackerAndroid() {
 }
 
-bool NativeWindowTrackerAura::WasNativeWindowClosed() const {
+bool NativeWindowTrackerAndroid::WasNativeWindowClosed() const {
   return window_ == nullptr;
 }
 
-void NativeWindowTrackerAura::OnWindowDestroying(
-    aura::Window* window) {
-  window_->RemoveObserver(this);
-  window_ = nullptr;
-}
-
 // static
 std::unique_ptr<NativeWindowTracker> NativeWindowTracker::Create(
     gfx::NativeWindow window) {
   return std::unique_ptr<NativeWindowTracker>(
-      new NativeWindowTrackerAura(window));
+      new NativeWindowTrackerAndroid(window));
 }
--- a/chrome/browser/ui/aura/native_window_tracker_aura.h
+++ b/chrome/browser/ui/aura/native_window_tracker_aura.h
@@ -2,29 +2,26 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef CHROME_BROWSER_UI_AURA_NATIVE_WINDOW_TRACKER_AURA_H_
-#define CHROME_BROWSER_UI_AURA_NATIVE_WINDOW_TRACKER_AURA_H_
+#ifndef CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_ANDROID_H_
+#define CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_ANDROID_H_
 
 #include "base/macros.h"
 #include "chrome/browser/ui/native_window_tracker.h"
-#include "ui/aura/window_observer.h"
+#include "ui/android/window_android.h"
 
-class NativeWindowTrackerAura : public NativeWindowTracker,
-                                public aura::WindowObserver {
+class NativeWindowTrackerAndroid : public NativeWindowTracker {
  public:
-  explicit NativeWindowTrackerAura(gfx::NativeWindow window);
-  ~NativeWindowTrackerAura() override;
+  explicit NativeWindowTrackerAndroid(gfx::NativeWindow window);
+  ~NativeWindowTrackerAndroid() override;
 
   // NativeWindowTracker:
   bool WasNativeWindowClosed() const override;
 
  private:
-  // aura::WindowObserver:
-  void OnWindowDestroying(aura::Window* window) override;
 
-  aura::Window* window_;
+  ui::WindowAndroid* window_;
 
-  DISALLOW_COPY_AND_ASSIGN(NativeWindowTrackerAura);
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowTrackerAndroid);
 };
 
-#endif  // CHROME_BROWSER_UI_AURA_NATIVE_WINDOW_TRACKER_AURA_H_
+#endif  // CHROME_BROWSER_UI_ANDROID_NATIVE_WINDOW_TRACKER_AURA_H_
--- a/chrome/browser/policy/browser_dm_token_storage_linux.cc
+++ b/chrome/browser/policy/browser_dm_token_storage_linux.cc
@@ -71,12 +71,12 @@ bool StoreDMTokenInUserDataDir(const std
 
 }  // namespace
 
-BrowserDMTokenStorageLinux::BrowserDMTokenStorageLinux()
+BrowserDMTokenStorageAndroid::BrowserDMTokenStorageAndroid()
     : task_runner_(base::ThreadPool::CreateTaskRunner({base::MayBlock()})) {}
 
-BrowserDMTokenStorageLinux::~BrowserDMTokenStorageLinux() {}
+BrowserDMTokenStorageAndroid::~BrowserDMTokenStorageAndroid() {}
 
-std::string BrowserDMTokenStorageLinux::InitClientId() {
+std::string BrowserDMTokenStorageAndroid::InitClientId() {
   if (!client_id_.empty())
     return client_id_;
 
@@ -106,7 +106,7 @@ std::string BrowserDMTokenStorageLinux::
   return client_id_;
 }
 
-std::string BrowserDMTokenStorageLinux::InitEnrollmentToken() {
+std::string BrowserDMTokenStorageAndroid::InitEnrollmentToken() {
   std::string enrollment_token;
   base::FilePath dir_policy_files_path;
 
@@ -125,7 +125,7 @@ std::string BrowserDMTokenStorageLinux::
       .as_string();
 }
 
-std::string BrowserDMTokenStorageLinux::InitDMToken() {
+std::string BrowserDMTokenStorageAndroid::InitDMToken() {
   base::FilePath token_file_path;
   if (!GetDmTokenFilePath(&token_file_path, InitClientId(), false))
     return std::string();
@@ -137,7 +137,7 @@ std::string BrowserDMTokenStorageLinux::
   return base::TrimWhitespaceASCII(token, base::TRIM_ALL).as_string();
 }
 
-bool BrowserDMTokenStorageLinux::InitEnrollmentErrorOption() {
+bool BrowserDMTokenStorageAndroid::InitEnrollmentErrorOption() {
   std::string options;
   base::FilePath dir_policy_files_path;
 
@@ -156,18 +156,18 @@ bool BrowserDMTokenStorageLinux::InitEnr
          kEnrollmentMandatoryOption;
 }
 
-BrowserDMTokenStorage::StoreTask BrowserDMTokenStorageLinux::SaveDMTokenTask(
+BrowserDMTokenStorage::StoreTask BrowserDMTokenStorageAndroid::SaveDMTokenTask(
     const std::string& token,
     const std::string& client_id) {
   return base::BindOnce(&StoreDMTokenInUserDataDir, token, client_id);
 }
 
 scoped_refptr<base::TaskRunner>
-BrowserDMTokenStorageLinux::SaveDMTokenTaskRunner() {
+BrowserDMTokenStorageAndroid::SaveDMTokenTaskRunner() {
   return task_runner_;
 }
 
-std::string BrowserDMTokenStorageLinux::ReadMachineIdFile() {
+std::string BrowserDMTokenStorageAndroid::ReadMachineIdFile() {
   std::string machine_id;
   if (!base::ReadFileToString(base::FilePath(kMachineIdFilename), &machine_id))
     return std::string();
--- a/chrome/browser/policy/browser_dm_token_storage_linux.h
+++ b/chrome/browser/policy/browser_dm_token_storage_linux.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_LINUX_H_
-#define CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_LINUX_H_
+#ifndef CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
+#define CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
 
 #include "components/enterprise/browser/controller/browser_dm_token_storage.h"
 
@@ -18,11 +18,11 @@
 
 namespace policy {
 
-// Implementation of BrowserDMTokenStorage delegate for Linux.
-class BrowserDMTokenStorageLinux : public BrowserDMTokenStorage::Delegate {
+// Implementation of BrowserDMTokenStorage delegate for Android.
+class BrowserDMTokenStorageAndroid : public BrowserDMTokenStorage::Delegate {
  public:
-  BrowserDMTokenStorageLinux();
-  ~BrowserDMTokenStorageLinux() override;
+  BrowserDMTokenStorageAndroid();
+  ~BrowserDMTokenStorageAndroid() override;
 
  private:
   // override BrowserDMTokenStorage::Delegate
@@ -42,15 +42,15 @@ class BrowserDMTokenStorageLinux : publi
   std::string client_id_;
   scoped_refptr<base::TaskRunner> task_runner_;
 
-  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageLinuxTest, InitClientId);
-  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageLinuxTest, InitEnrollmentToken);
-  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageLinuxTest, InitDMToken);
-  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageLinuxTest,
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitClientId);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitEnrollmentToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, InitDMToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest,
                            InitDMTokenWithoutDirectory);
-  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageLinuxTest, SaveDMToken);
+  FRIEND_TEST_ALL_PREFIXES(BrowserDMTokenStorageAndroidTest, SaveDMToken);
 
-  DISALLOW_COPY_AND_ASSIGN(BrowserDMTokenStorageLinux);
+  DISALLOW_COPY_AND_ASSIGN(BrowserDMTokenStorageAndroid);
 };
 
 }  // namespace policy
-#endif  // CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_LINUX_H_
+#endif  // CHROME_BROWSER_POLICY_BROWSER_DM_TOKEN_STORAGE_ANDROID_H_
--- a/chrome/browser/extensions/global_shortcut_listener_ozone.cc
+++ b/chrome/browser/extensions/global_shortcut_listener_ozone.cc
@@ -13,12 +13,12 @@ namespace extensions {
 // static
 GlobalShortcutListener* GlobalShortcutListener::GetInstance() {
   CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
-  static GlobalShortcutListenerOzone* instance =
-      new GlobalShortcutListenerOzone();
+  static GlobalShortcutListenerAndroid* instance =
+      new GlobalShortcutListenerAndroid();
   return instance;
 }
 
-GlobalShortcutListenerOzone::GlobalShortcutListenerOzone()
+GlobalShortcutListenerAndroid::GlobalShortcutListenerAndroid()
     : is_listening_(false) {
   CHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
 
@@ -26,39 +26,28 @@ GlobalShortcutListenerOzone::GlobalShort
   LOG(ERROR) << "GlobalShortcutListenerOzone object created";
 }
 
-GlobalShortcutListenerOzone::~GlobalShortcutListenerOzone() {
+GlobalShortcutListenerAndroid::~GlobalShortcutListenerAndroid() {
   if (is_listening_)
     StopListening();
 }
 
-void GlobalShortcutListenerOzone::StartListening() {
+void GlobalShortcutListenerAndroid::StartListening() {
   DCHECK(!is_listening_);  // Don't start twice.
-  NOTIMPLEMENTED();
   is_listening_ = true;
 }
 
-void GlobalShortcutListenerOzone::StopListening() {
+void GlobalShortcutListenerAndroid::StopListening() {
   DCHECK(is_listening_);  // No point if we are not already listening.
-  NOTIMPLEMENTED();
   is_listening_ = false;
 }
 
-bool GlobalShortcutListenerOzone::RegisterAcceleratorImpl(
+bool GlobalShortcutListenerAndroid::RegisterAcceleratorImpl(
     const ui::Accelerator& accelerator) {
-  NOTIMPLEMENTED();
-  // To implement:
-  // 1) Convert modifiers to platform specific modifiers.
-  // 2) Register for the hotkey.
-  // 3) If not successful, return false.
-  // 4) Else, return true.
-
   return false;
 }
 
-void GlobalShortcutListenerOzone::UnregisterAcceleratorImpl(
+void GlobalShortcutListenerAndroid::UnregisterAcceleratorImpl(
     const ui::Accelerator& accelerator) {
-  NOTIMPLEMENTED();
-  // To implement: Unregister for the hotkey.
 }
 
 }  // namespace extensions
--- a/chrome/browser/extensions/global_shortcut_listener_ozone.h
+++ b/chrome/browser/extensions/global_shortcut_listener_ozone.h
@@ -2,21 +2,21 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_OZONE_H_
-#define CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_OZONE_H_
+#ifndef CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
+#define CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
 
 #include "base/macros.h"
 #include "chrome/browser/extensions/global_shortcut_listener.h"
 
 namespace extensions {
 
-// Ozone-specific implementation of the GlobalShortcutListener class that
+// Android-specific implementation of the GlobalShortcutListener class that
 // listens for global shortcuts. Handles basic keyboard intercepting and
 // forwards its output to the base class for processing.
-class GlobalShortcutListenerOzone : public GlobalShortcutListener {
+class GlobalShortcutListenerAndroid : public GlobalShortcutListener {
  public:
-  GlobalShortcutListenerOzone();
-  ~GlobalShortcutListenerOzone() override;
+  GlobalShortcutListenerAndroid();
+  ~GlobalShortcutListenerAndroid() override;
 
  private:
   // GlobalShortcutListener implementation.
@@ -28,9 +28,9 @@ class GlobalShortcutListenerOzone : publ
   // Whether this object is listening for global shortcuts.
   bool is_listening_;
 
-  DISALLOW_COPY_AND_ASSIGN(GlobalShortcutListenerOzone);
+  DISALLOW_COPY_AND_ASSIGN(GlobalShortcutListenerAndroid);
 };
 
 }  // namespace extensions
 
-#endif  // CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_OZONE_H_
+#endif  // CHROME_BROWSER_EXTENSIONS_GLOBAL_SHORTCUT_LISTENER_ANDROID_H_
--- a/chrome/browser/ui/views/dropdown_bar_host_aura.cc
+++ b/chrome/browser/ui/views/dropdown_bar_host_aura.cc
@@ -4,10 +4,8 @@
 
 #include "chrome/browser/ui/views/dropdown_bar_host.h"
 
-#include "ui/aura/window.h"
-#include "ui/views/view_constants_aura.h"
+#include "ui/android/window_android.h"
 #include "ui/views/widget/widget.h"
 
 void DropdownBarHost::SetHostViewNative(views::View* host_view) {
-  host_->GetNativeView()->SetProperty(views::kHostViewKey, host_view);
 }
--- a/ui/views/widget/native_widget_aura.cc
+++ b/ui/views/widget/native_widget_aura.cc
@@ -13,19 +13,6 @@
 #include "base/strings/string_util.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "build/build_config.h"
-#include "ui/aura/client/aura_constants.h"
-#include "ui/aura/client/capture_client.h"
-#include "ui/aura/client/cursor_client.h"
-#include "ui/aura/client/drag_drop_client.h"
-#include "ui/aura/client/focus_client.h"
-#include "ui/aura/client/screen_position_client.h"
-#include "ui/aura/client/window_parenting_client.h"
-#include "ui/aura/client/window_types.h"
-#include "ui/aura/env.h"
-#include "ui/aura/window.h"
-#include "ui/aura/window_event_dispatcher.h"
-#include "ui/aura/window_observer.h"
-#include "ui/aura/window_tree_host.h"
 #include "ui/base/class_property.h"
 #include "ui/base/dragdrop/os_exchange_data.h"
 #include "ui/base/ui_base_types.h"
@@ -34,7 +21,7 @@
 #include "ui/display/screen.h"
 #include "ui/events/event.h"
 #include "ui/gfx/canvas.h"
-#include "ui/native_theme/native_theme_aura.h"
+#include "ui/native_theme/native_theme_android.h"
 #include "ui/views/buildflags.h"
 #include "ui/views/drag_utils.h"
 #include "ui/views/views_delegate.h"
@@ -55,21 +42,6 @@
 #include "ui/wm/public/activation_client.h"
 #include "ui/wm/public/window_move_client.h"
 
-#if BUILDFLAG(ENABLE_DESKTOP_AURA)
-#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
-#include "ui/views/widget/desktop_aura/desktop_window_tree_host.h"
-#endif
-
-#if defined(OS_WIN)
-#include "ui/views/widget/desktop_aura/desktop_window_tree_host_win.h"
-#endif
-
-#if BUILDFLAG(ENABLE_DESKTOP_AURA) && \
-    (defined(OS_LINUX) || defined(OS_CHROMEOS))
-#include "ui/views/linux_ui/linux_ui.h"
-#include "ui/views/widget/desktop_aura/desktop_window_tree_host_linux.h"
-#endif
-
 DEFINE_UI_CLASS_PROPERTY_TYPE(views::internal::NativeWidgetPrivate*)
 
 namespace views {
@@ -80,163 +52,76 @@ DEFINE_UI_CLASS_PROPERTY_KEY(internal::N
                              kNativeWidgetPrivateKey,
                              nullptr)
 
-void SetRestoreBounds(aura::Window* window, const gfx::Rect& bounds) {
-  window->SetProperty(aura::client::kRestoreBoundsKey, bounds);
+void SetRestoreBounds(gfx::NativeWindow window, const gfx::Rect& bounds) {
 }
 
-void SetIcon(aura::Window* window,
+void SetIcon(gfx::NativeWindow window,
              const aura::WindowProperty<gfx::ImageSkia*>* key,
              const gfx::ImageSkia& value) {
-  if (value.isNull())
-    window->ClearProperty(key);
-  else
-    window->SetProperty(key, value);
 }
 
 }  // namespace
 
 ////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, public:
+// NativeWidgetAndroid, public:
 
-NativeWidgetAura::NativeWidgetAura(internal::NativeWidgetDelegate* delegate)
+NativeWidgetAndroid::NativeWidgetAndroid(internal::NativeWidgetDelegate* delegate)
     : delegate_(delegate),
-      window_(new aura::Window(this, aura::client::WINDOW_TYPE_UNKNOWN)),
       ownership_(Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET),
-      destroying_(false),
-      cursor_(gfx::kNullCursor) {
-  aura::client::SetFocusChangeObserver(window_, this);
-  wm::SetActivationChangeObserver(window_, this);
+      destroying_(false) {
 }
 
 // static
-void NativeWidgetAura::RegisterNativeWidgetForWindow(
-    internal::NativeWidgetPrivate* native_widget,
-    aura::Window* window) {
-  window->SetProperty(kNativeWidgetPrivateKey, native_widget);
+void NativeWidgetAndroid::RegisterNativeWidgetForWindow(
+      internal::NativeWidgetPrivate* native_widget,
+      gfx::NativeWindow window) {
 }
 
 // static
-void NativeWidgetAura::AssignIconToAuraWindow(aura::Window* window,
+void NativeWidgetAndroid::AssignIconToAuraWindow(gfx::NativeWindow window,
                                               const gfx::ImageSkia& window_icon,
                                               const gfx::ImageSkia& app_icon) {
-  if (window) {
-    SetIcon(window, aura::client::kWindowIconKey, window_icon);
-    SetIcon(window, aura::client::kAppIconKey, app_icon);
-  }
 }
 
 // static
-void NativeWidgetAura::SetShadowElevationFromInitParams(
-    aura::Window* window,
+void NativeWidgetAndroid::SetShadowElevationFromInitParams(
+    gfx::NativeWindow window,
     const Widget::InitParams& params) {
-  if (params.shadow_type == Widget::InitParams::ShadowType::kNone) {
-    wm::SetShadowElevation(window, wm::kShadowElevationNone);
-  } else if (params.shadow_type == Widget::InitParams::ShadowType::kDrop &&
-             params.shadow_elevation) {
-    wm::SetShadowElevation(window, *params.shadow_elevation);
-  }
 }
 
 // static
-void NativeWidgetAura::SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
-                                                     aura::Window* window) {
-  int behavior = aura::client::kResizeBehaviorNone;
-  if (delegate) {
-    if (delegate->CanResize())
-      behavior |= aura::client::kResizeBehaviorCanResize;
-    if (delegate->CanMaximize())
-      behavior |= aura::client::kResizeBehaviorCanMaximize;
-    if (delegate->CanMinimize())
-      behavior |= aura::client::kResizeBehaviorCanMinimize;
-  }
-  window->SetProperty(aura::client::kResizeBehaviorKey, behavior);
+void NativeWidgetAndroid::SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
+                                                     gfx::NativeWindow window) {
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, internal::NativeWidgetPrivate implementation:
+// NativeWidgetAndroid, internal::NativeWidgetPrivate implementation:
 
-void NativeWidgetAura::InitNativeWidget(Widget::InitParams params) {
+void NativeWidgetAndroid::InitNativeWidget(Widget::InitParams params) {
   // See Widget::InitParams::context for details.
   DCHECK(params.parent || params.context);
 
   ownership_ = params.ownership;
 
-  window_->AcquireAllPropertiesFrom(
-      std::move(params.init_properties_container));
-
   RegisterNativeWidgetForWindow(this, window_);
-  window_->SetType(GetAuraWindowTypeForWidgetType(params.type));
-  if (params.corner_radius) {
-    window_->SetProperty(aura::client::kWindowCornerRadiusKey,
-                         *params.corner_radius);
-  }
-  window_->SetProperty(aura::client::kShowStateKey, params.show_state);
-  if (params.type == Widget::InitParams::TYPE_BUBBLE)
-    wm::SetHideOnDeactivate(window_, true);
-  window_->SetTransparent(params.opacity ==
-                          Widget::InitParams::WindowOpacity::kTranslucent);
-
   // Check for ShadowType::kNone before aura::Window::Init() to ensure observers
   // do not add useless shadow layers by deriving one from the window type.
   SetShadowElevationFromInitParams(window_, params);
 
-  window_->Init(params.layer_type);
-  // Set name after layer init so it propagates to layer.
-  window_->SetName(params.name.empty() ? "NativeWidgetAura" : params.name);
-  if (params.type == Widget::InitParams::TYPE_CONTROL)
-    window_->Show();
-
   delegate_->OnNativeWidgetCreated();
 
   gfx::Rect window_bounds = params.bounds;
   gfx::NativeView parent = params.parent;
   gfx::NativeView context = params.context;
   if (!params.child) {
-    // Set up the transient child before the window is added. This way the
-    // LayoutManager knows the window has a transient parent.
-    if (parent && parent->type() != aura::client::WINDOW_TYPE_UNKNOWN) {
-      wm::AddTransientChild(parent, window_);
-      if (!context)
-        context = parent;
-      parent = nullptr;
-
-      // Generally transient bubbles are showing state associated to the parent
-      // window. Make sure the transient bubble is only visible if the parent is
-      // visible, otherwise the bubble may not make sense by itself.
-      if (params.type == Widget::InitParams::TYPE_BUBBLE) {
-        wm::TransientWindowManager::GetOrCreate(window_)
-            ->set_parent_controls_visibility(true);
-      }
-    }
     // SetZOrderLevel before SetParent so that always-on-top container is used.
     SetZOrderLevel(params.EffectiveZOrderLevel());
-
-    // Make sure we have a real |window_bounds|.
-    aura::Window* parent_or_context = parent ? parent : context;
-    if (parent_or_context && window_bounds == gfx::Rect()) {
-      // If a parent or context is specified but no bounds are given, use the
-      // origin of the display so that the widget will be added to the same
-      // display as the parent or context.
-      gfx::Rect bounds = display::Screen::GetScreen()
-                             ->GetDisplayNearestWindow(parent_or_context)
-                             .bounds();
-      window_bounds.set_origin(bounds.origin());
-    }
   }
 
   // Set properties before adding to the parent so that its layout manager sees
   // the correct values.
   OnSizeConstraintsChanged();
 
-  if (parent) {
-    parent->AddChild(window_);
-  } else {
-    aura::client::ParentWindowWithContext(window_, context->GetRootWindow(),
-                                          window_bounds);
-  }
-
-  window_->AddObserver(this);
-
   // Wait to set the bounds until we have a parent. That way we can know our
   // true state/bounds (the LayoutManager may enforce a particular
   // state/bounds).
@@ -244,831 +129,305 @@ void NativeWidgetAura::InitNativeWidget(
     SetRestoreBounds(window_, window_bounds);
   else
     SetBounds(window_bounds);
-  window_->SetEventTargetingPolicy(
-      params.accept_events ? aura::EventTargetingPolicy::kTargetAndDescendants
-                           : aura::EventTargetingPolicy::kNone);
   DCHECK(GetWidget()->GetRootView());
-  if (params.type != Widget::InitParams::TYPE_TOOLTIP)
-    tooltip_manager_ = std::make_unique<views::TooltipManagerAura>(GetWidget());
-
-  drop_helper_ = std::make_unique<DropHelper>(GetWidget()->GetRootView());
-  if (params.type != Widget::InitParams::TYPE_TOOLTIP &&
-      params.type != Widget::InitParams::TYPE_POPUP) {
-    aura::client::SetDragDropDelegate(window_, this);
-  }
-
-  if (params.type == Widget::InitParams::TYPE_WINDOW) {
-    focus_manager_event_handler_ =
-        std::make_unique<FocusManagerEventHandler>(GetWidget(), window_);
-  }
-
-  wm::SetActivationDelegate(window_, this);
-
-  window_reorderer_ =
-      std::make_unique<WindowReorderer>(window_, GetWidget()->GetRootView());
 }
 
-void NativeWidgetAura::OnWidgetInitDone() {}
+void NativeWidgetAndroid::OnWidgetInitDone() {}
 
 std::unique_ptr<NonClientFrameView>
-NativeWidgetAura::CreateNonClientFrameView() {
+NativeWidgetAndroid::CreateNonClientFrameView() {
   return nullptr;
 }
 
-bool NativeWidgetAura::ShouldUseNativeFrame() const {
+bool NativeWidgetAndroid::ShouldUseNativeFrame() const {
   // There is only one frame type for aura.
   return false;
 }
 
-bool NativeWidgetAura::ShouldWindowContentsBeTransparent() const {
+bool NativeWidgetAndroid::ShouldWindowContentsBeTransparent() const {
   return false;
 }
 
-void NativeWidgetAura::FrameTypeChanged() {
+void NativeWidgetAndroid::FrameTypeChanged() {
   // This is called when the Theme has changed; forward the event to the root
   // widget.
   GetWidget()->ThemeChanged();
   GetWidget()->GetRootView()->SchedulePaint();
 }
 
-Widget* NativeWidgetAura::GetWidget() {
+Widget* NativeWidgetAndroid::GetWidget() {
   return delegate_->AsWidget();
 }
 
-const Widget* NativeWidgetAura::GetWidget() const {
+const Widget* NativeWidgetAndroid::GetWidget() const {
   return delegate_->AsWidget();
 }
 
-gfx::NativeView NativeWidgetAura::GetNativeView() const {
+gfx::NativeView NativeWidgetAndroid::GetNativeView() const {
   return window_;
 }
 
-gfx::NativeWindow NativeWidgetAura::GetNativeWindow() const {
+gfx::NativeWindow NativeWidgetAndroid::GetNativeWindow() const {
   return window_;
 }
 
-Widget* NativeWidgetAura::GetTopLevelWidget() {
+Widget* NativeWidgetAndroid::GetTopLevelWidget() {
   NativeWidgetPrivate* native_widget = GetTopLevelNativeWidget(GetNativeView());
   return native_widget ? native_widget->GetWidget() : nullptr;
 }
 
-const ui::Compositor* NativeWidgetAura::GetCompositor() const {
-  return window_ ? window_->layer()->GetCompositor() : nullptr;
+const ui::Compositor* NativeWidgetAndroid::GetCompositor() const {
+  return nullptr;
 }
 
-const ui::Layer* NativeWidgetAura::GetLayer() const {
-  return window_ ? window_->layer() : nullptr;
+const ui::Layer* NativeWidgetAndroid::GetLayer() const {
+  return nullptr;
 }
 
-void NativeWidgetAura::ReorderNativeViews() {
-  window_reorderer_->ReorderChildWindows();
+void NativeWidgetAndroid::ReorderNativeViews() {
 }
 
-void NativeWidgetAura::ViewRemoved(View* view) {
+void NativeWidgetAndroid::ViewRemoved(View* view) {
   DCHECK(drop_helper_.get() != nullptr);
   drop_helper_->ResetTargetViewIfEquals(view);
 }
 
-void NativeWidgetAura::SetNativeWindowProperty(const char* name, void* value) {
-  if (window_)
-    window_->SetNativeWindowProperty(name, value);
+void NativeWidgetAndroid::SetNativeWindowProperty(const char* name, void* value) {
 }
 
-void* NativeWidgetAura::GetNativeWindowProperty(const char* name) const {
-  return window_ ? window_->GetNativeWindowProperty(name) : nullptr;
+void* NativeWidgetAndroid::GetNativeWindowProperty(const char* name) const {
+  return nullptr;
 }
 
-TooltipManager* NativeWidgetAura::GetTooltipManager() const {
+TooltipManager* NativeWidgetAndroid::GetTooltipManager() const {
   return tooltip_manager_.get();
 }
 
-void NativeWidgetAura::SetCapture() {
-  if (window_)
-    window_->SetCapture();
+void NativeWidgetAndroid::SetCapture() {
 }
 
-void NativeWidgetAura::ReleaseCapture() {
-  if (window_)
-    window_->ReleaseCapture();
+void NativeWidgetAndroid::ReleaseCapture() {
 }
 
-bool NativeWidgetAura::HasCapture() const {
-  return window_ && window_->HasCapture();
+bool NativeWidgetAndroid::HasCapture() const {
+  return false;
 }
 
-ui::InputMethod* NativeWidgetAura::GetInputMethod() {
-  if (!window_)
-    return nullptr;
-  aura::Window* root_window = window_->GetRootWindow();
-  return root_window ? root_window->GetHost()->GetInputMethod() : nullptr;
+ui::InputMethod* NativeWidgetAndroid::GetInputMethod() {
+  return nullptr;
 }
 
-void NativeWidgetAura::CenterWindow(const gfx::Size& size) {
-  if (!window_)
-    return;
-
-  window_->SetProperty(aura::client::kPreferredSize, size);
-
-  gfx::Rect parent_bounds(window_->parent()->GetBoundsInRootWindow());
-  // When centering window, we take the intersection of the host and
-  // the parent. We assume the root window represents the visible
-  // rect of a single screen.
-  gfx::Rect work_area = display::Screen::GetScreen()
-                            ->GetDisplayNearestWindow(window_)
-                            .work_area();
-
-  aura::client::ScreenPositionClient* screen_position_client =
-      aura::client::GetScreenPositionClient(window_->GetRootWindow());
-  if (screen_position_client) {
-    gfx::Point origin = work_area.origin();
-    screen_position_client->ConvertPointFromScreen(window_->GetRootWindow(),
-                                                   &origin);
-    work_area.set_origin(origin);
-  }
-
-  parent_bounds.Intersect(work_area);
-
-  // If |window_|'s transient parent's bounds are big enough to fit it, then we
-  // center it with respect to the transient parent.
-  if (wm::GetTransientParent(window_)) {
-    gfx::Rect transient_parent_rect =
-        wm::GetTransientParent(window_)->GetBoundsInRootWindow();
-    transient_parent_rect.Intersect(work_area);
-    if (transient_parent_rect.height() >= size.height() &&
-        transient_parent_rect.width() >= size.width())
-      parent_bounds = transient_parent_rect;
-  }
-
-  gfx::Rect window_bounds(
-      parent_bounds.x() + (parent_bounds.width() - size.width()) / 2,
-      parent_bounds.y() + (parent_bounds.height() - size.height()) / 2,
-      size.width(), size.height());
-  // Don't size the window bigger than the parent, otherwise the user may not be
-  // able to close or move it.
-  window_bounds.AdjustToFit(parent_bounds);
-
-  // Convert the bounds back relative to the parent.
-  gfx::Point origin = window_bounds.origin();
-  aura::Window::ConvertPointToTarget(window_->GetRootWindow(),
-                                     window_->parent(), &origin);
-  window_bounds.set_origin(origin);
-  window_->SetBounds(window_bounds);
+void NativeWidgetAndroid::CenterWindow(const gfx::Size& size) {
 }
 
-void NativeWidgetAura::GetWindowPlacement(
+void NativeWidgetAndroid::GetWindowPlacement(
     gfx::Rect* bounds,
     ui::WindowShowState* show_state) const {
-  // The interface specifies returning restored bounds, not current bounds.
-  *bounds = GetRestoredBounds();
-  *show_state = window_ ? window_->GetProperty(aura::client::kShowStateKey)
-                        : ui::SHOW_STATE_DEFAULT;
 }
 
-bool NativeWidgetAura::SetWindowTitle(const base::string16& title) {
-  if (!window_)
-    return false;
-  if (window_->GetTitle() == title)
-    return false;
-  window_->SetTitle(title);
+bool NativeWidgetAndroid::SetWindowTitle(const base::string16& title) {
   return true;
 }
 
-void NativeWidgetAura::SetWindowIcons(const gfx::ImageSkia& window_icon,
+void NativeWidgetAndroid::SetWindowIcons(const gfx::ImageSkia& window_icon,
                                       const gfx::ImageSkia& app_icon) {
-  AssignIconToAuraWindow(window_, window_icon, app_icon);
 }
 
-void NativeWidgetAura::InitModalType(ui::ModalType modal_type) {
-  if (modal_type != ui::MODAL_TYPE_NONE)
-    window_->SetProperty(aura::client::kModalKey, modal_type);
-  if (modal_type == ui::MODAL_TYPE_WINDOW) {
-    wm::TransientWindowManager::GetOrCreate(window_)
-        ->set_parent_controls_visibility(true);
-  }
+void NativeWidgetAndroid::InitModalType(ui::ModalType modal_type) {
 }
 
-gfx::Rect NativeWidgetAura::GetWindowBoundsInScreen() const {
-  return window_ ? window_->GetBoundsInScreen() : gfx::Rect();
+gfx::Rect NativeWidgetAndroid::GetWindowBoundsInScreen() const {
+  return gfx::Rect();
 }
 
-gfx::Rect NativeWidgetAura::GetClientAreaBoundsInScreen() const {
+gfx::Rect NativeWidgetAndroid::GetClientAreaBoundsInScreen() const {
   // View-to-screen coordinate system transformations depend on this returning
   // the full window bounds, for example View::ConvertPointToScreen().
-  return window_ ? window_->GetBoundsInScreen() : gfx::Rect();
+  return gfx::Rect();
 }
 
-gfx::Rect NativeWidgetAura::GetRestoredBounds() const {
-  if (!window_)
-    return gfx::Rect();
-
-  // Restored bounds should only be relevant if the window is minimized,
-  // maximized, or fullscreen. However, in some places the code expects
-  // GetRestoredBounds() to return the current window bounds if the window is
-  // not in either state.
-  if (IsMinimized() || IsMaximized() || IsFullscreen()) {
-    // Restore bounds are in screen coordinates, no need to convert.
-    gfx::Rect* restore_bounds =
-        window_->GetProperty(aura::client::kRestoreBoundsKey);
-    if (restore_bounds)
-      return *restore_bounds;
-  }
-
-  // Prefer getting the window bounds and converting them to screen bounds since
-  // Window::GetBoundsInScreen takes into the account the window transform.
-  auto* screen_position_client =
-      aura::client::GetScreenPositionClient(window_->GetRootWindow());
-  if (screen_position_client) {
-    // |window_|'s bounds are in parent's coordinate system so use that when
-    // converting.
-    gfx::Rect bounds = window_->bounds();
-    gfx::Point origin = bounds.origin();
-    screen_position_client->ConvertPointToScreenIgnoringTransforms(
-        window_->parent(), &origin);
-    return gfx::Rect(origin, bounds.size());
-  }
-
-  return window_->GetBoundsInScreen();
+gfx::Rect NativeWidgetAndroid::GetRestoredBounds() const {
+  return gfx::Rect();
 }
 
-std::string NativeWidgetAura::GetWorkspace() const {
+std::string NativeWidgetAndroid::GetWorkspace() const {
   return std::string();
 }
 
-void NativeWidgetAura::SetBounds(const gfx::Rect& bounds) {
-  if (!window_)
-    return;
-
-  aura::Window* root = window_->GetRootWindow();
-  if (root) {
-    aura::client::ScreenPositionClient* screen_position_client =
-        aura::client::GetScreenPositionClient(root);
-    if (screen_position_client) {
-      display::Display dst_display =
-          display::Screen::GetScreen()->GetDisplayMatching(bounds);
-      screen_position_client->SetBounds(window_, bounds, dst_display);
-      return;
-    }
-  }
-  window_->SetBounds(bounds);
+void NativeWidgetAndroid::SetBounds(const gfx::Rect& bounds) {
 }
 
-void NativeWidgetAura::SetBoundsConstrained(const gfx::Rect& bounds) {
-  if (!window_)
-    return;
-
-  gfx::Rect new_bounds(bounds);
-  if (window_->parent()) {
-    if (window_->parent()->GetProperty(wm::kUsesScreenCoordinatesKey)) {
-      new_bounds =
-          NativeWidgetPrivate::ConstrainBoundsToDisplayWorkArea(new_bounds);
-    } else {
-      new_bounds.AdjustToFit(gfx::Rect(window_->parent()->bounds().size()));
-    }
-  }
-  SetBounds(new_bounds);
+void NativeWidgetAndroid::SetBoundsConstrained(const gfx::Rect& bounds) {
 }
 
-void NativeWidgetAura::SetSize(const gfx::Size& size) {
-  if (window_)
-    window_->SetBounds(gfx::Rect(window_->bounds().origin(), size));
+void NativeWidgetAndroid::SetSize(const gfx::Size& size) {
 }
 
-void NativeWidgetAura::StackAbove(gfx::NativeView native_view) {
-  if (window_ && window_->parent() &&
-      window_->parent() == native_view->parent())
-    window_->parent()->StackChildAbove(window_, native_view);
+void NativeWidgetAndroid::StackAbove(gfx::NativeView native_view) {
 }
 
-void NativeWidgetAura::StackAtTop() {
-  if (window_)
-    window_->parent()->StackChildAtTop(window_);
+void NativeWidgetAndroid::StackAtTop() {
 }
 
-void NativeWidgetAura::SetShape(std::unique_ptr<Widget::ShapeRects> shape) {
-  if (window_)
-    window_->layer()->SetAlphaShape(std::move(shape));
+void NativeWidgetAndroid::SetShape(std::unique_ptr<Widget::ShapeRects> shape) {
 }
 
-void NativeWidgetAura::Close() {
+void NativeWidgetAndroid::Close() {
   // |window_| may already be deleted by parent window. This can happen
   // when this widget is child widget or has transient parent
   // and ownership is WIDGET_OWNS_NATIVE_WIDGET.
-  DCHECK(window_ ||
-         ownership_ == Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET);
-  if (window_) {
-    Hide();
-    window_->SetProperty(aura::client::kModalKey, ui::MODAL_TYPE_NONE);
-  }
-
-  if (!close_widget_factory_.HasWeakPtrs()) {
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::BindOnce(&NativeWidgetAura::CloseNow,
-                                  close_widget_factory_.GetWeakPtr()));
-  }
 }
 
-void NativeWidgetAura::CloseNow() {
-  delete window_;
+void NativeWidgetAndroid::CloseNow() {
 }
 
-void NativeWidgetAura::Show(ui::WindowShowState show_state,
+void NativeWidgetAndroid::Show(ui::WindowShowState show_state,
                             const gfx::Rect& restore_bounds) {
-  if (!window_)
-    return;
-
-  if (show_state == ui::SHOW_STATE_MAXIMIZED && !restore_bounds.IsEmpty())
-    SetRestoreBounds(window_, restore_bounds);
-  if (show_state == ui::SHOW_STATE_MAXIMIZED ||
-      show_state == ui::SHOW_STATE_FULLSCREEN) {
-    window_->SetProperty(aura::client::kShowStateKey, show_state);
-  }
-  window_->Show();
-  if (delegate_->CanActivate()) {
-    if (show_state != ui::SHOW_STATE_INACTIVE)
-      Activate();
-    // SetInitialFocus() should be always be called, even for
-    // SHOW_STATE_INACTIVE. If the window has to stay inactive, the method will
-    // do the right thing.
-    // Activate() might fail if the window is non-activatable. In this case, we
-    // should pass SHOW_STATE_INACTIVE to SetInitialFocus() to stop the initial
-    // focused view from getting focused. See crbug.com/515594 for example.
-    SetInitialFocus(IsActive() ? show_state : ui::SHOW_STATE_INACTIVE);
-  }
-
-  // On desktop aura, a window is activated first even when it is shown as
-  // minimized. Do the same for consistency.
-  if (show_state == ui::SHOW_STATE_MINIMIZED)
-    Minimize();
 }
 
-void NativeWidgetAura::Hide() {
-  if (window_)
-    window_->Hide();
+void NativeWidgetAndroid::Hide() {
 }
 
-bool NativeWidgetAura::IsVisible() const {
-  return window_ && window_->IsVisible();
+bool NativeWidgetAndroid::IsVisible() const {
+  return false;
 }
 
-void NativeWidgetAura::Activate() {
-  if (!window_)
-    return;
-
-  // We don't necessarily have a root window yet. This can happen with
-  // constrained windows.
-  if (window_->GetRootWindow())
-    wm::GetActivationClient(window_->GetRootWindow())->ActivateWindow(window_);
-  if (window_->GetProperty(aura::client::kDrawAttentionKey))
-    window_->SetProperty(aura::client::kDrawAttentionKey, false);
+void NativeWidgetAndroid::Activate() {
 }
 
-void NativeWidgetAura::Deactivate() {
-  if (!window_)
-    return;
-  wm::GetActivationClient(window_->GetRootWindow())->DeactivateWindow(window_);
+void NativeWidgetAndroid::Deactivate() {
 }
 
-bool NativeWidgetAura::IsActive() const {
-  return window_ && wm::IsActiveWindow(window_);
+bool NativeWidgetAndroid::IsActive() const {
+  return false;
 }
 
-void NativeWidgetAura::SetZOrderLevel(ui::ZOrderLevel order) {
-  if (window_)
-    window_->SetProperty(aura::client::kZOrderingKey, order);
+void NativeWidgetAndroid::SetZOrderLevel(ui::ZOrderLevel order) {
 }
 
-ui::ZOrderLevel NativeWidgetAura::GetZOrderLevel() const {
-  if (window_)
-    return window_->GetProperty(aura::client::kZOrderingKey);
-
+ui::ZOrderLevel NativeWidgetAndroid::GetZOrderLevel() const {
   return ui::ZOrderLevel::kNormal;
 }
 
-void NativeWidgetAura::SetVisibleOnAllWorkspaces(bool always_visible) {
+void NativeWidgetAndroid::SetVisibleOnAllWorkspaces(bool always_visible) {
   // Not implemented on chromeos or for child widgets.
 }
 
-bool NativeWidgetAura::IsVisibleOnAllWorkspaces() const {
+bool NativeWidgetAndroid::IsVisibleOnAllWorkspaces() const {
   return false;
 }
 
-void NativeWidgetAura::Maximize() {
-  if (window_)
-    window_->SetProperty(aura::client::kShowStateKey, ui::SHOW_STATE_MAXIMIZED);
+void NativeWidgetAndroid::Maximize() {
 }
 
-void NativeWidgetAura::Minimize() {
-  if (window_)
-    window_->SetProperty(aura::client::kShowStateKey, ui::SHOW_STATE_MINIMIZED);
+void NativeWidgetAndroid::Minimize() {
 }
 
-bool NativeWidgetAura::IsMaximized() const {
-  return window_ && window_->GetProperty(aura::client::kShowStateKey) ==
-                        ui::SHOW_STATE_MAXIMIZED;
+bool NativeWidgetAndroid::IsMaximized() const {
+  return false;
 }
 
-bool NativeWidgetAura::IsMinimized() const {
-  return window_ && window_->GetProperty(aura::client::kShowStateKey) ==
-                        ui::SHOW_STATE_MINIMIZED;
+bool NativeWidgetAndroid::IsMinimized() const {
+  return false;
 }
 
-void NativeWidgetAura::Restore() {
-  if (window_)
-    window_->SetProperty(aura::client::kShowStateKey, ui::SHOW_STATE_NORMAL);
+void NativeWidgetAndroid::Restore() {
 }
 
-void NativeWidgetAura::SetFullscreen(bool fullscreen) {
-  if (!window_ || IsFullscreen() == fullscreen)
-    return;  // Nothing to do.
-
-  wm::SetWindowFullscreen(window_, fullscreen);
+void NativeWidgetAndroid::SetFullscreen(bool fullscreen) {
 }
 
-bool NativeWidgetAura::IsFullscreen() const {
-  return window_ && window_->GetProperty(aura::client::kShowStateKey) ==
-                        ui::SHOW_STATE_FULLSCREEN;
+bool NativeWidgetAndroid::IsFullscreen() const {
+  return false;
 }
 
-void NativeWidgetAura::SetCanAppearInExistingFullscreenSpaces(
+void NativeWidgetAndroid::SetCanAppearInExistingFullscreenSpaces(
     bool can_appear_in_existing_fullscreen_spaces) {}
 
-void NativeWidgetAura::SetOpacity(float opacity) {
-  if (window_)
-    window_->layer()->SetOpacity(opacity);
+void NativeWidgetAndroid::SetOpacity(float opacity) {
 }
 
-void NativeWidgetAura::SetAspectRatio(const gfx::SizeF& aspect_ratio) {
-  DCHECK(!aspect_ratio.IsEmpty());
-  if (window_) {
-    // aura::client::kAspectRatio is owned, which allows for passing in this
-    // raw pointer.
-    window_->SetProperty(aura::client::kAspectRatio,
-                         new gfx::SizeF(aspect_ratio));
-  }
+void NativeWidgetAndroid::SetAspectRatio(const gfx::SizeF& aspect_ratio) {
 }
 
-void NativeWidgetAura::FlashFrame(bool flash) {
-  if (window_)
-    window_->SetProperty(aura::client::kDrawAttentionKey, flash);
+void NativeWidgetAndroid::FlashFrame(bool flash) {
 }
 
-void NativeWidgetAura::RunShellDrag(View* view,
+void NativeWidgetAndroid::RunShellDrag(View* view,
                                     std::unique_ptr<ui::OSExchangeData> data,
                                     const gfx::Point& location,
                                     int operation,
                                     ui::mojom::DragEventSource source) {
-  if (window_)
-    views::RunShellDrag(window_, std::move(data), location, operation, source);
 }
 
-void NativeWidgetAura::SchedulePaintInRect(const gfx::Rect& rect) {
-  if (window_)
-    window_->SchedulePaintInRect(rect);
+void NativeWidgetAndroid::SchedulePaintInRect(const gfx::Rect& rect) {
 }
 
-void NativeWidgetAura::ScheduleLayout() {
-  // ScheduleDraw() triggers a callback to WindowDelegate::UpdateVisualState().
-  if (window_)
-    window_->ScheduleDraw();
+void NativeWidgetAndroid::ScheduleLayout() {
 }
 
-void NativeWidgetAura::SetCursor(gfx::NativeCursor cursor) {
-  cursor_ = cursor;
-  aura::client::CursorClient* cursor_client =
-      aura::client::GetCursorClient(window_->GetRootWindow());
-  if (cursor_client)
-    cursor_client->SetCursor(cursor);
+void NativeWidgetAndroid::SetCursor(gfx::NativeCursor cursor) {
 }
 
-bool NativeWidgetAura::IsMouseEventsEnabled() const {
-  if (!window_)
-    return false;
-  aura::client::CursorClient* cursor_client =
-      aura::client::GetCursorClient(window_->GetRootWindow());
-  return cursor_client ? cursor_client->IsMouseEventsEnabled() : true;
+bool NativeWidgetAndroid::IsMouseEventsEnabled() const {
+  return false;
 }
 
-bool NativeWidgetAura::IsMouseButtonDown() const {
-  return aura::Env::GetInstance()->IsMouseButtonDown();
+bool NativeWidgetAndroid::IsMouseButtonDown() const {
+  return false;
 }
 
-void NativeWidgetAura::ClearNativeFocus() {
-  aura::client::FocusClient* client = aura::client::GetFocusClient(window_);
-  if (window_ && client && window_->Contains(client->GetFocusedWindow()))
-    client->ResetFocusWithinActiveWindow(window_);
+void NativeWidgetAndroid::ClearNativeFocus() {
 }
 
-gfx::Rect NativeWidgetAura::GetWorkAreaBoundsInScreen() const {
-  if (!window_)
-    return gfx::Rect();
-  return display::Screen::GetScreen()
-      ->GetDisplayNearestWindow(window_)
-      .work_area();
+gfx::Rect NativeWidgetAndroid::GetWorkAreaBoundsInScreen() const {
+  return gfx::Rect();
 }
 
-Widget::MoveLoopResult NativeWidgetAura::RunMoveLoop(
+Widget::MoveLoopResult NativeWidgetAndroid::RunMoveLoop(
     const gfx::Vector2d& drag_offset,
     Widget::MoveLoopSource source,
     Widget::MoveLoopEscapeBehavior escape_behavior) {
-  // |escape_behavior| is only needed on windows when running the native message
-  // loop.
-  if (!window_ || !window_->GetRootWindow())
-    return Widget::MOVE_LOOP_CANCELED;
-  wm::WindowMoveClient* move_client =
-      wm::GetWindowMoveClient(window_->GetRootWindow());
-  if (!move_client)
-    return Widget::MOVE_LOOP_CANCELED;
-
-  SetCapture();
-  wm::WindowMoveSource window_move_source =
-      source == Widget::MoveLoopSource::kMouse ? wm::WINDOW_MOVE_SOURCE_MOUSE
-                                               : wm::WINDOW_MOVE_SOURCE_TOUCH;
-  if (move_client->RunMoveLoop(window_, drag_offset, window_move_source) ==
-      wm::MOVE_SUCCESSFUL) {
-    return Widget::MOVE_LOOP_SUCCESSFUL;
-  }
   return Widget::MOVE_LOOP_CANCELED;
 }
 
-void NativeWidgetAura::EndMoveLoop() {
-  if (!window_ || !window_->GetRootWindow())
-    return;
-  wm::WindowMoveClient* move_client =
-      wm::GetWindowMoveClient(window_->GetRootWindow());
-  if (move_client)
-    move_client->EndMoveLoop();
+void NativeWidgetAndroid::EndMoveLoop() {
 }
 
-void NativeWidgetAura::SetVisibilityChangedAnimationsEnabled(bool value) {
-  if (window_)
-    window_->SetProperty(aura::client::kAnimationsDisabledKey, !value);
+void NativeWidgetAndroid::SetVisibilityChangedAnimationsEnabled(bool value) {
 }
 
-void NativeWidgetAura::SetVisibilityAnimationDuration(
+void NativeWidgetAndroid::SetVisibilityAnimationDuration(
     const base::TimeDelta& duration) {
-  wm::SetWindowVisibilityAnimationDuration(window_, duration);
 }
 
-void NativeWidgetAura::SetVisibilityAnimationTransition(
+void NativeWidgetAndroid::SetVisibilityAnimationTransition(
     Widget::VisibilityTransition transition) {
-  wm::WindowVisibilityAnimationTransition wm_transition = wm::ANIMATE_NONE;
-  switch (transition) {
-    case Widget::ANIMATE_SHOW:
-      wm_transition = wm::ANIMATE_SHOW;
-      break;
-    case Widget::ANIMATE_HIDE:
-      wm_transition = wm::ANIMATE_HIDE;
-      break;
-    case Widget::ANIMATE_BOTH:
-      wm_transition = wm::ANIMATE_BOTH;
-      break;
-    case Widget::ANIMATE_NONE:
-      wm_transition = wm::ANIMATE_NONE;
-      break;
-  }
-  wm::SetWindowVisibilityAnimationTransition(window_, wm_transition);
 }
 
-bool NativeWidgetAura::IsTranslucentWindowOpacitySupported() const {
+bool NativeWidgetAndroid::IsTranslucentWindowOpacitySupported() const {
   return true;
 }
 
-ui::GestureRecognizer* NativeWidgetAura::GetGestureRecognizer() {
-  return aura::Env::GetInstance()->gesture_recognizer();
-}
-
-void NativeWidgetAura::OnSizeConstraintsChanged() {
-  SetResizeBehaviorFromDelegate(GetWidget()->widget_delegate(), window_);
-}
-
-void NativeWidgetAura::OnNativeViewHierarchyWillChange() {}
-
-void NativeWidgetAura::OnNativeViewHierarchyChanged() {}
-
-std::string NativeWidgetAura::GetName() const {
-  return window_ ? window_->GetName() : std::string();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, aura::WindowDelegate implementation:
-
-gfx::Size NativeWidgetAura::GetMinimumSize() const {
-  return delegate_->GetMinimumSize();
-}
-
-gfx::Size NativeWidgetAura::GetMaximumSize() const {
-  // Do no check maximizability as EXO clients can have maximum size and be
-  // maximizable at the same time.
-  return delegate_->GetMaximumSize();
-}
-
-void NativeWidgetAura::OnBoundsChanged(const gfx::Rect& old_bounds,
-                                       const gfx::Rect& new_bounds) {
-  // Assume that if the old bounds was completely empty a move happened. This
-  // handles the case of a maximize animation acquiring the layer (acquiring a
-  // layer results in clearing the bounds).
-  if (old_bounds.origin() != new_bounds.origin() ||
-      (old_bounds == gfx::Rect(0, 0, 0, 0) && !new_bounds.IsEmpty())) {
-    delegate_->OnNativeWidgetMove();
-  }
-  if (old_bounds.size() != new_bounds.size())
-    delegate_->OnNativeWidgetSizeChanged(new_bounds.size());
-}
-
-gfx::NativeCursor NativeWidgetAura::GetCursor(const gfx::Point& point) {
-  return cursor_;
-}
-
-int NativeWidgetAura::GetNonClientComponent(const gfx::Point& point) const {
-  return delegate_->GetNonClientComponent(point);
-}
-
-bool NativeWidgetAura::ShouldDescendIntoChildForEventHandling(
-    aura::Window* child,
-    const gfx::Point& location) {
-  return delegate_->ShouldDescendIntoChildForEventHandling(
-      window_->layer(), child, child->layer(), location);
-}
-
-bool NativeWidgetAura::CanFocus() {
-  return ShouldActivate();
-}
-
-void NativeWidgetAura::OnCaptureLost() {
-  delegate_->OnMouseCaptureLost();
-}
-
-void NativeWidgetAura::OnPaint(const ui::PaintContext& context) {
-  delegate_->OnNativeWidgetPaint(context);
-}
-
-void NativeWidgetAura::OnDeviceScaleFactorChanged(
-    float old_device_scale_factor,
-    float new_device_scale_factor) {
-  GetWidget()->DeviceScaleFactorChanged(old_device_scale_factor,
-                                        new_device_scale_factor);
-}
-
-void NativeWidgetAura::OnWindowDestroying(aura::Window* window) {
-  window_->RemoveObserver(this);
-  delegate_->OnNativeWidgetDestroying();
-
-  // If the aura::Window is destroyed, we can no longer show tooltips.
-  tooltip_manager_.reset();
-
-  focus_manager_event_handler_.reset();
-}
-
-void NativeWidgetAura::OnWindowDestroyed(aura::Window* window) {
-  window_ = nullptr;
-  // |OnNativeWidgetDestroyed| may delete |this| if the object does not own
-  // itself.
-  bool should_delete_this =
-      (ownership_ == Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET);
-  delegate_->OnNativeWidgetDestroyed();
-  if (should_delete_this)
-    delete this;
-}
-
-void NativeWidgetAura::OnWindowTargetVisibilityChanged(bool visible) {
-  delegate_->OnNativeWidgetVisibilityChanged(visible);
-}
-
-bool NativeWidgetAura::HasHitTestMask() const {
-  return delegate_->HasHitTestMask();
-}
-
-void NativeWidgetAura::GetHitTestMask(SkPath* mask) const {
-  DCHECK(mask);
-  delegate_->GetHitTestMask(mask);
-}
-
-void NativeWidgetAura::UpdateVisualState() {
-  delegate_->LayoutRootViewIfNecessary();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, aura::WindowObserver implementation:
-
-void NativeWidgetAura::OnWindowPropertyChanged(aura::Window* window,
-                                               const void* key,
-                                               intptr_t old) {
-  if (key == aura::client::kShowStateKey)
-    delegate_->OnNativeWidgetWindowShowStateChanged();
-}
-
-void NativeWidgetAura::OnResizeLoopStarted(aura::Window* window) {
-  delegate_->OnNativeWidgetBeginUserBoundsChange();
-}
-
-void NativeWidgetAura::OnResizeLoopEnded(aura::Window* window) {
-  delegate_->OnNativeWidgetEndUserBoundsChange();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, ui::EventHandler implementation:
-
-void NativeWidgetAura::OnKeyEvent(ui::KeyEvent* event) {
-  DCHECK(window_);
-  // Renderer may send a key event back to us if the key event wasn't handled,
-  // and the window may be invisible by that time.
-  if (!window_->IsVisible())
-    return;
-
-  delegate_->OnKeyEvent(event);
-}
-
-void NativeWidgetAura::OnMouseEvent(ui::MouseEvent* event) {
-  DCHECK(window_);
-  DCHECK(window_->IsVisible());
-  if (event->type() == ui::ET_MOUSEWHEEL) {
-    delegate_->OnMouseEvent(event);
-    return;
-  }
-
-  if (tooltip_manager_.get())
-    tooltip_manager_->UpdateTooltip();
-  TooltipManagerAura::UpdateTooltipManagerForCapture(GetWidget());
-  delegate_->OnMouseEvent(event);
-}
-
-void NativeWidgetAura::OnScrollEvent(ui::ScrollEvent* event) {
-  delegate_->OnScrollEvent(event);
-}
-
-void NativeWidgetAura::OnGestureEvent(ui::GestureEvent* event) {
-  DCHECK(window_);
-  DCHECK(window_->IsVisible() || event->IsEndingEvent());
-  delegate_->OnGestureEvent(event);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, wm::ActivationDelegate implementation:
-
-bool NativeWidgetAura::ShouldActivate() const {
-  return delegate_->CanActivate();
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, wm::ActivationChangeObserver implementation:
-
-void NativeWidgetAura::OnWindowActivated(
-    wm::ActivationChangeObserver::ActivationReason,
-    aura::Window* gained_active,
-    aura::Window* lost_active) {
-  DCHECK(window_ == gained_active || window_ == lost_active);
-  if (GetWidget()->GetFocusManager()) {
-    if (window_ == gained_active)
-      GetWidget()->GetFocusManager()->RestoreFocusedView();
-    else if (window_ == lost_active)
-      GetWidget()->GetFocusManager()->StoreFocusedView(true);
-  }
-  delegate_->OnNativeWidgetActivationChanged(window_ == gained_active);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, aura::client::FocusChangeObserver:
-
-void NativeWidgetAura::OnWindowFocused(aura::Window* gained_focus,
-                                       aura::Window* lost_focus) {
-  if (window_ == gained_focus)
-    delegate_->OnNativeFocus();
-  else if (window_ == lost_focus)
-    delegate_->OnNativeBlur();
+ui::GestureRecognizer* NativeWidgetAndroid::GetGestureRecognizer() {
+  return nullptr;
 }
 
-////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, aura::WindowDragDropDelegate implementation:
-
-void NativeWidgetAura::OnDragEntered(const ui::DropTargetEvent& event) {
-  DCHECK(drop_helper_.get() != nullptr);
-  last_drop_operation_ = drop_helper_->OnDragOver(
-      event.data(), event.location(), event.source_operations());
+void NativeWidgetAndroid::OnSizeConstraintsChanged() {
 }
 
-int NativeWidgetAura::OnDragUpdated(const ui::DropTargetEvent& event) {
-  DCHECK(drop_helper_.get() != nullptr);
-  last_drop_operation_ = drop_helper_->OnDragOver(
-      event.data(), event.location(), event.source_operations());
-  return last_drop_operation_;
-}
+void NativeWidgetAndroid::OnNativeViewHierarchyWillChange() {}
 
-void NativeWidgetAura::OnDragExited() {
-  DCHECK(drop_helper_.get() != nullptr);
-  drop_helper_->OnDragExit();
-}
+void NativeWidgetAndroid::OnNativeViewHierarchyChanged() {}
 
-int NativeWidgetAura::OnPerformDrop(const ui::DropTargetEvent& event,
-                                    std::unique_ptr<ui::OSExchangeData> data) {
-  DCHECK(drop_helper_.get() != nullptr);
-  return drop_helper_->OnDrop(event.data(), event.location(),
-                              last_drop_operation_);
+std::string NativeWidgetAndroid::GetName() const {
+  return std::string();
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, protected:
+// NativeWidgetAndroid, protected:
 
-NativeWidgetAura::~NativeWidgetAura() {
+NativeWidgetAndroid::~NativeWidgetAndroid() {
   destroying_ = true;
   if (ownership_ == Widget::InitParams::NATIVE_WIDGET_OWNS_WIDGET)
     delete delegate_;
@@ -1077,12 +436,9 @@ NativeWidgetAura::~NativeWidgetAura() {
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// NativeWidgetAura, private:
+// NativeWidgetAndroid, private:
 
-void NativeWidgetAura::SetInitialFocus(ui::WindowShowState show_state) {
-  // The window does not get keyboard messages unless we focus it.
-  if (!GetWidget()->SetInitialFocus(show_state))
-    window_->Focus();
+void NativeWidgetAndroid::SetInitialFocus(ui::WindowShowState show_state) {
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -1090,7 +446,7 @@ void NativeWidgetAura::SetInitialFocus(u
 
 namespace {
 #if BUILDFLAG(ENABLE_DESKTOP_AURA) && \
-    (defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS))
+    (defined(OS_WIN) || defined(OS_CHROMEOS))
 void CloseWindow(aura::Window* window) {
   if (window) {
     Widget* widget = Widget::GetWidgetForNativeView(window);
@@ -1121,26 +477,11 @@ void Widget::CloseAllSecondaryWidgets()
 #endif
 
 #if BUILDFLAG(ENABLE_DESKTOP_AURA) && \
-    (defined(OS_LINUX) || defined(OS_CHROMEOS))
+    defined(OS_CHROMEOS)
   DesktopWindowTreeHostLinux::CleanUpWindowList(CloseWindow);
 #endif
 }
 
-const ui::NativeTheme* Widget::GetNativeTheme() const {
-#if BUILDFLAG(ENABLE_DESKTOP_AURA) && \
-    (defined(OS_LINUX) || defined(OS_CHROMEOS))
-  const LinuxUI* linux_ui = LinuxUI::instance();
-  if (linux_ui) {
-    ui::NativeTheme* native_theme =
-        linux_ui->GetNativeTheme(native_widget_->GetNativeWindow());
-    if (native_theme)
-      return native_theme;
-  }
-#endif
-
-  return ui::NativeTheme::GetInstanceForNativeUi();
-}
-
 namespace internal {
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -1149,116 +490,46 @@ namespace internal {
 // static
 NativeWidgetPrivate* NativeWidgetPrivate::CreateNativeWidget(
     internal::NativeWidgetDelegate* delegate) {
-  return new NativeWidgetAura(delegate);
+  return new NativeWidgetAndroid(delegate);
 }
 
 // static
 NativeWidgetPrivate* NativeWidgetPrivate::GetNativeWidgetForNativeView(
     gfx::NativeView native_view) {
-  return native_view->GetProperty(kNativeWidgetPrivateKey);
+  return nullptr;
 }
 
 // static
 NativeWidgetPrivate* NativeWidgetPrivate::GetNativeWidgetForNativeWindow(
     gfx::NativeWindow native_window) {
-  return native_window->GetProperty(kNativeWidgetPrivateKey);
+  return nullptr;
 }
 
 // static
 NativeWidgetPrivate* NativeWidgetPrivate::GetTopLevelNativeWidget(
     gfx::NativeView native_view) {
-  aura::Window* window = native_view;
-  NativeWidgetPrivate* top_level_native_widget = nullptr;
-  while (window) {
-    NativeWidgetPrivate* native_widget = GetNativeWidgetForNativeView(window);
-    if (native_widget)
-      top_level_native_widget = native_widget;
-    window = window->parent();
-  }
-  return top_level_native_widget;
+  return nullptr;
 }
 
 // static
 void NativeWidgetPrivate::GetAllChildWidgets(gfx::NativeView native_view,
                                              Widget::Widgets* children) {
-  {
-    // Code expects widget for |native_view| to be added to |children|.
-    NativeWidgetPrivate* native_widget = static_cast<NativeWidgetPrivate*>(
-        GetNativeWidgetForNativeView(native_view));
-    if (native_widget && native_widget->GetWidget())
-      children->insert(native_widget->GetWidget());
-  }
-
-  for (auto* child_window : native_view->children())
-    GetAllChildWidgets(child_window, children);
 }
 
 // static
 void NativeWidgetPrivate::GetAllOwnedWidgets(gfx::NativeView native_view,
                                              Widget::Widgets* owned) {
-  // Add all owned widgets.
-  for (aura::Window* transient_child : wm::GetTransientChildren(native_view)) {
-    NativeWidgetPrivate* native_widget = static_cast<NativeWidgetPrivate*>(
-        GetNativeWidgetForNativeView(transient_child));
-    if (native_widget && native_widget->GetWidget())
-      owned->insert(native_widget->GetWidget());
-    GetAllOwnedWidgets(transient_child, owned);
-  }
-
-  // Add all child windows.
-  for (aura::Window* child : native_view->children())
-    GetAllChildWidgets(child, owned);
 }
 
 // static
 void NativeWidgetPrivate::ReparentNativeView(gfx::NativeView native_view,
                                              gfx::NativeView new_parent) {
-  DCHECK(native_view != new_parent);
-
-  gfx::NativeView previous_parent = native_view->parent();
-  if (previous_parent == new_parent)
-    return;
-
-  Widget::Widgets widgets;
-  GetAllChildWidgets(native_view, &widgets);
-
-  // First notify all the widgets that they are being disassociated
-  // from their previous parent.
-  for (auto* widget : widgets)
-    widget->NotifyNativeViewHierarchyWillChange();
-
-  if (new_parent) {
-    new_parent->AddChild(native_view);
-  } else {
-    // The following looks weird, but it's the equivalent of what aura has
-    // always done. (The previous behaviour of aura::Window::SetParent() used
-    // NULL as a special value that meant ask the WindowParentingClient where
-    // things should go.)
-    //
-    // This probably isn't strictly correct, but its an invariant that a Window
-    // in use will be attached to a RootWindow, so we can't just call
-    // RemoveChild here. The only possible thing that could assign a RootWindow
-    // in this case is the stacking client of the current RootWindow. This
-    // matches our previous behaviour; the global stacking client would almost
-    // always reattach the window to the same RootWindow.
-    aura::Window* root_window = native_view->GetRootWindow();
-    aura::client::ParentWindowWithContext(native_view, root_window,
-                                          root_window->GetBoundsInScreen());
-  }
-
-  // And now, notify them that they have a brand new parent.
-  for (auto* widget : widgets)
-    widget->NotifyNativeViewHierarchyChanged();
 }
 
 // static
 gfx::NativeView NativeWidgetPrivate::GetGlobalCapture(
     gfx::NativeView native_view) {
-  aura::client::CaptureClient* capture_client =
-      aura::client::GetCaptureClient(native_view->GetRootWindow());
-  if (!capture_client)
-    return nullptr;
-  return capture_client->GetGlobalCaptureWindow();
+  return nullptr;
 }
 
 }  // namespace internal
--- a/ui/views/widget/native_widget_aura.h
+++ b/ui/views/widget/native_widget_aura.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef UI_VIEWS_WIDGET_NATIVE_WIDGET_AURA_H_
-#define UI_VIEWS_WIDGET_NATIVE_WIDGET_AURA_H_
+#ifndef UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
+#define UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
 
 #include <memory>
 #include <string>
@@ -11,10 +11,6 @@
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "build/build_config.h"
-#include "ui/aura/client/drag_drop_delegate.h"
-#include "ui/aura/client/focus_change_observer.h"
-#include "ui/aura/window_delegate.h"
-#include "ui/aura/window_observer.h"
 #include "ui/base/cursor/cursor.h"
 #include "ui/events/event_constants.h"
 #include "ui/views/views_export.h"
@@ -22,11 +18,7 @@
 #include "ui/wm/public/activation_change_observer.h"
 #include "ui/wm/public/activation_delegate.h"
 
-#if defined(OS_APPLE)
-#error This file must not be included on macOS; Chromium Mac doesn't use Aura.
-#endif
-
-namespace aura {
+namespace android {
 class Window;
 }
 
@@ -34,39 +26,33 @@ namespace views {
 
 class DropHelper;
 class FocusManagerEventHandler;
-class TooltipManagerAura;
+class TooltipManagerAndroid;
 class WindowReorderer;
 
-class VIEWS_EXPORT NativeWidgetAura : public internal::NativeWidgetPrivate,
-                                      public aura::WindowDelegate,
-                                      public aura::WindowObserver,
-                                      public wm::ActivationDelegate,
-                                      public wm::ActivationChangeObserver,
-                                      public aura::client::FocusChangeObserver,
-                                      public aura::client::DragDropDelegate {
+class VIEWS_EXPORT NativeWidgetAndroid : public internal::NativeWidgetPrivate {
  public:
-  explicit NativeWidgetAura(internal::NativeWidgetDelegate* delegate);
+  explicit NativeWidgetAndroid(internal::NativeWidgetDelegate* delegate);
 
-  // Called internally by NativeWidgetAura and DesktopNativeWidgetAura to
+  // Called internally by NativeWidgetAndroid and DesktopNativeWidgetAndroid to
   // associate |native_widget| with |window|.
   static void RegisterNativeWidgetForWindow(
       internal::NativeWidgetPrivate* native_widget,
-      aura::Window* window);
+      gfx::NativeWindow window);
 
   // Assign an icon to aura window.
-  static void AssignIconToAuraWindow(aura::Window* window,
+  static void AssignIconToAuraWindow(gfx::NativeWindow window,
                                      const gfx::ImageSkia& window_icon,
                                      const gfx::ImageSkia& app_icon);
 
   // If necessary, sets the ShadowElevation of |window| from |params|.
   static void SetShadowElevationFromInitParams(
-      aura::Window* window,
+      gfx::NativeWindow window,
       const Widget::InitParams& params);
 
   // Sets the window property aura::client::kResizeBehaviorKey based on the
   // values from the delegate.
   static void SetResizeBehaviorFromDelegate(WidgetDelegate* delegate,
-                                            aura::Window* window);
+                                            gfx::NativeWindow window);
 
   // internal::NativeWidgetPrivate:
   void InitNativeWidget(Widget::InitParams params) override;
@@ -161,62 +147,8 @@ class VIEWS_EXPORT NativeWidgetAura : pu
   void OnNativeViewHierarchyChanged() override;
   std::string GetName() const override;
 
-  // aura::WindowDelegate:
-  gfx::Size GetMinimumSize() const override;
-  gfx::Size GetMaximumSize() const override;
-  void OnBoundsChanged(const gfx::Rect& old_bounds,
-                       const gfx::Rect& new_bounds) override;
-  gfx::NativeCursor GetCursor(const gfx::Point& point) override;
-  int GetNonClientComponent(const gfx::Point& point) const override;
-  bool ShouldDescendIntoChildForEventHandling(
-      aura::Window* child,
-      const gfx::Point& location) override;
-  bool CanFocus() override;
-  void OnCaptureLost() override;
-  void OnPaint(const ui::PaintContext& context) override;
-  void OnDeviceScaleFactorChanged(float old_device_scale_factor,
-                                  float new_device_scale_factor) override;
-  void OnWindowDestroying(aura::Window* window) override;
-  void OnWindowDestroyed(aura::Window* window) override;
-  void OnWindowTargetVisibilityChanged(bool visible) override;
-  bool HasHitTestMask() const override;
-  void GetHitTestMask(SkPath* mask) const override;
-  void UpdateVisualState() override;
-
-  // aura::WindowObserver:
-  void OnWindowPropertyChanged(aura::Window* window,
-                               const void* key,
-                               intptr_t old) override;
-  void OnResizeLoopStarted(aura::Window* window) override;
-  void OnResizeLoopEnded(aura::Window* window) override;
-
-  // ui::EventHandler:
-  void OnKeyEvent(ui::KeyEvent* event) override;
-  void OnMouseEvent(ui::MouseEvent* event) override;
-  void OnScrollEvent(ui::ScrollEvent* event) override;
-  void OnGestureEvent(ui::GestureEvent* event) override;
-
-  // wm::ActivationDelegate:
-  bool ShouldActivate() const override;
-
-  // wm::ActivationChangeObserver:
-  void OnWindowActivated(wm::ActivationChangeObserver::ActivationReason reason,
-                         aura::Window* gained_active,
-                         aura::Window* lost_active) override;
-
-  // aura::client::FocusChangeObserver:
-  void OnWindowFocused(aura::Window* gained_focus,
-                       aura::Window* lost_focus) override;
-
-  // aura::client::DragDropDelegate:
-  void OnDragEntered(const ui::DropTargetEvent& event) override;
-  int OnDragUpdated(const ui::DropTargetEvent& event) override;
-  void OnDragExited() override;
-  int OnPerformDrop(const ui::DropTargetEvent& event,
-                    std::unique_ptr<ui::OSExchangeData> data) override;
-
  protected:
-  ~NativeWidgetAura() override;
+  ~NativeWidgetAndroid() override;
 
   internal::NativeWidgetDelegate* delegate() { return delegate_; }
 
@@ -228,7 +160,7 @@ class VIEWS_EXPORT NativeWidgetAura : pu
   // WARNING: set to NULL when destroyed. As the Widget is not necessarily
   // destroyed along with |window_| all usage of |window_| should first verify
   // non-NULL.
-  aura::Window* window_;
+  gfx::NativeWindow window_;
 
   // See class documentation for Widget in widget.h for a note about ownership.
   Widget::InitParams::Ownership ownership_;
@@ -238,7 +170,7 @@ class VIEWS_EXPORT NativeWidgetAura : pu
 
   gfx::NativeCursor cursor_;
 
-  std::unique_ptr<TooltipManagerAura> tooltip_manager_;
+  std::unique_ptr<TooltipManagerAndroid> tooltip_manager_;
 
   // Reorders child windows of |window_| associated with a view based on the
   // order of the associated views in the widget's view hierarchy.
@@ -250,13 +182,13 @@ class VIEWS_EXPORT NativeWidgetAura : pu
   // Native widget's handler to receive events before the event target.
   std::unique_ptr<FocusManagerEventHandler> focus_manager_event_handler_;
 
-  // The following factory is used for calls to close the NativeWidgetAura
+  // The following factory is used for calls to close the NativeWidgetAndroid
   // instance.
-  base::WeakPtrFactory<NativeWidgetAura> close_widget_factory_{this};
+  base::WeakPtrFactory<NativeWidgetAndroid> close_widget_factory_{this};
 
-  DISALLOW_COPY_AND_ASSIGN(NativeWidgetAura);
+  DISALLOW_COPY_AND_ASSIGN(NativeWidgetAndroid);
 };
 
 }  // namespace views
 
-#endif  // UI_VIEWS_WIDGET_NATIVE_WIDGET_AURA_H_
+#endif  // UI_VIEWS_WIDGET_NATIVE_WIDGET_ANDROID_H_
--- a/ui/views/native_cursor_aura.cc
+++ b/ui/views/native_cursor_aura.cc
@@ -5,28 +5,27 @@
 #include "ui/views/native_cursor.h"
 
 #include "ui/base/cursor/cursor.h"
-#include "ui/base/cursor/mojom/cursor_type.mojom-shared.h"
 
 namespace views {
 
 gfx::NativeCursor GetNativeIBeamCursor() {
-  return ui::mojom::CursorType::kIBeam;
+  return gfx::kNullCursor;
 }
 
 gfx::NativeCursor GetNativeHandCursor() {
-  return ui::mojom::CursorType::kHand;
+  return gfx::kNullCursor;
 }
 
 gfx::NativeCursor GetNativeColumnResizeCursor() {
-  return ui::mojom::CursorType::kColumnResize;
+  return gfx::kNullCursor;
 }
 
 gfx::NativeCursor GetNativeEastWestResizeCursor() {
-  return ui::mojom::CursorType::kEastWestResize;
+  return gfx::kNullCursor;
 }
 
 gfx::NativeCursor GetNativeNorthSouthResizeCursor() {
-  return ui::mojom::CursorType::kNorthSouthResize;
+  return gfx::kNullCursor;
 }
 
 }  // namespace views
--- a/ui/views/widget/tooltip_manager_aura.cc
+++ b/ui/views/widget/tooltip_manager_aura.cc
@@ -4,9 +4,6 @@
 
 #include "ui/views/widget/tooltip_manager_aura.h"
 
-#include "ui/aura/client/screen_position_client.h"
-#include "ui/aura/window_event_dispatcher.h"
-#include "ui/aura/window_tree_host.h"
 #include "ui/base/resource/resource_bundle.h"
 #include "ui/display/screen.h"
 #include "ui/gfx/geometry/rect.h"
@@ -16,111 +13,46 @@
 namespace views {
 
 ////////////////////////////////////////////////////////////////////////////////
-// TooltipManagerAura public:
+// TooltipManagerAndroid public:
 
-TooltipManagerAura::TooltipManagerAura(Widget* widget) : widget_(widget) {
-  wm::SetTooltipText(GetWindow(), &tooltip_text_);
+TooltipManagerAndroid::TooltipManagerAndroid(Widget* widget) : widget_(widget) {
 }
 
-TooltipManagerAura::~TooltipManagerAura() {
-  wm::SetTooltipText(GetWindow(), nullptr);
+TooltipManagerAndroid::~TooltipManagerAndroid() {
 }
 
 // static
-const gfx::FontList& TooltipManagerAura::GetDefaultFontList() {
+const gfx::FontList& TooltipManagerAndroid::GetDefaultFontList() {
   return ui::ResourceBundle::GetSharedInstance().GetFontList(
       ui::ResourceBundle::BaseFont);
 }
 
 // static
-void TooltipManagerAura::UpdateTooltipManagerForCapture(Widget* source) {
-  if (!source->HasCapture())
-    return;
-
-  aura::Window* root_window = source->GetNativeView()->GetRootWindow();
-  if (!root_window)
-    return;
-
-  gfx::Point screen_loc(
-      root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot());
-  aura::client::ScreenPositionClient* screen_position_client =
-      aura::client::GetScreenPositionClient(root_window);
-  if (!screen_position_client)
-    return;
-  screen_position_client->ConvertPointToScreen(root_window, &screen_loc);
-  display::Screen* screen = display::Screen::GetScreen();
-  aura::Window* target = screen->GetWindowAtScreenPoint(screen_loc);
-  if (!target)
-    return;
-  gfx::Point target_loc(screen_loc);
-  screen_position_client =
-      aura::client::GetScreenPositionClient(target->GetRootWindow());
-  if (!screen_position_client)
-    return;
-  screen_position_client->ConvertPointFromScreen(target, &target_loc);
-  target = target->GetEventHandlerForPoint(target_loc);
-  while (target) {
-    Widget* target_widget = Widget::GetWidgetForNativeView(target);
-    if (target_widget == source)
-      return;
-
-    if (target_widget) {
-      if (target_widget->GetTooltipManager())
-        target_widget->GetTooltipManager()->UpdateTooltip();
-      return;
-    }
-    target = target->parent();
-  }
+void TooltipManagerAndroid::UpdateTooltipManagerForCapture(Widget* source) {
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// TooltipManagerAura, TooltipManager implementation:
+// TooltipManagerAndroid, TooltipManager implementation:
 
-const gfx::FontList& TooltipManagerAura::GetFontList() const {
+const gfx::FontList& TooltipManagerAndroid::GetFontList() const {
   return GetDefaultFontList();
 }
 
-int TooltipManagerAura::GetMaxWidth(const gfx::Point& point) const {
-  return wm::GetTooltipClient(widget_->GetNativeView()->GetRootWindow())
-      ->GetMaxWidth(point);
-}
-
-void TooltipManagerAura::UpdateTooltip() {
-  aura::Window* root_window = GetWindow()->GetRootWindow();
-  if (wm::GetTooltipClient(root_window)) {
-    if (!widget_->IsVisible()) {
-      UpdateTooltipForTarget(nullptr, gfx::Point(), root_window);
-      return;
-    }
-    gfx::Point view_point =
-        root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot();
-    aura::Window::ConvertPointToTarget(root_window, GetWindow(), &view_point);
-    View* view = GetViewUnderPoint(view_point);
-    UpdateTooltipForTarget(view, view_point, root_window);
-  }
+int TooltipManagerAndroid::GetMaxWidth(const gfx::Point& point) const {
+  return 0;
 }
 
-void TooltipManagerAura::TooltipTextChanged(View* view) {
-  aura::Window* root_window = GetWindow()->GetRootWindow();
-  if (wm::GetTooltipClient(root_window)) {
-    gfx::Point view_point =
-        root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot();
-    aura::Window::ConvertPointToTarget(root_window, GetWindow(), &view_point);
-    View* target = GetViewUnderPoint(view_point);
-    if (target != view)
-      return;
-    UpdateTooltipForTarget(view, view_point, root_window);
-  }
+void TooltipManagerAndroid::UpdateTooltip() {
+}
+
+void TooltipManagerAndroid::TooltipTextChanged(View* view) {
 }
 
-View* TooltipManagerAura::GetViewUnderPoint(const gfx::Point& point) {
-  View* root_view = widget_->GetRootView();
-  if (root_view)
-    return root_view->GetTooltipHandlerForPoint(point);
+View* TooltipManagerAndroid::GetViewUnderPoint(const gfx::Point& point) {
   return nullptr;
 }
 
-void TooltipManagerAura::UpdateTooltipForTarget(View* target,
+void TooltipManagerAndroid::UpdateTooltipForTarget(View* target,
                                                 const gfx::Point& point,
                                                 aura::Window* root_window) {
   if (target) {
@@ -130,14 +62,10 @@ void TooltipManagerAura::UpdateTooltipFo
   } else {
     tooltip_text_.clear();
   }
-
-  wm::SetTooltipId(GetWindow(), target);
-
-  wm::GetTooltipClient(root_window)->UpdateTooltip(GetWindow());
 }
 
-aura::Window* TooltipManagerAura::GetWindow() {
-  return widget_->GetNativeView();
+aura::Window* TooltipManagerAndroid::GetWindow() {
+  return nullptr;
 }
 
 }  // namespace views.
--- a/ui/views/widget/tooltip_manager_aura.h
+++ b/ui/views/widget/tooltip_manager_aura.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef UI_VIEWS_WIDGET_TOOLTIP_MANAGER_AURA_H_
-#define UI_VIEWS_WIDGET_TOOLTIP_MANAGER_AURA_H_
+#ifndef UI_VIEWS_WIDGET_TOOLTIP_MANAGER_ANDROID_H_
+#define UI_VIEWS_WIDGET_TOOLTIP_MANAGER_ANDROID_H_
 
 #include "base/compiler_specific.h"
 #include "base/macros.h"
@@ -24,11 +24,11 @@ namespace views {
 
 class Widget;
 
-// TooltipManager implementation for Aura.
-class VIEWS_EXPORT TooltipManagerAura : public TooltipManager {
+// TooltipManager implementation for Android.
+class VIEWS_EXPORT TooltipManagerAndroid : public TooltipManager {
  public:
-  explicit TooltipManagerAura(Widget* widget);
-  ~TooltipManagerAura() override;
+  explicit TooltipManagerAndroid(Widget* widget);
+  ~TooltipManagerAndroid() override;
 
   // If |source| has capture this finds the Widget under the mouse and invokes
   // UpdateTooltip() on it's TooltipManager. This is necessary as when capture
@@ -36,7 +36,7 @@ class VIEWS_EXPORT TooltipManagerAura :
   // though we may show tooltips for the Window under the mouse.
   static void UpdateTooltipManagerForCapture(Widget* source);
 
-  // Returns the FontList used by all TooltipManagerAuras.
+  // Returns the FontList used by all TooltipManagerAndroids.
   static const gfx::FontList& GetDefaultFontList();
 
   // TooltipManager:
@@ -57,9 +57,9 @@ class VIEWS_EXPORT TooltipManagerAura :
   Widget* widget_;
   base::string16 tooltip_text_;
 
-  DISALLOW_COPY_AND_ASSIGN(TooltipManagerAura);
+  DISALLOW_COPY_AND_ASSIGN(TooltipManagerAndroid);
 };
 
 }  // namespace views
 
-#endif  // UI_VIEWS_WIDGET_TOOLTIP_MANAGER_AURA_H_
+#endif  // UI_VIEWS_WIDGET_TOOLTIP_MANAGER_ANDROID_H_
--- a/ui/views/controls/menu/menu_pre_target_handler_aura.cc
+++ b/ui/views/controls/menu/menu_pre_target_handler_aura.cc
@@ -6,8 +6,6 @@
 
 #include <memory>
 
-#include "ui/aura/env.h"
-#include "ui/aura/window.h"
 #include "ui/views/controls/menu/menu_controller.h"
 #include "ui/views/widget/widget.h"
 #include "ui/wm/public/activation_client.h"
@@ -16,67 +14,37 @@ namespace views {
 
 namespace {
 
-aura::Window* GetOwnerRootWindow(views::Widget* owner) {
-  return owner ? owner->GetNativeWindow()->GetRootWindow() : nullptr;
+ui::WindowAndroid* GetOwnerRootWindow(views::Widget* owner) {
+  return nullptr;
 }
 
 }  // namespace
 
-MenuPreTargetHandlerAura::MenuPreTargetHandlerAura(MenuController* controller,
+MenuPreTargetHandlerAndroid::MenuPreTargetHandlerAndroid(MenuController* controller,
                                                    Widget* owner)
     : controller_(controller), root_(GetOwnerRootWindow(owner)) {
-  if (root_) {
-    wm::GetActivationClient(root_)->AddObserver(this);
-    root_->AddObserver(this);
-  } else {
-    // This should only happen in cases like when context menus are shown for
-    // Windows OS system tray items and there is no parent window.
-  }
-  aura::Env::GetInstance()->AddPreTargetHandler(
-      this, ui::EventTarget::Priority::kSystem);
 }
 
-MenuPreTargetHandlerAura::~MenuPreTargetHandlerAura() {
-  aura::Env::GetInstance()->RemovePreTargetHandler(this);
+MenuPreTargetHandlerAndroid::~MenuPreTargetHandlerAndroid() {
   Cleanup();
 }
 
-void MenuPreTargetHandlerAura::OnWindowActivated(
-    wm::ActivationChangeObserver::ActivationReason reason,
-    aura::Window* gained_active,
-    aura::Window* lost_active) {
-  if (!controller_->drag_in_progress())
-    controller_->Cancel(MenuController::ExitType::kAll);
-}
-
-void MenuPreTargetHandlerAura::OnWindowDestroying(aura::Window* window) {
-  Cleanup();
-}
-
-void MenuPreTargetHandlerAura::OnCancelMode(ui::CancelModeEvent* event) {
+void MenuPreTargetHandlerAndroid::OnCancelMode(ui::CancelModeEvent* event) {
   controller_->Cancel(MenuController::ExitType::kAll);
 }
 
-void MenuPreTargetHandlerAura::OnKeyEvent(ui::KeyEvent* event) {
+void MenuPreTargetHandlerAndroid::OnKeyEvent(ui::KeyEvent* event) {
   controller_->OnWillDispatchKeyEvent(event);
 }
 
-void MenuPreTargetHandlerAura::Cleanup() {
-  if (!root_)
-    return;
-  // The ActivationClient may have been destroyed by the time we get here.
-  wm::ActivationClient* client = wm::GetActivationClient(root_);
-  if (client)
-    client->RemoveObserver(this);
-  root_->RemoveObserver(this);
-  root_ = nullptr;
+void MenuPreTargetHandlerAndroid::Cleanup() {
 }
 
 // static
 std::unique_ptr<MenuPreTargetHandler> MenuPreTargetHandler::Create(
     MenuController* controller,
     Widget* owner) {
-  return std::make_unique<MenuPreTargetHandlerAura>(controller, owner);
+  return nullptr;
 }
 
 }  // namespace views
--- a/ui/views/controls/menu/menu_pre_target_handler_aura.h
+++ b/ui/views/controls/menu/menu_pre_target_handler_aura.h
@@ -2,44 +2,29 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef UI_VIEWS_CONTROLS_MENU_MENU_PRE_TARGET_HANDLER_AURA_H_
-#define UI_VIEWS_CONTROLS_MENU_MENU_PRE_TARGET_HANDLER_AURA_H_
+#ifndef UI_VIEWS_CONTROLS_MENU_MENU_PRE_TARGET_HANDLER_ANDROID_H_
+#define UI_VIEWS_CONTROLS_MENU_MENU_PRE_TARGET_HANDLER_ANDROID_H_
 
-#include "ui/aura/window_observer.h"
+#include "ui/android/window_android.h"
 #include "ui/events/event_handler.h"
 #include "ui/views/controls/menu/menu_pre_target_handler.h"
 #include "ui/views/views_export.h"
-#include "ui/wm/public/activation_change_observer.h"
-
-namespace aura {
-class Window;
-}  // namespace aura
 
 namespace views {
 
 class MenuController;
 class Widget;
 
-// MenuPreTargetHandlerAura is used to observe activation changes, cancel
+// MenuPreTargetHandlerAndroid is used to observe activation changes, cancel
 // events, and root window destruction, to shutdown the menu.
 //
 // Additionally handles key events to provide accelerator support to menus.
-class VIEWS_EXPORT MenuPreTargetHandlerAura
-    : public wm::ActivationChangeObserver,
-      public aura::WindowObserver,
-      public ui::EventHandler,
+class VIEWS_EXPORT MenuPreTargetHandlerAndroid
+    : public ui::EventHandler,
       public MenuPreTargetHandler {
  public:
-  MenuPreTargetHandlerAura(MenuController* controller, Widget* owner);
-  ~MenuPreTargetHandlerAura() override;
-
-  // aura::client:ActivationChangeObserver:
-  void OnWindowActivated(wm::ActivationChangeObserver::ActivationReason reason,
-                         aura::Window* gained_active,
-                         aura::Window* lost_active) override;
-
-  // aura::WindowObserver:
-  void OnWindowDestroying(aura::Window* window) override;
+  MenuPreTargetHandlerAndroid(MenuController* controller, Widget* owner);
+  ~MenuPreTargetHandlerAndroid() override;
 
   // ui::EventHandler:
   void OnCancelMode(ui::CancelModeEvent* event) override;
@@ -49,11 +34,11 @@ class VIEWS_EXPORT MenuPreTargetHandlerA
   void Cleanup();
 
   MenuController* controller_;
-  aura::Window* root_;
+  ui::WindowAndroid* root_;
 
-  DISALLOW_COPY_AND_ASSIGN(MenuPreTargetHandlerAura);
+  DISALLOW_COPY_AND_ASSIGN(MenuPreTargetHandlerAndroid);
 };
 
 }  // namespace views
 
-#endif  // UI_VIEWS_CONTROLS_MENU_MENU_PRE_TARGET_HANDLER_AURA_H_
+#endif  // UI_VIEWS_CONTROLS_MENU_MENU_PRE_TARGET_HANDLER_ANDROID_H_
--- a/ui/views/controls/native/native_view_host_aura.cc
+++ b/ui/views/controls/native/native_view_host_aura.cc
@@ -10,12 +10,7 @@
 #include "base/check.h"
 #include "base/optional.h"
 #include "build/build_config.h"
-#include "ui/aura/client/aura_constants.h"
-#include "ui/aura/client/focus_client.h"
-#include "ui/aura/window.h"
-#include "ui/aura/window_delegate.h"
-#include "ui/aura/window_occlusion_tracker.h"
-#include "ui/aura/window_targeter.h"
+#include "ui/android/window_android.h"
 #include "ui/base/cursor/cursor.h"
 #include "ui/base/hit_test.h"
 #include "ui/compositor/paint_recorder.h"
@@ -23,368 +18,118 @@
 #include "ui/views/controls/native/native_view_host.h"
 #include "ui/views/painter.h"
 #include "ui/views/view_class_properties.h"
-#include "ui/views/view_constants_aura.h"
 #include "ui/views/widget/widget.h"
 
 namespace views {
 
-class NativeViewHostAura::ClippingWindowDelegate : public aura::WindowDelegate {
- public:
-  ClippingWindowDelegate() = default;
-  ~ClippingWindowDelegate() override = default;
-
-  void set_native_view(aura::Window* native_view) {
-    native_view_ = native_view;
-  }
-
-  gfx::Size GetMinimumSize() const override { return gfx::Size(); }
-  gfx::Size GetMaximumSize() const override { return gfx::Size(); }
-  void OnBoundsChanged(const gfx::Rect& old_bounds,
-                       const gfx::Rect& new_bounds) override {}
-  gfx::NativeCursor GetCursor(const gfx::Point& point) override {
-    return gfx::kNullCursor;
-  }
-  int GetNonClientComponent(const gfx::Point& point) const override {
-    return HTCLIENT;
-  }
-  bool ShouldDescendIntoChildForEventHandling(
-      aura::Window* child,
-      const gfx::Point& location) override {
-    return true;
-  }
-  bool CanFocus() override {
-    // Ask the hosted native view's delegate because directly calling
-    // aura::Window::CanFocus() will call back into this when checking whether
-    // parents can focus.
-    return !native_view_ || !native_view_->delegate() ||
-           native_view_->delegate()->CanFocus();
-  }
-  void OnCaptureLost() override {}
-  void OnPaint(const ui::PaintContext& context) override {}
-  void OnDeviceScaleFactorChanged(float old_device_scale_factor,
-                                  float new_device_scale_factor) override {}
-  void OnWindowDestroying(aura::Window* window) override {}
-  void OnWindowDestroyed(aura::Window* window) override {}
-  void OnWindowTargetVisibilityChanged(bool visible) override {}
-  bool HasHitTestMask() const override { return false; }
-  void GetHitTestMask(SkPath* mask) const override {}
-
- private:
-  aura::Window* native_view_ = nullptr;
-};
-
-NativeViewHostAura::NativeViewHostAura(NativeViewHost* host) : host_(host) {}
-
-NativeViewHostAura::~NativeViewHostAura() {
-  if (host_->native_view()) {
-    host_->native_view()->RemoveObserver(this);
-    host_->native_view()->ClearProperty(views::kHostViewKey);
-    host_->native_view()->ClearProperty(aura::client::kHostWindowKey);
-    host_->native_view()->ClearProperty(
-        aura::client::kParentNativeViewAccessibleKey);
-    clipping_window_->ClearProperty(views::kHostViewKey);
-    if (host_->native_view()->parent() == clipping_window_.get())
-      clipping_window_->RemoveChild(host_->native_view());
-  }
+NativeViewHostAndroid::NativeViewHostAndroid(NativeViewHost* host) : host_(host) {}
+
+NativeViewHostAndroid::~NativeViewHostAndroid() {
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// NativeViewHostAura, NativeViewHostWrapper implementation:
-void NativeViewHostAura::AttachNativeView() {
-  if (!clipping_window_)
-    CreateClippingWindow();
-  clipping_window_delegate_->set_native_view(host_->native_view());
-  host_->native_view()->AddObserver(this);
-  host_->native_view()->SetProperty(views::kHostViewKey,
-                                    static_cast<View*>(host_));
-
-  original_transform_ = host_->native_view()->transform();
-  original_transform_changed_ = false;
-  AddClippingWindow();
-  InstallMask();
-  ApplyRoundedCorners();
+// NativeViewHostAndroid, NativeViewHostWrapper implementation:
+void NativeViewHostAndroid::AttachNativeView() {
 }
 
-void NativeViewHostAura::SetParentAccessible(
+void NativeViewHostAndroid::SetParentAccessible(
     gfx::NativeViewAccessible accessible) {
-  host_->native_view()->SetProperty(
-      aura::client::kParentNativeViewAccessibleKey, accessible);
 }
 
-gfx::NativeViewAccessible NativeViewHostAura::GetParentAccessible() {
-  return host_->native_view()->GetProperty(
-      aura::client::kParentNativeViewAccessibleKey);
-}
-
-void NativeViewHostAura::NativeViewDetaching(bool destroyed) {
-  // This method causes a succession of window tree changes. ScopedPause ensures
-  // that occlusion is recomputed at the end of the method instead of after each
-  // change.
-  base::Optional<aura::WindowOcclusionTracker::ScopedPause> pause_occlusion;
-  if (clipping_window_)
-    pause_occlusion.emplace();
-
-  clipping_window_delegate_->set_native_view(nullptr);
-  RemoveClippingWindow();
-  if (!destroyed) {
-    host_->native_view()->RemoveObserver(this);
-    host_->native_view()->ClearProperty(views::kHostViewKey);
-    host_->native_view()->ClearProperty(aura::client::kHostWindowKey);
-    host_->native_view()->ClearProperty(
-        aura::client::kParentNativeViewAccessibleKey);
-    if (original_transform_changed_)
-      host_->native_view()->SetTransform(original_transform_);
-    host_->native_view()->Hide();
-    if (host_->native_view()->parent())
-      Widget::ReparentNativeView(host_->native_view(), nullptr);
-  }
-}
-
-void NativeViewHostAura::AddedToWidget() {
-  if (!host_->native_view())
-    return;
-
-  AddClippingWindow();
-  if (host_->IsDrawn())
-    host_->native_view()->Show();
-  else
-    host_->native_view()->Hide();
-  host_->InvalidateLayout();
-}
-
-void NativeViewHostAura::RemovedFromWidget() {
-  if (host_->native_view()) {
-    // Clear kHostWindowKey before Hide() because it could be accessed during
-    // the call. In MUS aura, the hosting window could be destroyed at this
-    // point.
-    host_->native_view()->ClearProperty(aura::client::kHostWindowKey);
-
-    host_->native_view()->Hide();
-    if (host_->native_view()->parent())
-      host_->native_view()->parent()->RemoveChild(host_->native_view());
-    RemoveClippingWindow();
-  }
+gfx::NativeViewAccessible NativeViewHostAndroid::GetParentAccessible() {
+  return nullptr;
+}
+
+void NativeViewHostAndroid::NativeViewDetaching(bool destroyed) {
+}
+
+void NativeViewHostAndroid::AddedToWidget() {
 }
 
-bool NativeViewHostAura::SetCornerRadii(
+void NativeViewHostAndroid::RemovedFromWidget() {
+}
+
+bool NativeViewHostAndroid::SetCornerRadii(
     const gfx::RoundedCornersF& corner_radii) {
-  corner_radii_ = corner_radii;
-  ApplyRoundedCorners();
-  return true;
+  return false;
 }
 
-bool NativeViewHostAura::SetCustomMask(std::unique_ptr<ui::LayerOwner> mask) {
-  UninstallMask();
-  mask_ = std::move(mask);
-  if (mask_)
-    mask_->layer()->SetFillsBoundsOpaquely(false);
-  InstallMask();
-  return true;
+bool NativeViewHostAndroid::SetCustomMask(std::unique_ptr<ui::LayerOwner> mask) {
+  return false;
 }
 
-void NativeViewHostAura::SetHitTestTopInset(int top_inset) {
-  if (top_inset_ == top_inset)
-    return;
-  top_inset_ = top_inset;
-  UpdateInsets();
+void NativeViewHostAndroid::SetHitTestTopInset(int top_inset) {
 }
 
-void NativeViewHostAura::InstallClip(int x, int y, int w, int h) {
-  clip_rect_ = std::make_unique<gfx::Rect>(
-      host_->ConvertRectToWidget(gfx::Rect(x, y, w, h)));
+void NativeViewHostAndroid::InstallClip(int x, int y, int w, int h) {
 }
 
-int NativeViewHostAura::GetHitTestTopInset() const {
+int NativeViewHostAndroid::GetHitTestTopInset() const {
   return top_inset_;
 }
 
-bool NativeViewHostAura::HasInstalledClip() {
+bool NativeViewHostAndroid::HasInstalledClip() {
   return !!clip_rect_;
 }
 
-void NativeViewHostAura::UninstallClip() {
+void NativeViewHostAndroid::UninstallClip() {
   clip_rect_.reset();
 }
 
-void NativeViewHostAura::ShowWidget(int x,
+void NativeViewHostAndroid::ShowWidget(int x,
                                     int y,
                                     int w,
                                     int h,
                                     int native_w,
                                     int native_h) {
-  if (host_->fast_resize()) {
-    gfx::Point origin(x, y);
-    views::View::ConvertPointFromWidget(host_, &origin);
-    InstallClip(origin.x(), origin.y(), w, h);
-    native_w = host_->native_view()->bounds().width();
-    native_h = host_->native_view()->bounds().height();
-  } else {
-    gfx::Transform transform = original_transform_;
-    if (w > 0 && h > 0 && native_w > 0 && native_h > 0) {
-      transform.Scale(static_cast<SkScalar>(w) / native_w,
-                      static_cast<SkScalar>(h) / native_h);
-    }
-    // Only set the transform when it is actually different.
-    if (transform != host_->native_view()->transform()) {
-      host_->native_view()->SetTransform(transform);
-      original_transform_changed_ = true;
-    }
-  }
-
-  clipping_window_->SetBounds(clip_rect_ ? *clip_rect_ : gfx::Rect(x, y, w, h));
-  gfx::Point clip_offset = clipping_window_->bounds().origin();
-  host_->native_view()->SetBounds(
-      gfx::Rect(x - clip_offset.x(), y - clip_offset.y(), native_w, native_h));
-  host_->native_view()->Show();
-  clipping_window_->Show();
-}
-
-void NativeViewHostAura::HideWidget() {
-  host_->native_view()->Hide();
-  clipping_window_->Hide();
-}
-
-void NativeViewHostAura::SetFocus() {
-  aura::Window* window = host_->native_view();
-  aura::client::FocusClient* client = aura::client::GetFocusClient(window);
-  if (client)
-    client->FocusWindow(window);
 }
 
-gfx::NativeView NativeViewHostAura::GetNativeViewContainer() const {
-  return clipping_window_.get();
+void NativeViewHostAndroid::HideWidget() {
+}
+
+void NativeViewHostAndroid::SetFocus() {
+}
+
+gfx::NativeView NativeViewHostAndroid::GetNativeViewContainer() const {
+  return gfx::NativeView();
 }
 
-gfx::NativeViewAccessible NativeViewHostAura::GetNativeViewAccessible() {
+gfx::NativeViewAccessible NativeViewHostAndroid::GetNativeViewAccessible() {
   return nullptr;
 }
 
-gfx::NativeCursor NativeViewHostAura::GetCursor(int x, int y) {
-  if (host_->native_view())
-    return host_->native_view()->GetCursor(gfx::Point(x, y));
+gfx::NativeCursor NativeViewHostAndroid::GetCursor(int x, int y) {
   return gfx::kNullCursor;
 }
 
-void NativeViewHostAura::SetVisible(bool visible) {
-  if (!visible)
-    host_->native_view()->Hide();
-  else
-    host_->native_view()->Show();
-}
-
-void NativeViewHostAura::OnWindowBoundsChanged(
-    aura::Window* window,
-    const gfx::Rect& old_bounds,
-    const gfx::Rect& new_bounds,
-    ui::PropertyChangeReason reason) {
-  if (mask_)
-    mask_->layer()->SetBounds(gfx::Rect(host_->native_view()->bounds().size()));
-}
-
-void NativeViewHostAura::OnWindowDestroying(aura::Window* window) {
-  DCHECK(window == host_->native_view());
-  clipping_window_delegate_->set_native_view(nullptr);
-}
-
-void NativeViewHostAura::OnWindowDestroyed(aura::Window* window) {
-  DCHECK(window == host_->native_view());
-  host_->NativeViewDestroyed();
+void NativeViewHostAndroid::SetVisible(bool visible) {
 }
 
 // static
 NativeViewHostWrapper* NativeViewHostWrapper::CreateWrapper(
     NativeViewHost* host) {
-  return new NativeViewHostAura(host);
+  return new NativeViewHostAndroid(host);
+}
+
+void NativeViewHostAndroid::CreateClippingWindow() {
+}
+
+void NativeViewHostAndroid::AddClippingWindow() {
+}
+
+void NativeViewHostAndroid::RemoveClippingWindow() {
+}
+
+void NativeViewHostAndroid::ApplyRoundedCorners() {
+}
+
+void NativeViewHostAndroid::InstallMask() {
+}
+
+void NativeViewHostAndroid::UninstallMask() {
 }
 
-void NativeViewHostAura::CreateClippingWindow() {
-  clipping_window_delegate_ = std::make_unique<ClippingWindowDelegate>();
-  // Use WINDOW_TYPE_CONTROLLER type so descendant views (including popups) get
-  // positioned appropriately.
-  clipping_window_ = std::make_unique<aura::Window>(
-      clipping_window_delegate_.get(), aura::client::WINDOW_TYPE_CONTROL);
-  clipping_window_->Init(ui::LAYER_NOT_DRAWN);
-  clipping_window_->set_owned_by_parent(false);
-  clipping_window_->SetName("NativeViewHostAuraClip");
-  clipping_window_->layer()->SetMasksToBounds(true);
-  clipping_window_->SetProperty(views::kHostViewKey, static_cast<View*>(host_));
-  UpdateInsets();
-}
-
-void NativeViewHostAura::AddClippingWindow() {
-  RemoveClippingWindow();
-
-  host_->native_view()->SetProperty(aura::client::kHostWindowKey,
-                                    host_->GetWidget()->GetNativeView());
-  Widget::ReparentNativeView(host_->native_view(), clipping_window_.get());
-  if (host_->GetWidget()->GetNativeView()) {
-    Widget::ReparentNativeView(clipping_window_.get(),
-                               host_->GetWidget()->GetNativeView());
-  }
-}
-
-void NativeViewHostAura::RemoveClippingWindow() {
-  clipping_window_->Hide();
-  if (host_->native_view())
-    host_->native_view()->ClearProperty(aura::client::kHostWindowKey);
-
-  if (host_->native_view()->parent() == clipping_window_.get()) {
-    if (host_->GetWidget() && host_->GetWidget()->GetNativeView()) {
-      Widget::ReparentNativeView(host_->native_view(),
-                                 host_->GetWidget()->GetNativeView());
-    } else {
-      clipping_window_->RemoveChild(host_->native_view());
-    }
-  }
-  if (clipping_window_->parent())
-    clipping_window_->parent()->RemoveChild(clipping_window_.get());
-}
-
-void NativeViewHostAura::ApplyRoundedCorners() {
-  if (!host_->native_view())
-    return;
-
-  ui::Layer* layer = host_->native_view()->layer();
-  if (layer->rounded_corner_radii() != corner_radii_) {
-    layer->SetRoundedCornerRadius(corner_radii_);
-    layer->SetIsFastRoundedCorner(true);
-  }
-}
-
-void NativeViewHostAura::InstallMask() {
-  if (!mask_)
-    return;
-  if (host_->native_view()) {
-    mask_->layer()->SetBounds(gfx::Rect(host_->native_view()->bounds().size()));
-    host_->native_view()->layer()->SetMaskLayer(mask_->layer());
-  }
-}
-
-void NativeViewHostAura::UninstallMask() {
-  if (!host_->native_view() || !mask_)
-    return;
-
-  host_->native_view()->layer()->SetMaskLayer(nullptr);
-  mask_.reset();
-}
-
-void NativeViewHostAura::UpdateInsets() {
-  if (!clipping_window_)
-    return;
-
-  if (top_inset_ == 0) {
-    // The window targeter needs to be uninstalled when not used; keeping empty
-    // targeter here actually conflicts with ash::ImmersiveWindowTargeter on
-    // immersive mode in Ash.
-    // TODO(mukai): fix this.
-    clipping_window_->SetEventTargeter(nullptr);
-  } else {
-    if (!clipping_window_->targeter()) {
-      clipping_window_->SetEventTargeter(
-          std::make_unique<aura::WindowTargeter>());
-    }
-    clipping_window_->targeter()->SetInsets(gfx::Insets(top_inset_, 0, 0, 0));
-  }
+void NativeViewHostAndroid::UpdateInsets() {
 }
 
 }  // namespace views
--- a/ui/views/controls/native/native_view_host_aura.h
+++ b/ui/views/controls/native/native_view_host_aura.h
@@ -9,27 +9,21 @@
 
 #include "base/compiler_specific.h"
 #include "base/macros.h"
-#include "ui/aura/window_observer.h"
 #include "ui/compositor/layer_owner.h"
 #include "ui/gfx/geometry/rounded_corners_f.h"
 #include "ui/gfx/transform.h"
 #include "ui/views/controls/native/native_view_host_wrapper.h"
 #include "ui/views/views_export.h"
 
-namespace aura {
-class Window;
-}
-
 namespace views {
 
 class NativeViewHost;
 
-// Aura implementation of NativeViewHostWrapper.
-class NativeViewHostAura : public NativeViewHostWrapper,
-                           public aura::WindowObserver {
+// Android implementation of NativeViewHostWrapper.
+class NativeViewHostAndroid : public NativeViewHostWrapper {
  public:
-  explicit NativeViewHostAura(NativeViewHost* host);
-  ~NativeViewHostAura() override;
+  explicit NativeViewHostAndroid(NativeViewHost* host);
+  ~NativeViewHostAndroid() override;
 
   // Overridden from NativeViewHostWrapper:
   void AttachNativeView() override;
@@ -55,16 +49,7 @@ class NativeViewHostAura : public Native
   gfx::NativeViewAccessible GetParentAccessible() override;
 
  private:
-  friend class NativeViewHostAuraTest;
-  class ClippingWindowDelegate;
-
-  // Overridden from aura::WindowObserver:
-  void OnWindowDestroying(aura::Window* window) override;
-  void OnWindowDestroyed(aura::Window* window) override;
-  void OnWindowBoundsChanged(aura::Window* window,
-                             const gfx::Rect& old_bounds,
-                             const gfx::Rect& new_bounds,
-                             ui::PropertyChangeReason reason) override;
+  friend class NativeViewHostAndroidTest;
 
   void CreateClippingWindow();
 
@@ -91,12 +76,9 @@ class NativeViewHostAura : public Native
   // Our associated NativeViewHost.
   NativeViewHost* host_;
 
-  std::unique_ptr<ClippingWindowDelegate> clipping_window_delegate_;
-
   // Window that exists between the native view and the parent that allows for
   // clipping to occur. This is positioned in the coordinate space of
   // host_->GetWidget().
-  std::unique_ptr<aura::Window> clipping_window_;
   std::unique_ptr<gfx::Rect> clip_rect_;
 
   // This mask exists for the sake of SetCornerRadius().
@@ -118,9 +100,9 @@ class NativeViewHostAura : public Native
   // The top insets to exclude the underlying native view from the target.
   int top_inset_ = 0;
 
-  DISALLOW_COPY_AND_ASSIGN(NativeViewHostAura);
+  DISALLOW_COPY_AND_ASSIGN(NativeViewHostAndroid);
 };
 
 }  // namespace views
 
-#endif  // UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_AURA_H_
+#endif  // UI_VIEWS_CONTROLS_NATIVE_NATIVE_VIEW_HOST_ANDROID_H_
--- a/ui/views/event_monitor_aura.cc
+++ b/ui/views/event_monitor_aura.cc
@@ -8,8 +8,7 @@
 
 #include "base/check_op.h"
 #include "base/scoped_observer.h"
-#include "ui/aura/env.h"
-#include "ui/aura/window.h"
+#include "ui/android/window_android.h"
 #include "ui/events/event_observer.h"
 #include "ui/events/event_target.h"
 
@@ -17,31 +16,21 @@ namespace views {
 
 namespace {
 
-// An EventMonitorAura that removes its event observer on window destruction.
-class WindowMonitorAura : public EventMonitorAura, public aura::WindowObserver {
+// An EventMonitorAndroid that removes its event observer on window destruction.
+class WindowMonitorAndroid : public EventMonitorAndroid {
  public:
-  WindowMonitorAura(ui::EventObserver* event_observer,
-                    aura::Window* target_window,
+  WindowMonitorAndroid(ui::EventObserver* event_observer,
+                    ui::WindowAndroid* target_window,
                     const std::set<ui::EventType>& types)
-      : EventMonitorAura(event_observer, target_window, types),
+      : EventMonitorAndroid(event_observer, target_window, types),
         target_window_(target_window) {
-    window_observer_.Add(target_window);
-  }
-  ~WindowMonitorAura() override = default;
-
-  // aura::WindowObserver:
-  void OnWindowDestroying(aura::Window* window) override {
-    DCHECK_EQ(window, target_window_);
-    window_observer_.Remove(target_window_);
-    target_window_ = nullptr;
-    TearDown();
   }
+  ~WindowMonitorAndroid() override = default;
 
  private:
-  aura::Window* target_window_;
-  ScopedObserver<aura::Window, aura::WindowObserver> window_observer_{this};
+  ui::WindowAndroid* target_window_;
 
-  DISALLOW_COPY_AND_ASSIGN(WindowMonitorAura);
+  DISALLOW_COPY_AND_ASSIGN(WindowMonitorAndroid);
 };
 
 }  // namespace
@@ -51,8 +40,8 @@ std::unique_ptr<EventMonitor> EventMonit
     ui::EventObserver* event_observer,
     gfx::NativeWindow context,
     const std::set<ui::EventType>& types) {
-  return std::make_unique<EventMonitorAura>(event_observer,
-                                            aura::Env::GetInstance(), types);
+  return std::make_unique<EventMonitorAndroid>(event_observer,
+                                            nullptr, types);
 }
 
 // static
@@ -60,31 +49,27 @@ std::unique_ptr<EventMonitor> EventMonit
     ui::EventObserver* event_observer,
     gfx::NativeWindow target_window,
     const std::set<ui::EventType>& types) {
-  return std::make_unique<WindowMonitorAura>(event_observer, target_window,
+  return std::make_unique<WindowMonitorAndroid>(event_observer, nullptr,
                                              types);
 }
 
-EventMonitorAura::EventMonitorAura(ui::EventObserver* event_observer,
+EventMonitorAndroid::EventMonitorAndroid(ui::EventObserver* event_observer,
                                    ui::EventTarget* event_target,
                                    const std::set<ui::EventType>& types)
     : event_observer_(event_observer), event_target_(event_target) {
   DCHECK(event_observer_);
   DCHECK(event_target_);
-  aura::Env::GetInstance()->AddEventObserver(event_observer_, event_target,
-                                             types);
 }
 
-EventMonitorAura::~EventMonitorAura() {
+EventMonitorAndroid::~EventMonitorAndroid() {
   TearDown();
 }
 
-gfx::Point EventMonitorAura::GetLastMouseLocation() {
-  return aura::Env::GetInstance()->last_mouse_location();
+gfx::Point EventMonitorAndroid::GetLastMouseLocation() {
+  return gfx::Point();
 }
 
-void EventMonitorAura::TearDown() {
-  if (event_observer_)
-    aura::Env::GetInstance()->RemoveEventObserver(event_observer_);
+void EventMonitorAndroid::TearDown() {
   event_observer_ = nullptr;
 }
 
--- a/ui/views/event_monitor_aura.h
+++ b/ui/views/event_monitor_aura.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef UI_VIEWS_EVENT_MONITOR_AURA_H_
-#define UI_VIEWS_EVENT_MONITOR_AURA_H_
+#ifndef UI_VIEWS_EVENT_MONITOR_ANDROID_H_
+#define UI_VIEWS_EVENT_MONITOR_ANDROID_H_
 
 #include <set>
 
@@ -17,12 +17,12 @@ class EventTarget;
 namespace views {
 
 // Observes events by installing a pre-target handler on the ui::EventTarget.
-class EventMonitorAura : public EventMonitor {
+class EventMonitorAndroid : public EventMonitor {
  public:
-  EventMonitorAura(ui::EventObserver* event_observer,
+  EventMonitorAndroid(ui::EventObserver* event_observer,
                    ui::EventTarget* event_target,
                    const std::set<ui::EventType>& types);
-  ~EventMonitorAura() override;
+  ~EventMonitorAndroid() override;
 
   // EventMonitor:
   gfx::Point GetLastMouseLocation() override;
@@ -35,9 +35,9 @@ class EventMonitorAura : public EventMon
   ui::EventObserver* event_observer_;  // Weak. Owned by our owner.
   ui::EventTarget* event_target_;      // Weak.
 
-  DISALLOW_COPY_AND_ASSIGN(EventMonitorAura);
+  DISALLOW_COPY_AND_ASSIGN(EventMonitorAndroid);
 };
 
 }  // namespace views
 
-#endif  // UI_VIEWS_EVENT_MONITOR_AURA_H_
+#endif  // UI_VIEWS_EVENT_MONITOR_ANDROID_H_
--- a/ui/views/drag_utils_aura.cc
+++ b/ui/views/drag_utils_aura.cc
@@ -4,10 +4,7 @@
 
 #include "ui/views/drag_utils.h"
 
-#include "ui/aura/client/drag_drop_client.h"
-#include "ui/aura/window.h"
-#include "ui/aura/window_event_dispatcher.h"
-#include "ui/wm/core/coordinate_conversion.h"
+#include "ui/android/window_android.h"
 
 namespace views {
 
@@ -16,14 +13,6 @@ void RunShellDrag(gfx::NativeView view,
                   const gfx::Point& location,
                   int operation,
                   ui::mojom::DragEventSource source) {
-  gfx::Point screen_location(location);
-  wm::ConvertPointToScreen(view, &screen_location);
-  aura::Window* root_window = view->GetRootWindow();
-  if (aura::client::GetDragDropClient(root_window)) {
-    aura::client::GetDragDropClient(root_window)
-        ->StartDragAndDrop(std::move(data), root_window, view, screen_location,
-                           operation, source);
-  }
 }
 
 }  // namespace views
--- a/chrome/browser/ui/views/frame/native_browser_frame_factory_aurax11.cc
+++ b/chrome/browser/ui/views/frame/native_browser_frame_factory_aurax11.cc
@@ -4,10 +4,10 @@
 
 #include "chrome/browser/ui/views/frame/native_browser_frame_factory.h"
 
-#include "chrome/browser/ui/views/frame/desktop_browser_frame_aura_linux.h"
+#include "chrome/browser/ui/views/frame/desktop_browser_frame_aura.h"
 
 NativeBrowserFrame* NativeBrowserFrameFactory::Create(
     BrowserFrame* browser_frame,
     BrowserView* browser_view) {
-  return new DesktopBrowserFrameAuraLinux(browser_frame, browser_view);
+  return new DesktopBrowserFrameAndroid(browser_frame, browser_view);
 }
--- a/chrome/browser/ui/views/frame/desktop_browser_frame_aura.cc
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_aura.cc
@@ -7,10 +7,7 @@
 #include "chrome/app/chrome_command_ids.h"
 #include "chrome/browser/ui/views/frame/browser_desktop_window_tree_host.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
-#include "ui/aura/client/aura_constants.h"
-#include "ui/aura/window.h"
-#include "ui/aura/window_event_dispatcher.h"
-#include "ui/aura/window_observer.h"
+#include "ui/android/window_android.h"
 #include "ui/base/hit_test.h"
 #include "ui/base/models/simple_menu_model.h"
 #include "ui/gfx/font.h"
@@ -18,99 +15,62 @@
 #include "ui/views/widget/widget.h"
 #include "ui/wm/core/visibility_controller.h"
 
-using aura::Window;
+using ui::WindowAndroid;
 
 ///////////////////////////////////////////////////////////////////////////////
-// DesktopBrowserFrameAura, public:
+// DesktopBrowserFrameAndroid, public:
 
-DesktopBrowserFrameAura::DesktopBrowserFrameAura(
+DesktopBrowserFrameAndroid::DesktopBrowserFrameAndroid(
     BrowserFrame* browser_frame,
     BrowserView* browser_view)
-    : views::DesktopNativeWidgetAura(browser_frame),
-      browser_view_(browser_view),
-      browser_frame_(browser_frame),
-      browser_desktop_window_tree_host_(nullptr) {
-  GetNativeWindow()->SetName("BrowserFrameAura");
+    : browser_view_(browser_view),
+      browser_frame_(browser_frame) {
 }
 
 ///////////////////////////////////////////////////////////////////////////////
-// DesktopBrowserFrameAura, protected:
+// DesktopBrowserFrameAndroid, protected:
 
-DesktopBrowserFrameAura::~DesktopBrowserFrameAura() {
-}
-
-///////////////////////////////////////////////////////////////////////////////
-// DesktopBrowserFrameAura, views::DesktopNativeWidgetAura overrides:
-
-void DesktopBrowserFrameAura::OnHostClosed() {
-  aura::client::SetVisibilityClient(GetNativeView()->GetRootWindow(), nullptr);
-  DesktopNativeWidgetAura::OnHostClosed();
-}
-
-void DesktopBrowserFrameAura::InitNativeWidget(
-    views::Widget::InitParams params) {
-  browser_desktop_window_tree_host_ =
-      BrowserDesktopWindowTreeHost::CreateBrowserDesktopWindowTreeHost(
-          browser_frame_,
-          this,
-          browser_view_,
-          browser_frame_);
-  params.desktop_window_tree_host =
-      browser_desktop_window_tree_host_->AsDesktopWindowTreeHost();
-  DesktopNativeWidgetAura::InitNativeWidget(std::move(params));
-
-  visibility_controller_ = std::make_unique<wm::VisibilityController>();
-  aura::client::SetVisibilityClient(GetNativeView()->GetRootWindow(),
-                                    visibility_controller_.get());
-  wm::SetChildWindowVisibilityChangesAnimated(
-      GetNativeView()->GetRootWindow());
+DesktopBrowserFrameAndroid::~DesktopBrowserFrameAndroid() {
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// DesktopBrowserFrameAura, NativeBrowserFrame implementation:
+// DesktopBrowserFrameAndroid, NativeBrowserFrame implementation:
 
-views::Widget::InitParams DesktopBrowserFrameAura::GetWidgetParams() {
+views::Widget::InitParams DesktopBrowserFrameAndroid::GetWidgetParams() {
   views::Widget::InitParams params;
-  params.native_widget = this;
   return params;
 }
 
-bool DesktopBrowserFrameAura::UseCustomFrame() const {
+bool DesktopBrowserFrameAndroid::UseCustomFrame() const {
   return true;
 }
 
-bool DesktopBrowserFrameAura::UsesNativeSystemMenu() const {
-  return browser_desktop_window_tree_host_->UsesNativeSystemMenu();
+bool DesktopBrowserFrameAndroid::UsesNativeSystemMenu() const {
+  return true;
 }
 
-int DesktopBrowserFrameAura::GetMinimizeButtonOffset() const {
-  return browser_desktop_window_tree_host_->GetMinimizeButtonOffset();
+int DesktopBrowserFrameAndroid::GetMinimizeButtonOffset() const {
+  return 0;
 }
 
-bool DesktopBrowserFrameAura::ShouldSaveWindowPlacement() const {
+bool DesktopBrowserFrameAndroid::ShouldSaveWindowPlacement() const {
   // The placement can always be stored.
   return true;
 }
 
-void DesktopBrowserFrameAura::GetWindowPlacement(
+void DesktopBrowserFrameAndroid::GetWindowPlacement(
     gfx::Rect* bounds,
     ui::WindowShowState* show_state) const {
-  *bounds = GetWidget()->GetRestoredBounds();
-  if (IsMaximized())
-    *show_state = ui::SHOW_STATE_MAXIMIZED;
-  else if (IsMinimized())
-    *show_state = ui::SHOW_STATE_MINIMIZED;
-  else
-    *show_state = ui::SHOW_STATE_NORMAL;
+  *show_state = ui::SHOW_STATE_NORMAL;
 }
 
 content::KeyboardEventProcessingResult
-DesktopBrowserFrameAura::PreHandleKeyboardEvent(
+DesktopBrowserFrameAndroid::PreHandleKeyboardEvent(
     const content::NativeWebKeyboardEvent& event) {
   return content::KeyboardEventProcessingResult::NOT_HANDLED;
 }
 
-bool DesktopBrowserFrameAura::HandleKeyboardEvent(
+bool DesktopBrowserFrameAndroid::HandleKeyboardEvent(
     const content::NativeWebKeyboardEvent& event) {
   return false;
 }
--- a/chrome/browser/ui/views/frame/desktop_browser_frame_aura.h
+++ b/chrome/browser/ui/views/frame/desktop_browser_frame_aura.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_AURA_H_
-#define CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_AURA_H_
+#ifndef CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
+#define CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
 
 #include <memory>
 
@@ -21,26 +21,21 @@ class VisibilityController;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
-// DesktopBrowserFrameAura
+// DesktopBrowserFrameAndroid
 //
-//  DesktopBrowserFrameAura is a DesktopNativeWidgetAura subclass that provides
+//  DesktopBrowserFrameAndroid is a DesktopNativeWidgetAndroid subclass that provides
 //  the window frame for the Chrome browser window.
 //
-class DesktopBrowserFrameAura : public views::DesktopNativeWidgetAura,
-                                public NativeBrowserFrame {
+class DesktopBrowserFrameAndroid : public NativeBrowserFrame {
  public:
-  DesktopBrowserFrameAura(BrowserFrame* browser_frame,
+  DesktopBrowserFrameAndroid(BrowserFrame* browser_frame,
                           BrowserView* browser_view);
 
   BrowserView* browser_view() const { return browser_view_; }
   BrowserFrame* browser_frame() const { return browser_frame_; }
 
  protected:
-  ~DesktopBrowserFrameAura() override;
-
-  // Overridden from views::DesktopNativeWidgetAura:
-  void OnHostClosed() override;
-  void InitNativeWidget(views::Widget::InitParams params) override;
+  ~DesktopBrowserFrameAndroid() override;
 
   // Overridden from NativeBrowserFrame:
   views::Widget::InitParams GetWidgetParams() override;
@@ -60,12 +55,9 @@ class DesktopBrowserFrameAura : public v
   BrowserView* browser_view_;
   BrowserFrame* browser_frame_;
 
-  // Owned by the RootWindow.
-  BrowserDesktopWindowTreeHost* browser_desktop_window_tree_host_;
-
   std::unique_ptr<wm::VisibilityController> visibility_controller_;
 
-  DISALLOW_COPY_AND_ASSIGN(DesktopBrowserFrameAura);
+  DISALLOW_COPY_AND_ASSIGN(DesktopBrowserFrameAndroid);
 };
 
-#endif  // CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_AURA_H_
+#endif  // CHROME_BROWSER_UI_VIEWS_FRAME_DESKTOP_BROWSER_FRAME_ANDROID_H_
--- a/chrome/browser/download/drag_download_item_aura.cc
+++ b/chrome/browser/download/drag_download_item_aura.cc
@@ -34,30 +34,4 @@ void DragDownloadItem(const download::Do
                       gfx::NativeView view) {
   DCHECK(download);
   DCHECK_EQ(download::DownloadItem::COMPLETE, download->GetState());
-
-  aura::Window* root_window = view->GetRootWindow();
-  if (!root_window || !aura::client::GetDragDropClient(root_window))
-    return;
-
-  // Set up our OLE machinery
-  auto data = std::make_unique<ui::OSExchangeData>();
-
-  button_drag_utils::SetDragImage(
-      GURL(), download->GetFileNameToReportUser().BaseName().LossyDisplayName(),
-      icon ? icon->AsImageSkia() : gfx::ImageSkia(), nullptr,
-      *views::Widget::GetTopLevelWidgetForNativeView(view), data.get());
-
-  base::FilePath full_path = download->GetTargetFilePath();
-  std::vector<ui::FileInfo> file_infos;
-  file_infos.push_back(
-      ui::FileInfo(full_path, download->GetFileNameToReportUser()));
-  data->SetFilenames(file_infos);
-
-  gfx::Point location = display::Screen::GetScreen()->GetCursorScreenPoint();
-  // TODO(varunjain): Properly determine and send DragEventSource below.
-  aura::client::GetDragDropClient(root_window)
-      ->StartDragAndDrop(
-          std::move(data), root_window, view, location,
-          ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_LINK,
-          ui::mojom::DragEventSource::kMouse);
 }
--- a/ui/base/dragdrop/os_exchange_data_provider_non_backed.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_non_backed.cc
@@ -19,13 +19,13 @@
 
 namespace ui {
 
-OSExchangeDataProviderNonBacked::OSExchangeDataProviderNonBacked() = default;
+OSExchangeDataProviderAndroid::OSExchangeDataProviderAndroid() = default;
 
-OSExchangeDataProviderNonBacked::~OSExchangeDataProviderNonBacked() = default;
+OSExchangeDataProviderAndroid::~OSExchangeDataProviderAndroid() = default;
 
-std::unique_ptr<OSExchangeDataProvider> OSExchangeDataProviderNonBacked::Clone()
+std::unique_ptr<OSExchangeDataProvider> OSExchangeDataProviderAndroid::Clone()
     const {
-  auto clone = std::make_unique<OSExchangeDataProviderNonBacked>();
+  auto clone = std::make_unique<OSExchangeDataProviderAndroid>();
 
   clone->formats_ = formats_;
   clone->string_ = string_;
@@ -40,7 +40,7 @@ std::unique_ptr<OSExchangeDataProvider>
   return clone;
 }
 
-void OSExchangeDataProviderNonBacked::MarkOriginatedFromRenderer() {
+void OSExchangeDataProviderAndroid::MarkOriginatedFromRenderer() {
   // TODO(dcheng): Currently unneeded because ChromeOS Aura correctly separates
   // URL and filename metadata, and does not implement the DownloadURL protocol.
 #if !defined(OS_CHROMEOS)
@@ -48,7 +48,7 @@ void OSExchangeDataProviderNonBacked::Ma
 #endif
 }
 
-bool OSExchangeDataProviderNonBacked::DidOriginateFromRenderer() const {
+bool OSExchangeDataProviderAndroid::DidOriginateFromRenderer() const {
 #if defined(OS_CHROMEOS)
   return false;
 #else
@@ -56,7 +56,7 @@ bool OSExchangeDataProviderNonBacked::Di
 #endif
 }
 
-void OSExchangeDataProviderNonBacked::SetString(const base::string16& data) {
+void OSExchangeDataProviderAndroid::SetString(const base::string16& data) {
   if (HasString())
     return;
 
@@ -64,7 +64,7 @@ void OSExchangeDataProviderNonBacked::Se
   formats_ |= OSExchangeData::STRING;
 }
 
-void OSExchangeDataProviderNonBacked::SetURL(const GURL& url,
+void OSExchangeDataProviderAndroid::SetURL(const GURL& url,
                                              const base::string16& title) {
   url_ = url;
   title_ = title;
@@ -73,26 +73,26 @@ void OSExchangeDataProviderNonBacked::Se
   SetString(base::UTF8ToUTF16(url.spec()));
 }
 
-void OSExchangeDataProviderNonBacked::SetFilename(const base::FilePath& path) {
+void OSExchangeDataProviderAndroid::SetFilename(const base::FilePath& path) {
   filenames_.clear();
   filenames_.push_back(FileInfo(path, base::FilePath()));
   formats_ |= OSExchangeData::FILE_NAME;
 }
 
-void OSExchangeDataProviderNonBacked::SetFilenames(
+void OSExchangeDataProviderAndroid::SetFilenames(
     const std::vector<FileInfo>& filenames) {
   filenames_ = filenames;
   formats_ |= OSExchangeData::FILE_NAME;
 }
 
-void OSExchangeDataProviderNonBacked::SetPickledData(
+void OSExchangeDataProviderAndroid::SetPickledData(
     const ClipboardFormatType& format,
     const base::Pickle& data) {
   pickle_data_[format] = data;
   formats_ |= OSExchangeData::PICKLED_DATA;
 }
 
-bool OSExchangeDataProviderNonBacked::GetString(base::string16* data) const {
+bool OSExchangeDataProviderAndroid::GetString(base::string16* data) const {
 #if defined(OS_LINUX) || defined(OS_CHROMEOS)
   if (HasFile()) {
     // Various Linux file managers both pass a list of file:// URIs and set the
@@ -108,7 +108,7 @@ bool OSExchangeDataProviderNonBacked::Ge
   return true;
 }
 
-bool OSExchangeDataProviderNonBacked::GetURLAndTitle(
+bool OSExchangeDataProviderAndroid::GetURLAndTitle(
     FilenameToURLPolicy policy,
     GURL* url,
     base::string16* title) const {
@@ -127,7 +127,7 @@ bool OSExchangeDataProviderNonBacked::Ge
   return true;
 }
 
-bool OSExchangeDataProviderNonBacked::GetFilename(base::FilePath* path) const {
+bool OSExchangeDataProviderAndroid::GetFilename(base::FilePath* path) const {
   if ((formats_ & OSExchangeData::FILE_NAME) == 0)
     return false;
   DCHECK(!filenames_.empty());
@@ -135,7 +135,7 @@ bool OSExchangeDataProviderNonBacked::Ge
   return true;
 }
 
-bool OSExchangeDataProviderNonBacked::GetFilenames(
+bool OSExchangeDataProviderAndroid::GetFilenames(
     std::vector<FileInfo>* filenames) const {
   if ((formats_ & OSExchangeData::FILE_NAME) == 0)
     return false;
@@ -143,7 +143,7 @@ bool OSExchangeDataProviderNonBacked::Ge
   return true;
 }
 
-bool OSExchangeDataProviderNonBacked::GetPickledData(
+bool OSExchangeDataProviderAndroid::GetPickledData(
     const ClipboardFormatType& format,
     base::Pickle* data) const {
   const auto i = pickle_data_.find(format);
@@ -154,11 +154,11 @@ bool OSExchangeDataProviderNonBacked::Ge
   return true;
 }
 
-bool OSExchangeDataProviderNonBacked::HasString() const {
+bool OSExchangeDataProviderAndroid::HasString() const {
   return (formats_ & OSExchangeData::STRING) != 0;
 }
 
-bool OSExchangeDataProviderNonBacked::HasURL(FilenameToURLPolicy policy) const {
+bool OSExchangeDataProviderAndroid::HasURL(FilenameToURLPolicy policy) const {
   if ((formats_ & OSExchangeData::URL) != 0) {
     return true;
   }
@@ -168,31 +168,31 @@ bool OSExchangeDataProviderNonBacked::Ha
           GetFileURL(nullptr));
 }
 
-bool OSExchangeDataProviderNonBacked::HasFile() const {
+bool OSExchangeDataProviderAndroid::HasFile() const {
   return (formats_ & OSExchangeData::FILE_NAME) != 0;
 }
 
-bool OSExchangeDataProviderNonBacked::HasCustomFormat(
+bool OSExchangeDataProviderAndroid::HasCustomFormat(
     const ClipboardFormatType& format) const {
   return base::Contains(pickle_data_, format);
 }
 
 #if defined(OS_LINUX) || defined(OS_CHROMEOS)
-void OSExchangeDataProviderNonBacked::SetFileContents(
+void OSExchangeDataProviderAndroid::SetFileContents(
     const base::FilePath& filename,
     const std::string& file_contents) {
   NOTIMPLEMENTED();
 }
 #endif
 
-void OSExchangeDataProviderNonBacked::SetHtml(const base::string16& html,
+void OSExchangeDataProviderAndroid::SetHtml(const base::string16& html,
                                               const GURL& base_url) {
   formats_ |= OSExchangeData::HTML;
   html_ = html;
   base_url_ = base_url;
 }
 
-bool OSExchangeDataProviderNonBacked::GetHtml(base::string16* html,
+bool OSExchangeDataProviderAndroid::GetHtml(base::string16* html,
                                               GURL* base_url) const {
   if ((formats_ & OSExchangeData::HTML) == 0)
     return false;
@@ -201,26 +201,26 @@ bool OSExchangeDataProviderNonBacked::Ge
   return true;
 }
 
-bool OSExchangeDataProviderNonBacked::HasHtml() const {
+bool OSExchangeDataProviderAndroid::HasHtml() const {
   return ((formats_ & OSExchangeData::HTML) != 0);
 }
 
-void OSExchangeDataProviderNonBacked::SetDragImage(
+void OSExchangeDataProviderAndroid::SetDragImage(
     const gfx::ImageSkia& image,
     const gfx::Vector2d& cursor_offset) {
   drag_image_ = image;
   drag_image_offset_ = cursor_offset;
 }
 
-gfx::ImageSkia OSExchangeDataProviderNonBacked::GetDragImage() const {
+gfx::ImageSkia OSExchangeDataProviderAndroid::GetDragImage() const {
   return drag_image_;
 }
 
-gfx::Vector2d OSExchangeDataProviderNonBacked::GetDragImageOffset() const {
+gfx::Vector2d OSExchangeDataProviderAndroid::GetDragImageOffset() const {
   return drag_image_offset_;
 }
 
-bool OSExchangeDataProviderNonBacked::GetFileURL(GURL* url) const {
+bool OSExchangeDataProviderAndroid::GetFileURL(GURL* url) const {
   base::FilePath file_path;
   if (!GetFilename(&file_path))
     return false;
@@ -234,7 +234,7 @@ bool OSExchangeDataProviderNonBacked::Ge
   return true;
 }
 
-bool OSExchangeDataProviderNonBacked::GetPlainTextURL(GURL* url) const {
+bool OSExchangeDataProviderAndroid::GetPlainTextURL(GURL* url) const {
   if ((formats_ & OSExchangeData::STRING) == 0)
     return false;
 
@@ -247,12 +247,12 @@ bool OSExchangeDataProviderNonBacked::Ge
   return true;
 }
 
-void OSExchangeDataProviderNonBacked::SetSource(
+void OSExchangeDataProviderAndroid::SetSource(
     std::unique_ptr<DataTransferEndpoint> data_source) {
   source_ = std::move(data_source);
 }
 
-DataTransferEndpoint* OSExchangeDataProviderNonBacked::GetSource() const {
+DataTransferEndpoint* OSExchangeDataProviderAndroid::GetSource() const {
   return source_.get();
 }
 
--- a/ui/base/dragdrop/os_exchange_data_provider_non_backed.h
+++ b/ui/base/dragdrop/os_exchange_data_provider_non_backed.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_NON_BACKED_H_
-#define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_NON_BACKED_H_
+#ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
+#define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
 
 #include <map>
 #include <memory>
@@ -28,15 +28,15 @@ class ClipboardFormatType;
 // Simple OSExchangeDataProvider implementation for aura-based ports with no
 // actual platform integration. So data managed by this class is exchangeable
 // only among Chromium windows and is available only while it is alive.
-class COMPONENT_EXPORT(UI_BASE) OSExchangeDataProviderNonBacked
+class COMPONENT_EXPORT(UI_BASE) OSExchangeDataProviderAndroid
     : public OSExchangeDataProvider {
  public:
-  OSExchangeDataProviderNonBacked();
-  OSExchangeDataProviderNonBacked(const OSExchangeDataProviderNonBacked&) =
+  OSExchangeDataProviderAndroid();
+  OSExchangeDataProviderAndroid(const OSExchangeDataProviderAndroid&) =
       delete;
-  OSExchangeDataProviderNonBacked& operator=(
-      const OSExchangeDataProviderNonBacked&) = delete;
-  ~OSExchangeDataProviderNonBacked() override;
+  OSExchangeDataProviderAndroid& operator=(
+      const OSExchangeDataProviderAndroid&) = delete;
+  ~OSExchangeDataProviderAndroid() override;
 
   // Overridden from OSExchangeDataProvider:
   std::unique_ptr<OSExchangeDataProvider> Clone() const override;
@@ -120,4 +120,4 @@ class COMPONENT_EXPORT(UI_BASE) OSExchan
 
 }  // namespace ui
 
-#endif  // UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_NON_BACKED_H_
+#endif  // UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_ANDROID_H_
--- a/chrome/browser/renderer_context_menu/render_view_context_menu.cc
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
@@ -1751,16 +1751,6 @@ void RenderViewContextMenu::AppendLangua
 #if defined(OS_MAC)
   menu_model_.AddItemWithStringId(IDC_CONTENT_CONTEXT_LANGUAGE_SETTINGS,
                                   IDS_CONTENT_CONTEXT_LANGUAGE_SETTINGS);
-#else
-  if (!spelling_options_submenu_observer_) {
-    const int kLanguageRadioGroup = 1;
-    spelling_options_submenu_observer_ =
-        std::make_unique<SpellingOptionsSubMenuObserver>(this, this,
-                                                         kLanguageRadioGroup);
-  }
-
-  spelling_options_submenu_observer_->InitMenu(params_);
-  observers_.AddObserver(spelling_options_submenu_observer_.get());
 #endif
 }
 
--- a/chrome/browser/renderer_context_menu/render_view_context_menu.h
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.h
@@ -41,7 +41,6 @@ class Profile;
 class QuickAnswersMenuObserver;
 class SharedClipboardContextMenuObserver;
 class SpellingMenuObserver;
-class SpellingOptionsSubMenuObserver;
 
 namespace content {
 class RenderFrameHost;
@@ -272,13 +271,6 @@ class RenderViewContextMenu : public Ren
       accessibility_labels_menu_observer_;
   ui::SimpleMenuModel accessibility_labels_submenu_model_;
 
-#if !defined(OS_MAC)
-  // An observer that handles the submenu for showing spelling options. This
-  // submenu lets users select the spelling language, for example.
-  std::unique_ptr<SpellingOptionsSubMenuObserver>
-      spelling_options_submenu_observer_;
-#endif
-
 #if defined(OS_CHROMEOS)
   // An observer that handles "Open with <app>" items.
   std::unique_ptr<RenderViewContextMenuObserver> open_with_menu_observer_;
--- a/chrome/browser/ui/views/status_icons/status_icon_button_linux.cc
+++ b/chrome/browser/ui/views/status_icons/status_icon_button_linux.cc
@@ -74,12 +74,6 @@ void StatusIconButtonLinux::OnSetDelegat
 
   auto* window = widget_->GetNativeWindow();
   DCHECK(window);
-  host_ = window->GetHost();
-  if (host_->GetAcceleratedWidget() == gfx::kNullAcceleratedWidget) {
-    delegate_->OnImplInitializationFailed();
-    // |this| might be destroyed.
-    return;
-  }
 
   widget_->SetContentsView(this);
   set_owned_by_client();
@@ -110,20 +104,12 @@ void StatusIconButtonLinux::PaintButtonC
   gfx::ScopedCanvas scoped_canvas(canvas);
   canvas->UndoDeviceScaleFactor();
 
-  gfx::Rect bounds = host_->GetBoundsInPixels();
   const gfx::ImageSkia& image = delegate_->GetImage();
 
   // If the image fits in the window, center it.  But if it won't fit, downscale
   // it preserving aspect ratio.
-  float scale =
-      std::min({1.0f, static_cast<float>(bounds.width()) / image.width(),
-                static_cast<float>(bounds.height()) / image.height()});
-  float x_offset = (bounds.width() - scale * image.width()) / 2.0f;
-  float y_offset = (bounds.height() - scale * image.height()) / 2.0f;
 
   gfx::Transform transform;
-  transform.Translate(x_offset, y_offset);
-  transform.Scale(scale, scale);
   canvas->Transform(transform);
 
   cc::PaintFlags flags;
--- a/base/process/kill.h
+++ b/base/process/kill.h
@@ -113,7 +113,7 @@ BASE_EXPORT TerminationStatus GetTermina
 BASE_EXPORT TerminationStatus GetKnownDeadTerminationStatus(
     ProcessHandle handle, int* exit_code);
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
 // Spawns a thread to wait asynchronously for the child |process| to exit
 // and then reaps it.
 BASE_EXPORT void EnsureProcessGetsReaped(Process process);
--- a/base/process/kill_posix.cc
+++ b/base/process/kill_posix.cc
@@ -160,7 +160,7 @@ void EnsureProcessTerminated(Process pro
       0, new BackgroundReaper(std::move(process), TimeDelta::FromSeconds(2)));
 }
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
 void EnsureProcessGetsReaped(Process process) {
   DCHECK(!process.is_current());
 
--- a/components/permissions/permission_request.cc
+++ b/components/permissions/permission_request.cc
@@ -18,7 +18,7 @@ ContentSettingsType PermissionRequest::G
   return ContentSettingsType::DEFAULT;
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 base::Optional<base::string16> PermissionRequest::GetChipText() const {
   return base::nullopt;
 }
--- a/components/permissions/permission_request.h
+++ b/components/permissions/permission_request.h
@@ -59,7 +59,7 @@ class PermissionRequest {
   virtual base::string16 GetQuietMessageText() const;
 #endif
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Returns the short text for the chip button related to this permission.
   virtual base::Optional<base::string16> GetChipText() const;
 #endif
--- a/components/permissions/permission_request_impl.cc
+++ b/components/permissions/permission_request_impl.cc
@@ -252,7 +252,7 @@ base::string16 PermissionRequestImpl::Ge
   return l10n_util::GetStringUTF16(message_id);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 base::Optional<base::string16> PermissionRequestImpl::GetChipText() const {
   int message_id;
   switch (content_settings_type_) {
--- a/components/permissions/permission_request_impl.h
+++ b/components/permissions/permission_request_impl.h
@@ -42,7 +42,7 @@ class PermissionRequestImpl : public Per
   base::string16 GetQuietTitleText() const override;
   base::string16 GetQuietMessageText() const override;
 #endif
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   base::Optional<base::string16> GetChipText() const override;
 #endif
   base::string16 GetMessageTextFragment() const override;
--- a/chrome/browser/ui/views/location_bar/permission_chip.cc
+++ b/chrome/browser/ui/views/location_bar/permission_chip.cc
@@ -241,22 +241,6 @@ void PermissionChip::UpdatePermissionIco
                              views::style::STYLE_DIALOG_BUTTON_DEFAULT);
 
   chip_button_->SetEnabledTextColors(enabled_text_color);
-  chip_button_->SetImageModel(
-      views::Button::STATE_NORMAL,
-      ui::ImageModel::FromVectorIcon(GetPermissionIconId(), enabled_text_color,
-                                     GetIconSize()));
-}
-
-const gfx::VectorIcon& PermissionChip::GetPermissionIconId() {
-  auto requests = delegate_->Requests();
-  if (requests.size() == 1)
-    return requests[0]->GetIconId();
-
-  // When we have two requests, it must be microphone & camera. Then we need to
-  // use the icon from the camera request.
-  return IsCameraPermission(requests[0]->GetPermissionRequestType())
-             ? requests[0]->GetIconId()
-             : requests[1]->GetIconId();
 }
 
 base::string16 PermissionChip::GetPermissionMessage() {
--- a/chrome/browser/ui/views/location_bar/permission_chip.h
+++ b/chrome/browser/ui/views/location_bar/permission_chip.h
@@ -66,7 +66,6 @@ class PermissionChip : public views::Vie
   int GetIconSize() const;
   void UpdatePermissionIconAndTextColor();
   base::string16 GetPermissionMessage();
-  const gfx::VectorIcon& GetPermissionIconId();
 
   Browser* browser_ = nullptr;
   permissions::PermissionPrompt::Delegate* delegate_ = nullptr;
--- a/chrome/browser/nearby_sharing/share_target.cc
+++ b/chrome/browser/nearby_sharing/share_target.cc
@@ -6,8 +6,6 @@
 
 #include <utility>
 
-ShareTarget::ShareTarget() = default;
-
 ShareTarget::ShareTarget(std::string device_name,
                          GURL image_url,
                          nearby_share::mojom::ShareTargetType type,
@@ -35,8 +33,6 @@ ShareTarget& ShareTarget::operator=(cons
 
 ShareTarget& ShareTarget::operator=(ShareTarget&&) = default;
 
-ShareTarget::~ShareTarget() = default;
-
 std::vector<int64_t> ShareTarget::GetAttachmentIds() const {
   std::vector<int64_t> attachment_ids;
 
--- a/chrome/browser/policy/chrome_browser_cloud_management_controller_desktop.cc
+++ b/chrome/browser/policy/chrome_browser_cloud_management_controller_desktop.cc
@@ -43,7 +43,7 @@
 #include "chrome/browser/policy/browser_dm_token_storage_mac.h"
 #endif  // defined(OS_MAC)
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_ANDROID)
 #include "chrome/browser/policy/browser_dm_token_storage_linux.h"
 #endif  // defined(OS_LINUX) || defined(OS_CHROMEOS)
 
@@ -176,10 +176,12 @@ void ChromeBrowserCloudManagementControl
 
 #if defined(OS_MAC)
   storage_delegate = std::make_unique<BrowserDMTokenStorageMac>();
-#elif defined(OS_LINUX) || defined(OS_CHROMEOS)
+#elif defined(OS_CHROMEOS)
   storage_delegate = std::make_unique<BrowserDMTokenStorageLinux>();
 #elif defined(OS_WIN)
   storage_delegate = std::make_unique<BrowserDMTokenStorageWin>();
+#elif defined(OS_ANDROID)
+  storage_delegate = std::make_unique<BrowserDMTokenStorageAndroid>();
 #else
   NOT_REACHED();
 #endif
--- a/ui/views/bubble/bubble_dialog_delegate_view.cc
+++ b/ui/views/bubble/bubble_dialog_delegate_view.cc
@@ -185,7 +185,7 @@ class BubbleDialogDelegate::AnchorViewOb
 
 // This class is responsible for observing events on a BubbleDialogDelegate's
 // anchor widget and notifying the BubbleDialogDelegate of them.
-#if defined(OS_APPLE)
+#if defined(OS_APPLE) || defined(OS_ANDROID)
 class BubbleDialogDelegate::AnchorWidgetObserver : public WidgetObserver {
 #else
 class BubbleDialogDelegate::AnchorWidgetObserver : public WidgetObserver,
@@ -196,7 +196,7 @@ class BubbleDialogDelegate::AnchorWidget
   AnchorWidgetObserver(BubbleDialogDelegate* owner, Widget* widget)
       : owner_(owner) {
     widget_observer_.Add(widget);
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_ANDROID)
     window_observer_.Add(widget->GetNativeWindow());
 #endif
   }
@@ -204,7 +204,7 @@ class BubbleDialogDelegate::AnchorWidget
 
   // WidgetObserver:
   void OnWidgetDestroying(Widget* widget) override {
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_ANDROID)
     window_observer_.Remove(widget->GetNativeWindow());
 #endif
     widget_observer_.Remove(widget);
@@ -220,7 +220,7 @@ class BubbleDialogDelegate::AnchorWidget
     owner_->OnAnchorBoundsChanged();
   }
 
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_ANDROID)
   // aura::WindowObserver:
   void OnWindowTransformed(aura::Window* window,
                            ui::PropertyChangeReason reason) override {
@@ -239,7 +239,7 @@ class BubbleDialogDelegate::AnchorWidget
  private:
   BubbleDialogDelegate* owner_;
   ScopedObserver<views::Widget, views::WidgetObserver> widget_observer_{this};
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_ANDROID)
   ScopedObserver<aura::Window, aura::WindowObserver> window_observer_{this};
 #endif
 };
@@ -556,7 +556,7 @@ gfx::Rect BubbleDialogDelegate::GetAncho
   anchor_rect_ = GetAnchorView()->GetAnchorBoundsInScreen();
   anchor_rect_->Inset(anchor_view_insets_);
 
-#if !defined(OS_APPLE)
+#if !defined(OS_APPLE) && !defined(OS_ANDROID)
   // GetAnchorBoundsInScreen returns values that take anchor widget's
   // translation into account, so undo that here. Without this, features which
   // apply transforms on windows such as ChromeOS overview mode will see bubbles
--- a/components/payments/content/android/java/src/org/chromium/components/payments/MojoPaymentRequestGateKeeper.java
+++ b/components/payments/content/android/java/src/org/chromium/components/payments/MojoPaymentRequestGateKeeper.java
@@ -54,7 +54,7 @@ import org.chromium.payments.mojom.Payme
     // Implement PaymentRequest:
     @Override
     public void init(PaymentRequestClient client, PaymentMethodData[] methodData,
-            PaymentDetails details, PaymentOptions options, boolean googlePayBridgeEligible) {
+            PaymentDetails details, PaymentOptions options) {
         if (mPaymentRequestService != null) {
             mPaymentRequestService.abortForInvalidDataFromRenderer(
                     ErrorStrings.ATTEMPTED_INITIALIZATION_TWICE);
@@ -65,7 +65,7 @@ import org.chromium.payments.mojom.Payme
         // Note that a null value would be assigned when the params are invalid.
         mPaymentRequestService =
                 mPaymentRequestServiceCreator.createPaymentRequestServiceIfParamsValid(client,
-                        methodData, details, options, googlePayBridgeEligible,
+                        methodData, details, options, false,
                         this::onPaymentRequestServiceClosed);
     }
 
--- a/chrome/browser/extensions/extension_management.cc
+++ b/chrome/browser/extensions/extension_management.cc
@@ -77,7 +77,7 @@ ExtensionManagement::ExtensionManagement
                              pref_change_callback);
   pref_change_registrar_.Add(prefs::kCloudExtensionRequestEnabled,
                              pref_change_callback);
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
   pref_change_registrar_.Add(enterprise_reporting::kCloudReportingEnabled,
                              pref_change_callback);
 #endif
--- a/chrome/browser/enterprise/reporting/prefs.cc
+++ b/chrome/browser/enterprise/reporting/prefs.cc
@@ -19,7 +19,6 @@ const char kLastUploadVersion[] = "enter
 void RegisterLocalStatePrefs(PrefRegistrySimple* registry) {
   // This is also registered as a Profile pref which will be removed after
   // the migration.
-  registry->RegisterBooleanPref(kCloudReportingEnabled, false);
   registry->RegisterTimePref(kLastUploadTimestamp, base::Time());
 #if !defined(OS_CHROMEOS)
   registry->RegisterStringPref(kLastUploadVersion, std::string());
--- a/chrome/browser/nearby_sharing/nearby_notification_manager.cc
+++ b/chrome/browser/nearby_sharing/nearby_notification_manager.cc
@@ -55,7 +55,6 @@ message_center::Notification CreateNearb
                                  kNearbyNotifier),
       /*optional_fields=*/{},
       /*delegate=*/nullptr);
-  notification.set_vector_small_image(kNearbyShareIcon);
 
   // TODO(crbug.com/1102348): Also show settings for other platforms once there
   // is a nearby settings page in Chrome browser.
--- a/chrome/browser/ui/views/payments/secure_payment_confirmation_view.cc
+++ b/chrome/browser/ui/views/payments/secure_payment_confirmation_view.cc
@@ -8,14 +8,6 @@
 
 namespace payments {
 
-// static
-base::WeakPtr<SecurePaymentConfirmationView>
-SecurePaymentConfirmationView::Create() {
-  return (new SecurePaymentConfirmationDialogView(
-              /*observer_for_test=*/nullptr))
-      ->GetWeakPtr();
-}
-
 SecurePaymentConfirmationView::SecurePaymentConfirmationView() = default;
 SecurePaymentConfirmationView::~SecurePaymentConfirmationView() = default;
 
--- a/chrome/browser/ui/views/hats/hats_bubble_view.cc
+++ b/chrome/browser/ui/views/hats/hats_bubble_view.cc
@@ -74,14 +74,7 @@ void HatsBubbleView::ShowOnContentReady(
   // The bubble will only show after the survey content is retrieved.
   // If it fails due to no internet connection or any other reason, the bubble
   // will not show.
-  if (base::FeatureList::IsEnabled(
-          features::kHappinessTrackingSurveysForDesktopMigration)) {
-    // Self deleting on close.
-    new HatsNextWebDialog(browser, site_id, std::move(success_callback),
-                          std::move(failure_callback));
-  } else {
-    HatsWebDialog::Create(browser, site_id);
-  }
+  HatsWebDialog::Create(browser, site_id);
 }
 
 void HatsBubbleView::Show(Browser* browser,
--- a/chrome/browser/ui/views/hats/hats_next_web_dialog.cc
+++ b/chrome/browser/ui/views/hats/hats_next_web_dialog.cc
@@ -185,9 +185,6 @@ HatsNextWebDialog::~HatsNextWebDialog()
     otr_profile_->RemoveObserver(this);
     ProfileDestroyer::DestroyProfileWhenAppropriate(otr_profile_);
   }
-  auto* service = HatsServiceFactory::GetForProfile(browser_->profile(), false);
-  DCHECK(service);
-  service->HatsNextDialogClosed();
 
   // Explicitly clear the delegate to ensure it is not invalid between now and
   // when the web contents is destroyed in the base class.
@@ -197,10 +194,6 @@ HatsNextWebDialog::~HatsNextWebDialog()
 GURL HatsNextWebDialog::GetParameterizedHatsURL() const {
   GURL param_url =
       net::AppendQueryParameter(hats_survey_url_, "trigger_id", trigger_id_);
-  if (base::FeatureList::IsEnabled(
-          features::kHappinessTrackingSurveysForDesktopDemo)) {
-    param_url = net::AppendQueryParameter(param_url, "enable_testing", "true");
-  }
   return param_url;
 }
 
@@ -217,10 +210,6 @@ void HatsNextWebDialog::OnSurveyStateUpd
 
   if (state == "loaded") {
     // Record that the survey was shown, and display the widget.
-    auto* service =
-        HatsServiceFactory::GetForProfile(browser_->profile(), false);
-    DCHECK(service);
-    service->RecordSurveyAsShown(trigger_id_);
     received_survey_loaded_ = true;
     ShowWidget();
     std::move(success_callback_).Run();
--- a/components/media_router/browser/android/media_router_android.h
+++ b/components/media_router/browser/android/media_router_android.h
@@ -14,6 +14,7 @@
 #include "base/macros.h"
 #include "base/observer_list.h"
 #include "components/media_router/browser/android/media_router_android_bridge.h"
+#include "components/media_router/browser/logger_impl.h"
 #include "components/media_router/browser/media_router_base.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
 #include "mojo/public/cpp/bindings/receiver.h"
@@ -88,6 +89,9 @@ class MediaRouterAndroid : public MediaR
   // Notifies the media router about a message received from the media route.
   void OnMessage(const MediaRoute::Id& route_id, const std::string& message);
 
+ protected:
+  LoggerImpl* GetLogger() override;
+
  private:
   friend class MediaRouterAndroidTest;
 
@@ -183,6 +187,8 @@ class MediaRouterAndroid : public MediaR
                      std::vector<std::unique_ptr<PresentationConnectionProxy>>>
       presentation_connections_;
 
+  LoggerImpl logger_;
+
   DISALLOW_COPY_AND_ASSIGN(MediaRouterAndroid);
 };
 
--- a/components/media_router/browser/media_router.h
+++ b/components/media_router/browser/media_router.h
@@ -27,12 +27,10 @@
 #include "media/base/flinging_controller.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
 #include "components/media_router/browser/logger_impl.h"
 #include "components/media_router/common/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
-#endif  // !defined(OS_ANDROID)
 
 namespace content {
 class WebContents;
@@ -183,7 +181,6 @@ class MediaRouter : public KeyedService
   virtual std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) = 0;
 
-#if !defined(OS_ANDROID)
   // Binds |controller| for sending media commands to a route. The controller
   // will notify |observer| whenever there is a change to the status of the
   // media. It may invalidate bindings from previous calls to this method.
@@ -197,7 +194,6 @@ class MediaRouter : public KeyedService
 
   // Returns logs collected from Media Router components.
   virtual base::Value GetLogs() const = 0;
-#endif  // !defined(OS_ANDROID)
 
   // Returns media router state as a JSON string represented by base::Value.
   // Includes known sinks and sink compatibility with media sources.
--- a/components/media_router/browser/media_router_base.cc
+++ b/components/media_router/browser/media_router_base.cc
@@ -87,7 +87,6 @@ MediaRouterBase::GetFlingingController(c
   return nullptr;
 }
 
-#if !defined(OS_ANDROID)
 void MediaRouterBase::GetMediaController(
     const MediaRoute::Id& route_id,
     mojo::PendingReceiver<mojom::MediaController> controller,
@@ -96,7 +95,6 @@ void MediaRouterBase::GetMediaController
 base::Value MediaRouterBase::GetLogs() const {
   return base::Value();
 }
-#endif  // !defined(OS_ANDROID)
 
 MediaRouterBase::MediaRouterBase() : initialized_(false) {}
 
--- a/components/media_router/browser/media_router_base.h
+++ b/components/media_router/browser/media_router_base.h
@@ -19,11 +19,9 @@
 #include "components/media_router/common/media_route.h"
 #include "third_party/blink/public/mojom/presentation/presentation.mojom.h"
 
-#if !defined(OS_ANDROID)
 #include "components/media_router/common/mojom/media_controller.mojom.h"
 #include "mojo/public/cpp/bindings/pending_receiver.h"
 #include "mojo/public/cpp/bindings/pending_remote.h"
-#endif  // !defined(OS_ANDROID)
 
 namespace media_router {
 
@@ -45,13 +43,11 @@ class MediaRouterBase : public MediaRout
   std::vector<MediaRoute> GetCurrentRoutes() const override;
   std::unique_ptr<media::FlingingController> GetFlingingController(
       const MediaRoute::Id& route_id) override;
-#if !defined(OS_ANDROID)
   void GetMediaController(
       const MediaRoute::Id& route_id,
       mojo::PendingReceiver<mojom::MediaController> controller,
       mojo::PendingRemote<mojom::MediaStatusObserver> observer) override;
   base::Value GetLogs() const override;
-#endif  // !defined(OS_ANDROID)
   base::Value GetState() const override;
   void GetProviderState(
       MediaRouteProviderId provider_id,
--- a/chrome/browser/ui/browser_list_observer.h
+++ b/chrome/browser/ui/browser_list_observer.h
@@ -7,10 +7,6 @@
 
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Browser;
 
 class BrowserListObserver {
--- a/chrome/browser/ui/browser_list.h
+++ b/chrome/browser/ui/browser_list.h
@@ -16,10 +16,6 @@
 #include "base/observer_list.h"
 #include "build/build_config.h"
 
-#if defined(OS_ANDROID)
-#error This file should only be included on desktop.
-#endif
-
 class Browser;
 class Profile;
 
--- a/components/media_router/browser/android/media_router_android.cc
+++ b/components/media_router/browser/android/media_router_android.cc
@@ -345,6 +345,10 @@ void MediaRouterAndroid::RemoveRoute(con
     observer.OnRoutesUpdated(active_routes_, std::vector<MediaRoute::Id>());
 }
 
+LoggerImpl* MediaRouterAndroid::GetLogger() {
+  return &logger_;
+}
+
 std::unique_ptr<media::FlingingController>
 MediaRouterAndroid::GetFlingingController(const MediaRoute::Id& route_id) {
   return bridge_->GetFlingingController(route_id);
--- a/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
+++ b/chrome/browser/ui/views/permission_bubble/permission_prompt_bubble_view.cc
@@ -232,10 +232,6 @@ void PermissionPromptBubbleView::AddPerm
       provider->GetDistanceMetric(views::DISTANCE_RELATED_LABEL_HORIZONTAL)));
 
   constexpr int kPermissionIconSize = 18;
-  auto* icon = line_container->AddChildView(
-      std::make_unique<views::ColorTrackingIconView>(request->GetIconId(),
-                                                     kPermissionIconSize));
-  icon->SetVerticalAlignment(views::ImageView::Alignment::kLeading);
 
   auto* label = line_container->AddChildView(
       std::make_unique<views::Label>(request->GetMessageTextFragment()));
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -3250,7 +3250,6 @@ const char kWalletRequiresFirstSyncSetup
 
 // Non-Android -----------------------------------------------------------------
 
-#else  // !defined(OS_ANDROID)
 
 extern const char kAllowAllSitesToInitiateMirroringName[] =
     "Allow all sites to initiate mirroring";
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1876,7 +1876,6 @@ extern const char kWalletRequiresFirstSy
 
 // Non-Android ----------------------------------------------------------------
 
-#else  // !defined(OS_ANDROID)
 
 extern const char kAllowAllSitesToInitiateMirroringName[];
 extern const char kAllowAllSitesToInitiateMirroringDescription[];
--- a/chrome/browser/intranet_redirect_detector.h
+++ b/chrome/browser/intranet_redirect_detector.h
@@ -27,11 +27,6 @@ class SimpleURLLoader;
 
 class PrefRegistrySimple;
 
-#if !(defined(OS_MAC) || defined(OS_WIN) || defined(OS_LINUX) || \
-      defined(OS_CHROMEOS))
-#error "IntranetRedirectDetector should only be built on Desktop platforms."
-#endif
-
 // This object is responsible for determining whether the user is on a network
 // that redirects requests for intranet hostnames to another site, and if so,
 // tracking what that site is (including across restarts via a pref).  For
--- a/chrome/browser/profiles/profile_attributes_storage.cc
+++ b/chrome/browser/profiles/profile_attributes_storage.cc
@@ -31,7 +31,7 @@
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/gfx/image/image.h"
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 #include "chrome/browser/ui/browser_list.h"
 #endif
 
@@ -390,7 +390,7 @@ void ProfileAttributesStorage::RemoveObs
   observer_list_.RemoveObserver(obs);
 }
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
 void ProfileAttributesStorage::RecordDeletedProfileState(
     ProfileAttributesEntry* entry) {
   DCHECK(entry);
--- a/chrome/browser/profiles/profile_attributes_storage.h
+++ b/chrome/browser/profiles/profile_attributes_storage.h
@@ -97,7 +97,7 @@ class ProfileAttributesStorage
   bool IsDefaultProfileName(const base::string16& name,
                             bool include_check_for_legacy_profile_name) const;
 
-#if !defined(OS_ANDROID)
+#if defined(OS_ANDROID)
   // Records statistics about a profile `entry` that is being deleted. If the
   // profile has opened browser window(s) in the moment of deletion, this
   // function must be called before these windows get closed.
--- a/chrome/browser/ui/browser.cc
+++ b/chrome/browser/ui/browser.cc
@@ -32,6 +32,7 @@
 #include "base/time/time.h"
 #include "build/build_config.h"
 #include "chrome/app/chrome_command_ids.h"
+#include "chrome/browser/android/tab_android.h"
 #include "chrome/browser/app_mode/app_mode_utils.h"
 #include "chrome/browser/autofill/personal_data_manager_factory.h"
 #include "chrome/browser/background/background_contents.h"
@@ -128,7 +129,6 @@
 #include "chrome/browser/ui/sync/browser_synced_window_delegate.h"
 #include "chrome/browser/ui/tab_contents/core_tab_helper.h"
 #include "chrome/browser/ui/tab_dialogs.h"
-#include "chrome/browser/ui/tab_helpers.h"
 #include "chrome/browser/ui/tab_modal_confirm_dialog.h"
 #include "chrome/browser/ui/tabs/tab_group.h"
 #include "chrome/browser/ui/tabs/tab_group_model.h"
@@ -1830,7 +1830,7 @@ void Browser::WebContentsCreated(WebCont
   // requests for its initial navigation will start immediately. The WebContents
   // will later be inserted into this browser using Browser::Navigate via
   // AddNewContents.
-  TabHelpers::AttachTabHelpers(new_contents);
+  TabAndroid::AttachTabHelpers(new_contents);
 
   // Make the tab show up in the task manager.
   task_manager::WebContentsTags::CreateForTabContents(new_contents);
@@ -1840,7 +1840,7 @@ void Browser::PortalWebContentsCreated(W
   ChromeMetricsServiceAccessor::RegisterSyntheticFieldTrial("PortalsActive",
                                                             "Enabled");
 
-  TabHelpers::AttachTabHelpers(portal_web_contents);
+  TabAndroid::AttachTabHelpers(portal_web_contents);
 
   // Make the portal show up in the task manager.
   task_manager::WebContentsTags::CreateForPortal(portal_web_contents);
--- a/chrome/browser/ui/browser_tab_strip_model_delegate.cc
+++ b/chrome/browser/ui/browser_tab_strip_model_delegate.cc
@@ -8,6 +8,7 @@
 
 #include "base/bind.h"
 #include "base/command_line.h"
+#include "chrome/browser/android/tab_android.h"
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/sessions/tab_restore_service_factory.h"
 #include "chrome/browser/task_manager/web_contents_tags.h"
@@ -15,7 +16,6 @@
 #include "chrome/browser/ui/browser_commands.h"
 #include "chrome/browser/ui/browser_tabstrip.h"
 #include "chrome/browser/ui/browser_window.h"
-#include "chrome/browser/ui/tab_helpers.h"
 #include "chrome/browser/ui/tabs/tab_group.h"
 #include "chrome/browser/ui/tabs/tab_group_model.h"
 #include "chrome/browser/ui/tabs/tab_strip_model.h"
@@ -87,7 +87,7 @@ Browser* BrowserTabStripModelDelegate::C
 
 void BrowserTabStripModelDelegate::WillAddWebContents(
     content::WebContents* contents) {
-  TabHelpers::AttachTabHelpers(contents);
+  TabAndroid::AttachTabHelpers(contents);
 
   // Make the tab show up in the task manager.
   task_manager::WebContentsTags::CreateForTabContents(contents);
--- a/chrome/browser/ui/omnibox/chrome_omnibox_navigation_observer.cc
+++ b/chrome/browser/ui/omnibox/chrome_omnibox_navigation_observer.cc
@@ -7,7 +7,6 @@
 #include "base/bind.h"
 #include "chrome/browser/autocomplete/shortcuts_backend_factory.h"
 #include "chrome/browser/infobars/infobar_service.h"
-#include "chrome/browser/intranet_redirect_detector.h"
 #include "chrome/browser/search_engines/template_url_service_factory.h"
 #include "chrome/browser/ui/omnibox/alternate_nav_infobar_delegate.h"
 #include "components/omnibox/browser/shortcuts_backend.h"
@@ -46,14 +45,7 @@ bool ResponseCodeIndicatesSuccess(int re
 // Returns true if |final_url| doesn't represent an ISP hijack of
 // |original_url|, based on the IntranetRedirectDetector's RedirectOrigin().
 bool IsValidNavigation(const GURL& original_url, const GURL& final_url) {
-  const GURL& redirect_url(IntranetRedirectDetector::RedirectOrigin());
-  return !redirect_url.is_valid() ||
-         net::registry_controlled_domains::SameDomainOrHost(
-             original_url, final_url,
-             net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES) ||
-         !net::registry_controlled_domains::SameDomainOrHost(
-             final_url, redirect_url,
-             net::registry_controlled_domains::EXCLUDE_PRIVATE_REGISTRIES);
+  return true;
 }
 
 // Returns true if |origin| is a http URL and |destination| is a https URL and
--- a/chrome/android/java/src/org/chromium/chrome/browser/payments/ChromePaymentRequestService.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/payments/ChromePaymentRequestService.java
@@ -154,8 +154,7 @@ public class ChromePaymentRequestService
     @Override
     public void onWhetherGooglePayBridgeEligible(boolean googlePayBridgeEligible,
             WebContents webContents, PaymentMethodData[] rawMethodData) {
-        mIsGooglePayBridgeActivated = googlePayBridgeEligible
-                && SkipToGPayHelperUtil.canActivateExperiment(mWebContents, rawMethodData);
+        mIsGooglePayBridgeActivated = false;
     }
 
     // Implements BrowserPaymentRequest:
@@ -207,8 +206,6 @@ public class ChromePaymentRequestService
         assert details != null;
 
         if (mIsGooglePayBridgeActivated) {
-            PaymentMethodData data = methodData.get(MethodStrings.GOOGLE_PAY);
-            mSkipToGPayHelper = new SkipToGPayHelper(options, data.gpayBridgeData);
         }
 
         if (!parseAndValidateDetailsFurtherIfNeeded(details)) {
@@ -438,11 +435,6 @@ public class ChromePaymentRequestService
             // If skip-to-GPay flow is activated, ignore all other payment methods, which can be
             // either "basic-card" or "https://android.com/pay". The latter is safe to ignore
             // because merchant has already requested Google Pay.
-            if (!method.equals(MethodStrings.GOOGLE_PAY)) continue;
-            if (methodData.gpayBridgeData != null
-                    && !methodData.gpayBridgeData.stringifiedData.isEmpty()) {
-                methodData.stringifiedData = methodData.gpayBridgeData.stringifiedData;
-            }
             result.put(method, methodData);
         }
         methodDataMap.clear();
--- a/chrome/browser/web_applications/extensions/bookmark_app_provider.cc
+++ b/chrome/browser/web_applications/extensions/bookmark_app_provider.cc
@@ -47,8 +47,9 @@ WebAppProvider::CreateBookmarkAppInstall
 }
 
 void WebAppProviderFactory::DependsOnExtensionsSystem() {
-  DependsOn(
-      extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
+  if (extensions::ExtensionsBrowserClient::Get())
+    DependsOn(
+        extensions::ExtensionsBrowserClient::Get()->GetExtensionSystemFactory());
 }
 
 }  // namespace web_app
--- a/components/enterprise/browser/enterprise_switches.cc
+++ b/components/enterprise/browser/enterprise_switches.cc
@@ -8,7 +8,7 @@
 
 namespace switches {
 
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
 // Enables the Chrome Browser Cloud Management integration on Chromium builds.
 // CBCM is always enabled in branded builds.
 const char kEnableChromeBrowserCloudManagement[] =
--- a/components/enterprise/browser/enterprise_switches.h
+++ b/components/enterprise/browser/enterprise_switches.h
@@ -12,7 +12,7 @@
 
 namespace switches {
 
-#if !defined(OS_CHROMEOS) && !defined(OS_ANDROID)
+#if !defined(OS_CHROMEOS) && defined(OS_ANDROID)
 extern const char kEnableChromeBrowserCloudManagement[];
 #endif
 
--- a/content/browser/tracing/generate_trace_viewer_grd.py
+++ b/content/browser/tracing/generate_trace_viewer_grd.py
@@ -26,7 +26,7 @@ kGrdTemplate = '''<?xml version="1.0" en
   </outputs>
   <release seq="1">
     <includes>
-      <if expr="not is_android"></if>
+      <if expr="is_android"></if>
     </includes>
   </release>
 </grit>
--- a/content/browser/media/session/audio_focus_delegate_default.cc
+++ b/content/browser/media/session/audio_focus_delegate_default.cc
@@ -189,11 +189,4 @@ void AudioFocusDelegateDefault::EnsureSe
   audio_focus_->SetSource(media_session_->GetSourceId(), kAudioFocusSourceName);
 }
 
-// static
-std::unique_ptr<AudioFocusDelegate> AudioFocusDelegate::Create(
-    MediaSessionImpl* media_session) {
-  return std::unique_ptr<AudioFocusDelegate>(
-      new AudioFocusDelegateDefault(media_session));
-}
-
 }  // namespace content
--- a/chrome/browser/enterprise/reporting/report_scheduler_desktop.cc
+++ b/chrome/browser/enterprise/reporting/report_scheduler_desktop.cc
@@ -28,7 +28,7 @@ constexpr int kThrottleTimeInMinute = 1;
 // TODO(crbug.com/1102047): Get rid of this function after Chrome OS reporting
 // logic has been split to its own delegates.
 constexpr bool ShouldReportUpdates() {
-#if defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS)
   return false;
 #else
   return true;
@@ -36,8 +36,7 @@ constexpr bool ShouldReportUpdates() {
 }
 
 bool ShouldReportExtensionRequestRealtime() {
-  return base::FeatureList::IsEnabled(
-      features::kEnterpriseRealtimeExtensionRequest);
+  return false;
 }
 
 }  // namespace
--- a/chrome/browser/password_manager/multi_profile_credentials_filter.cc
+++ b/chrome/browser/password_manager/multi_profile_credentials_filter.cc
@@ -28,8 +28,7 @@ bool MultiProfileCredentialsFilter::Shou
     return true;  // This happens in incognito.
   if (!password_manager::sync_util::IsGaiaCredentialPage(form.signon_realm))
     return true;
-  if (!base::FeatureList::IsEnabled(kDiceWebSigninInterceptionFeature))
-    return true;
+  return true;
 
   // Note: this function is only called for "Save" bubbles, but not for "Update"
   // bubbles.
--- a/chrome/browser/devtools/devtools_ui_bindings.cc
+++ b/chrome/browser/devtools/devtools_ui_bindings.cc
@@ -1539,21 +1539,10 @@ void ShowSurveyCallback(const DevToolsUI
 
 void DevToolsUIBindings::ShowSurvey(const DispatchCallback& callback,
                                     const std::string& trigger) {
-  HatsService* hats_service =
-      HatsServiceFactory::GetForProfile(profile_->GetOriginalProfile(), true);
-  hats_service->LaunchSurvey(
-      trigger, base::BindOnce(ShowSurveyCallback, callback, true),
-      base::BindOnce(ShowSurveyCallback, callback, false));
 }
 
 void DevToolsUIBindings::CanShowSurvey(const DispatchCallback& callback,
                                        const std::string& trigger) {
-  HatsService* hats_service =
-      HatsServiceFactory::GetForProfile(profile_->GetOriginalProfile(), true);
-  bool can_show = hats_service->CanShowSurvey(trigger);
-  base::DictionaryValue response;
-  response.SetBoolean("canShowSurvey", can_show);
-  callback.Run(&response);
 }
 
 void DevToolsUIBindings::SetDelegate(Delegate* delegate) {
--- a/chrome/browser/ui/views/profiles/profile_picker_view.cc
+++ b/chrome/browser/ui/views/profiles/profile_picker_view.cc
@@ -405,19 +405,6 @@ void ProfilePickerView::OnRefreshTokenUp
                      weak_ptr_factory_.GetWeakPtr(), account_info.email),
       extended_account_info_timeout_);
 
-  // DiceTurnSyncOnHelper deletes itself once done.
-  new DiceTurnSyncOnHelper(
-      signed_in_profile_being_created_,
-      signin_metrics::AccessPoint::ACCESS_POINT_USER_MANAGER,
-      signin_metrics::PromoAction::PROMO_ACTION_NO_SIGNIN_PROMO,
-      signin_metrics::Reason::REASON_SIGNIN_PRIMARY_ACCOUNT,
-      account_info.account_id,
-      DiceTurnSyncOnHelper::SigninAbortedMode::KEEP_ACCOUNT,
-      std::make_unique<ProfilePickerViewSyncDelegate>(
-          signed_in_profile_being_created_,
-          base::BindOnce(&ProfilePickerView::FinishSignedInCreationFlow,
-                         weak_ptr_factory_.GetWeakPtr())),
-      std::move(sync_consent_completed_closure));
 }
 
 void ProfilePickerView::OnExtendedAccountInfoUpdated(
--- a/chrome/browser/ui/views/profiles/profile_picker_view_sync_delegate.cc
+++ b/chrome/browser/ui/views/profiles/profile_picker_view_sync_delegate.cc
@@ -41,16 +41,6 @@ ProfilePickerViewSyncDelegate::~ProfileP
 void ProfilePickerViewSyncDelegate::ShowLoginError(
     const std::string& email,
     const std::string& error_message) {
-  // Open the browser and when it's done, show the login error.
-  // TODO(crbug.com/1126913): In some cases, the current behavior is not ideal
-  // because it is not designed with profile creation in mind. Concretely, for
-  // sync not being available because there already is a syncing profile with
-  // this account, we should likely auto-delete the profile and offer to either
-  // switch or to start sign-in once again.
-  std::move(open_browser_callback_)
-      .Run(base::BindOnce(
-          &DiceTurnSyncOnHelper::Delegate::ShowLoginErrorForBrowser, email,
-          error_message));
 }
 
 void ProfilePickerViewSyncDelegate::ShowMergeSyncDataConfirmation(
@@ -65,11 +55,6 @@ void ProfilePickerViewSyncDelegate::Show
     const std::string& email,
     DiceTurnSyncOnHelper::SigninChoiceCallback callback) {
   enterprise_confirmation_shown_ = true;
-  // Open the browser and when it's done, show the confirmation dialog.
-  std::move(open_browser_callback_)
-      .Run(base::BindOnce(&DiceTurnSyncOnHelper::Delegate::
-                              ShowEnterpriseAccountConfirmationForBrowser,
-                          email, std::move(callback)));
 }
 
 void ProfilePickerViewSyncDelegate::ShowSyncConfirmation(
--- a/components/payments/content/android/java/src/org/chromium/components/payments/InvalidPaymentRequest.java
+++ b/components/payments/content/android/java/src/org/chromium/components/payments/InvalidPaymentRequest.java
@@ -24,8 +24,7 @@ public final class InvalidPaymentRequest
 
     @Override
     public void init(PaymentRequestClient client, PaymentMethodData[] unusedMethodData,
-            PaymentDetails unusedDetails, PaymentOptions unusedOptions,
-            boolean unusedGooglePayBridgeEligible) {
+            PaymentDetails unusedDetails, PaymentOptions unusedOptions) {
         mClient = client;
     }
 
